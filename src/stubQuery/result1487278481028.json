{"filter":1,"results":[{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/sitecapturer/2.1/org/htmlparser/parserapplications/SiteCapturer.java","method":"process","pos":470,"doc":"/** \n * Process a single page.\n * @param filter The filter to apply to the collected nodes.\n * @exception ParserException If a parse error occurs.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Page.java","method":"getCharacter","pos":713,"doc":"/** \n * Read the character at the given cursor position. The cursor position can be only behind or equal to the current source position. Returns end of lines (EOL) as \\n, by converting \\r and \\r\\n to \\n, and updates the end-of-line index accordingly. Advances the cursor position by one (or two in the \\r\\n case).\n * @param cursor The position to read at.\n * @return The character at that position, and modifies the cursor toprepare for the next read. If the source is exhausted a zero is returned.\n * @exception ParserException If an IOException on the underlying sourceoccurs, or an attempt is made to read characters in the future (the cursor position is ahead of the underlying stream)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":1746,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseTag","pos":973,"doc":"/** \n * Parse a tag. Parse the name and attributes from a start tag.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2<p> <cite> 3.2.2 Attributes<p> Elements may have associated properties, called attributes, which may have values (by default, or set by authors or scripts). Attribute/value pairs appear before the final \">\" of an element's start tag. Any number of (legal) attribute value pairs, separated by spaces, may appear in an element's start tag. They may appear in any order.<p> In this example, the id attribute is set for an H1 element: <code> &lt;H1 id=\"section1\"&gt; <\/code> This is an identified heading thanks to the id attribute <code> &lt;/H1&gt; <\/code> By default, SGML requires that all attribute values be delimited using either double quotation marks (ASCII decimal 34) or single quotation marks (ASCII decimal 39). Single quote marks can be included within the attribute value when the value is delimited by double quote marks, and vice versa. Authors may also use numeric character references to represent double quotes (&amp;#34;) and single quotes (&amp;#39;). For doublequotes authors can also use the character entity reference &amp;quot;.<p> In certain cases, authors may specify the value of an attribute without any quotation marks. The attribute value may only contain letters (a-z and A-Z), digits (0-9), hyphens (ASCII decimal 45), periods (ASCII decimal 46), underscores (ASCII decimal 95), and colons (ASCII decimal 58). We recommend using quotation marks even when it is possible to eliminate them.<p> Attribute names are always case-insensitive.<p> Attribute values are generally case-insensitive. The definition of each attribute in the reference manual indicates whether its value is case-insensitive.<p> All the attributes defined by this specification are listed in the attribute index.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - outside of any attribute<\/li> <li>state 1 - within attributre name<\/li> <li>state 2 - equals hit<\/li> <li>state 3 - within naked attribute value.<\/li> <li>state 4 - within single quoted attribute value<\/li> <li>state 5 - within double quoted attribute value<\/li> <li>state 6 - whitespaces after attribute name could lead to state 2 (=)or state 0<\/li> <\/ol> <p> The starting point for the various components is stored in an array of integers that match the initiation point for the states one-for-one, i.e. bookmarks[0] is where state 0 began, bookmarks[1] is where state 1 began, etc. Attributes are stored in a <code>Vector<\/code> having one slot for each whitespace or attribute/value pair. The first slot is for attribute name (kind of like a standalone attribute).\n * @param start The position at which to start scanning.\n * @return The parsed tag.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseAttribute","pos":2952,"doc":"/** \n * consumes the '>' terminating start tags.\n * @param isempty flag is passed as array so it can be modified\n * @param asp asp Node, passed as array so it can be modified\n * @param php php Node, passed as array so it can be modified\n * @return parsed attribute\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/thumbelina/2.1/org/htmlparser/lexerapplications/thumbelina/Thumbelina.java","method":"extractImageLinks","pos":754,"doc":"/** \n * Get the links of an element of a document. Only gets the links on IMG elements that reference another image. The latter is based on suffix (.jpg, .gif and .png).\n * @param lexer The fully conditioned lexer, ready to rock.\n * @param docbase The url to read.\n * @return The URLs, targets of the IMG links;\n * @exception IOException If the underlying infrastructure throws it.\n * @exception ParserException If there is a problem parsing the url.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/FilterBuilder.java","method":"makeProgram","pos":687,"doc":"/** \n * Makes a program like: <pre> // Generated by FilterBuilder. http://htmlparser.org // [aced0005737200206f72672e68746d6c7061727365722e66696c746572732e416e6446696c74657224c30516b2b7b2120200015b000b6d5072656469636174657374001c5b4c6f72672f68746d6c7061727365722f4e6f646546696c7465723b78707572001c5b4c6f72672e68746d6c7061727365722e4e6f646546696c7465723b8f17479b1d5f7992020000787000000002737200246f72672e68746d6c7061727365722e66696c746572732e5461674e616d6546696c746572b28b2601a614890f0200014c00056d4e616d657400124c6a6176612f6c616e672f537472696e673b78707400044d455441737200296f72672e68746d6c7061727365722e66696c746572732e48617341747472696275746546696c74657296abdfb3b0714cda0200024c000a6d41747472696275746571007e00064c00066d56616c756571007e000678707400046e616d6570] import org.htmlparser.*; import org.htmlparser.filters.*; import org.htmlparser.beans.*; import org.htmlparser.util.*; public class Test { public static void main (String args[]) { TagNameFilter filter0 = new TagNameFilter (); filter0.setName (\"META\"); HasAttributeFilter filter1 = new HasAttributeFilter (); filter1.setAttributeName (\"name\"); NodeFilter[] array0 = new NodeFilter[2]; array0[0] = filter0; array0[1] = filter1; AndFilter filter2 = new AndFilter (); filter2.setPredicates (array0); NodeFilter[] array1 = new NodeFilter[1]; array1[0] = filter2; FilterBean bean = new FilterBean (); bean.setFilters (array1); if (0 != args.length) { bean.setURL (args[0]); System.out.println (bean.getNodes ().toHtml ()); } else System.out.println (\"Usage: java -classpath .:htmlparser.jar:htmllexer.jar Test <url>\"); } } <\/pre>\n * @param name The name of the class. \n * @param out The buffer to append to.\n * @param bean The bean to extract the filters from to make the program.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":266,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/http/ConnectionManager.java","method":"parseCookies","pos":1082,"doc":"/** \n * Check for cookie and parse into cookie jar.\n * @param connection The connection to extract cookie information from.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/http/ConnectionManager.java","method":"openConnection","pos":547,"doc":"/** \n * Opens a connection using the given url.\n * @param url The url to open.\n * @return The connection.\n * @exception ParserException if an i/o exception occurs accessing the url.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseEntity","pos":648,"doc":"/** \n * Parse an html entity.\n * @param mode mode\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseString","pos":744,"doc":"/** \n * Parse a string node. Scan characters until \"&lt;/\", \"&lt;%\", \"&lt;!\" or &lt; followed by a letter is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":1063,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":1883,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":3050,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2884,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/ScriptDecoder.java","method":"Decode","pos":267,"doc":"/** \n * Decode script encoded by the Microsoft obfuscator.\n * @param page The source for encoded text.\n * @param cursor The position at which to start decoding.This is advanced to the end of the encoded text.\n * @return The plaintext.\n * @exception ParserException If an error is discovered while decoding.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":495,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":692,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseValue","pos":3202,"doc":"/** \n * Parse an attribute value.\n * @param name attribute name\n * @param foldCase fold case?\n * @param isempty is attribute empty? Passed as an array reference to allow modification\n * @param pdelim delimiter, passed as an array reference to allow modification\n * @return parsed value\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"nextNode","pos":320,"doc":"/** \n * Get the next node from the source.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return A Remark, Text or Tag, or <code>null<\/code> if nomore lexemes are present.\n * @exception ParserException If there is a problem with theunderlying page.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2506,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2727,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseJsp","pos":1387,"doc":"/** \n * Parse a java server page node. Scan characters until \"%&gt;\" is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parsePI","pos":1568,"doc":"/** \n * Parse an XML processing instruction. Scan characters until \"?&gt;\" is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/CompositeTagScanner.java","method":"scan","pos":70,"doc":"/** \n * Collect the children. <p>An initial test is performed for an empty XML tag, in which case the start tag and end tag of the returned tag are the same and it has no children.<p> If it's not an empty XML tag, the lexer is repeatedly asked for subsequent nodes until an end tag is found or a node is encountered that matches the tag ender set or end tag ender set. In the latter case, a virtual end tag is created. Each node found that is not the end tag is added to the list of children. The end tag is special and not a child.<p> Nodes that also have a CompositeTagScanner as their scanner are recursed into, which provides the nested structure of an HTML page. This method operates in two possible modes, depending on a private boolean. It can recurse on the JVM stack, which has caused some overflow problems in the past, or it can use the supplied stack argument to nest scanning of child tags within itself. The former is left as an option in the code, mostly to help subsequent modifiers visualize what the internal nesting is doing.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of subsequent nodes.\n * @param stack The parse stack. May contain pending tags that enclosethis tag.\n * @return The resultant tag (may be unchanged).\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Tidy.java","method":"parse","pos":384,"doc":"/** \n * Internal routine that actually does the parsing.\n * @param streamIn tidy StreamIn\n * @param o tidy Out\n * @return parsed org.w3c.tidy.Node\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseCDATA","pos":431,"doc":"/** \n * Return CDATA as a text node. Slightly less rigid than  {@link #parseCDATA()} this method provides forparsing CDATA that may contain quoted strings that have embedded ETAGO (\"&lt;/\") delimiters and skips single and multiline comments.\n * @param quotesmart If <code>true<\/code> the strict definition of CDATA isextended to allow for single or double quoted ETAGO (\"&lt;/\") sequences.\n * @return The <code>TextNode<\/code> of the CDATA or <code>null<\/code> if none.\n * @see #parseCDATA()\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2009,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"}]}