{"filter":1,"results":[{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/util/ParserUtils.java","method":"trimTags","pos":1070,"doc":"/** \n * Trim all tags in the input string and return a string like the input one without the tags and their content (optional). <BR>Use NodeFilter class as input parameter instead of tags[] string array.\n * @see ParserUtils#trimTags (String input, String[] tags, boolean recursive, boolean insideTag).\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"nextNode","pos":320,"doc":"/** \n * Get the next node from the source.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return A Remark, Text or Tag, or <code>null<\/code> if nomore lexemes are present.\n * @exception ParserException If there is a problem with theunderlying page.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseCDATA","pos":431,"doc":"/** \n * Return CDATA as a text node. Slightly less rigid than  {@link #parseCDATA()} this method provides forparsing CDATA that may contain quoted strings that have embedded ETAGO (\"&lt;/\") delimiters and skips single and multiline comments.\n * @param quotesmart If <code>true<\/code> the strict definition of CDATA isextended to allow for single or double quoted ETAGO (\"&lt;/\") sequences.\n * @return The <code>TextNode<\/code> of the CDATA or <code>null<\/code> if none.\n * @see #parseCDATA()\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/wrappers/HasAttributeFilterWrapper.java","method":"setNodeFilter","pos":228,"doc":"/** \n * Assign the underlying node filter for this wrapper.\n * @param filter The filter to wrap.\n * @param context The parser to use for conditioning this filter.Some filters need contextual information to provide to the user, i.e. for tag names or attribute names or values, so the Parser context is provided. \n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseAttribute","pos":2952,"doc":"/** \n * consumes the '>' terminating start tags.\n * @param isempty flag is passed as array so it can be modified\n * @param asp asp Node, passed as array so it can be modified\n * @param php php Node, passed as array so it can be modified\n * @return parsed attribute\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/sax/XMLReader.java","method":"doSAX","pos":616,"doc":"/** \n * Process nodes recursively on the DocumentHandler. Calls methods on the handler based on the type and whether it's an end tag. Processes composite tags recursively. Does rudimentary namespace processing according to the state of  {@link #mNameSpaces}and  {@link #mNameSpacePrefixes}. \n * @param node The htmlparser node to traverse.\n * @exception ParserException If a parse error occurs.\n * @exception SAXException If a SAX error occurs.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseAsp","pos":2859,"doc":"/** \n * parser for ASP within start tags Some people use ASP for to customize attributes Tidy isn't really well suited to dealing with ASP This is a workaround for attributes, but won't deal with the case where the ASP is used to tailor the attribute value. Here is an example of a work around for using ASP in attribute values: <code>href='<%=rsSchool.Fields(\"ID\").Value%>'<\/code> where the ASP that generates the attribute value is masked from Tidy by the quotemarks.\n * @return parsed Node\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanUntilEndTag","pos":2102,"doc":"/** \n * Scans the content of <noscript>: it doesn't get parsed but is considered as plain text when feature  {@link HTMLScanner#PARSE_NOSCRIPT_CONTENT} is set to false.\n * @param the tag for which content is scanned (one of \"noscript\", \"noframes\", \"iframe\")\n * @throws IOException\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/StyleScanner.java","method":"scan","pos":54,"doc":"/** \n * Scan for style definitions. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of CDATA.\n * @param stack The parse stack, <em>not used<\/em>.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/nodes/TagNode.java","method":"toTagHtml","pos":606,"doc":"/** \n * Return the tag HTML. Like <code>toHtml()<\/code> but since this is not implemented by  {@link org.htmlparser.tags.CompositeTag}, only renders the start tag.\n * @return The sequence of characters for the start tag only.\n * @see #toHtml()\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/PrototypicalNodeFactory.java","method":"registerTags","pos":294,"doc":"/** \n * Register all known tags in the tag package. Registers tags from the  {@link org.htmlparser.tags tag package} bycalling  {@link #registerTag(Tag) registerTag()}.\n * @return 'this' nodefactory as a convenience.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/ScriptScanner.java","method":"scan","pos":84,"doc":"/** \n * Scan for script. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of CDATA.\n * @param stack The parse stack, <em>not used<\/em>.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/Parser.java","method":"main","pos":806,"doc":"/** \n * The main program, which can be executed from the command line.\n * @param args A URL or file name to parse, and an optional tag name to beused as a filter.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseTag","pos":973,"doc":"/** \n * Parse a tag. Parse the name and attributes from a start tag.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2<p> <cite> 3.2.2 Attributes<p> Elements may have associated properties, called attributes, which may have values (by default, or set by authors or scripts). Attribute/value pairs appear before the final \">\" of an element's start tag. Any number of (legal) attribute value pairs, separated by spaces, may appear in an element's start tag. They may appear in any order.<p> In this example, the id attribute is set for an H1 element: <code> &lt;H1 id=\"section1\"&gt; <\/code> This is an identified heading thanks to the id attribute <code> &lt;/H1&gt; <\/code> By default, SGML requires that all attribute values be delimited using either double quotation marks (ASCII decimal 34) or single quotation marks (ASCII decimal 39). Single quote marks can be included within the attribute value when the value is delimited by double quote marks, and vice versa. Authors may also use numeric character references to represent double quotes (&amp;#34;) and single quotes (&amp;#39;). For doublequotes authors can also use the character entity reference &amp;quot;.<p> In certain cases, authors may specify the value of an attribute without any quotation marks. The attribute value may only contain letters (a-z and A-Z), digits (0-9), hyphens (ASCII decimal 45), periods (ASCII decimal 46), underscores (ASCII decimal 95), and colons (ASCII decimal 58). We recommend using quotation marks even when it is possible to eliminate them.<p> Attribute names are always case-insensitive.<p> Attribute values are generally case-insensitive. The definition of each attribute in the reference manual indicates whether its value is case-insensitive.<p> All the attributes defined by this specification are listed in the attribute index.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - outside of any attribute<\/li> <li>state 1 - within attributre name<\/li> <li>state 2 - equals hit<\/li> <li>state 3 - within naked attribute value.<\/li> <li>state 4 - within single quoted attribute value<\/li> <li>state 5 - within double quoted attribute value<\/li> <li>state 6 - whitespaces after attribute name could lead to state 2 (=)or state 0<\/li> <\/ol> <p> The starting point for the various components is stored in an array of integers that match the initiation point for the states one-for-one, i.e. bookmarks[0] is where state 0 began, bookmarks[1] is where state 1 began, etc. Attributes are stored in a <code>Vector<\/code> having one slot for each whitespace or attribute/value pair. The first slot is for attribute name (kind of like a standalone attribute).\n * @param start The position at which to start scanning.\n * @return The parsed tag.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseAttrs","pos":3615,"doc":"/** \n * Parse tag attributes.\n * @param isempty is tag empty?\n * @return parsed attribute/value list\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/HtmlTreeCellRenderer.java","method":"toHtml","pos":62,"doc":"/** \n * Render the tag as HTML. This is different from the tag's normal toHtml() method in that it doesn't process children or end tags, just the initial tag, and it also wraps the tag in html a label would expect.\n * @see org.htmlparser.Node#toHtml()\n * @param tag The tag to convert to HTML.\n * @return A string suitable for rendering the tag.\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/util/ParserUtils.java","method":"splitTags","pos":821,"doc":"/** \n * Split the input string in a string array, considering the tags as delimiter for splitting. <BR>Use NodeFilter class as input parameter instead of tags[] string array.\n * @see ParserUtils#splitTags (String input, String[] tags, boolean recursive, boolean insideTag).\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/CompositeTagScanner.java","method":"scan","pos":70,"doc":"/** \n * Collect the children. <p>An initial test is performed for an empty XML tag, in which case the start tag and end tag of the returned tag are the same and it has no children.<p> If it's not an empty XML tag, the lexer is repeatedly asked for subsequent nodes until an end tag is found or a node is encountered that matches the tag ender set or end tag ender set. In the latter case, a virtual end tag is created. Each node found that is not the end tag is added to the list of children. The end tag is special and not a child.<p> Nodes that also have a CompositeTagScanner as their scanner are recursed into, which provides the nested structure of an HTML page. This method operates in two possible modes, depending on a private boolean. It can recurse on the JVM stack, which has caused some overflow problems in the past, or it can use the supplied stack argument to nest scanning of child tags within itself. The former is left as an option in the code, mostly to help subsequent modifiers visualize what the internal nesting is doing.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of subsequent nodes.\n * @param stack The parse stack. May contain pending tags that enclosethis tag.\n * @return The resultant tag (may be unchanged).\n */\n"},{"file_path":"/home/yuan/Desktop/PL research/eclipseWorkSpace/javaSrcCompress/dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/FilterBuilder.java","method":"makeProgram","pos":687,"doc":"/** \n * Makes a program like: <pre> // Generated by FilterBuilder. http://htmlparser.org // [aced0005737200206f72672e68746d6c7061727365722e66696c746572732e416e6446696c74657224c30516b2b7b2120200015b000b6d5072656469636174657374001c5b4c6f72672f68746d6c7061727365722f4e6f646546696c7465723b78707572001c5b4c6f72672e68746d6c7061727365722e4e6f646546696c7465723b8f17479b1d5f7992020000787000000002737200246f72672e68746d6c7061727365722e66696c746572732e5461674e616d6546696c746572b28b2601a614890f0200014c00056d4e616d657400124c6a6176612f6c616e672f537472696e673b78707400044d455441737200296f72672e68746d6c7061727365722e66696c746572732e48617341747472696275746546696c74657296abdfb3b0714cda0200024c000a6d41747472696275746571007e00064c00066d56616c756571007e000678707400046e616d6570] import org.htmlparser.*; import org.htmlparser.filters.*; import org.htmlparser.beans.*; import org.htmlparser.util.*; public class Test { public static void main (String args[]) { TagNameFilter filter0 = new TagNameFilter (); filter0.setName (\"META\"); HasAttributeFilter filter1 = new HasAttributeFilter (); filter1.setAttributeName (\"name\"); NodeFilter[] array0 = new NodeFilter[2]; array0[0] = filter0; array0[1] = filter1; AndFilter filter2 = new AndFilter (); filter2.setPredicates (array0); NodeFilter[] array1 = new NodeFilter[1]; array1[0] = filter2; FilterBean bean = new FilterBean (); bean.setFilters (array1); if (0 != args.length) { bean.setURL (args[0]); System.out.println (bean.getNodes ().toHtml ()); } else System.out.println (\"Usage: java -classpath .:htmlparser.jar:htmllexer.jar Test <url>\"); } } <\/pre>\n * @param name The name of the class. \n * @param out The buffer to append to.\n * @param bean The bean to extract the filters from to make the program.\n */\n"}]}