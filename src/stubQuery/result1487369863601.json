{"filter":1,"results":[{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanUntilEndTag","pos":2102,"doc":"/** \n * Scans the content of <noscript>: it doesn't get parsed but is considered as plain text when feature  {@link HTMLScanner#PARSE_NOSCRIPT_CONTENT} is set to false.\n * @param the tag for which content is scanned (one of \"noscript\", \"noframes\", \"iframe\")\n * @throws IOException\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/CompositeTagScanner.java","method":"scan","pos":70,"doc":"/** \n * Collect the children. <p>An initial test is performed for an empty XML tag, in which case the start tag and end tag of the returned tag are the same and it has no children.<p> If it's not an empty XML tag, the lexer is repeatedly asked for subsequent nodes until an end tag is found or a node is encountered that matches the tag ender set or end tag ender set. In the latter case, a virtual end tag is created. Each node found that is not the end tag is added to the list of children. The end tag is special and not a child.<p> Nodes that also have a CompositeTagScanner as their scanner are recursed into, which provides the nested structure of an HTML page. This method operates in two possible modes, depending on a private boolean. It can recurse on the JVM stack, which has caused some overflow problems in the past, or it can use the supplied stack argument to nest scanning of child tags within itself. The former is left as an option in the code, mostly to help subsequent modifiers visualize what the internal nesting is doing.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of subsequent nodes.\n * @param stack The parse stack. May contain pending tags that enclosethis tag.\n * @return The resultant tag (may be unchanged).\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"setXHTMLDocType","pos":1223,"doc":"/** \n * Adds a new xhtml doctype to the document.\n * @param root root node\n * @return <code>true<\/code> if a doctype has been added\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"apparentVersion","pos":1388,"doc":"/** \n * Return the html version used in document.\n * @return version code\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parseDocument","pos":3343,"doc":"/** \n * HTML is the top level element.\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/PrototypicalNodeFactory.java","method":"registerTags","pos":294,"doc":"/** \n * Register all known tags in the tag package. Registers tags from the  {@link org.htmlparser.tags tag package} bycalling  {@link #registerTag(Tag) registerTag()}.\n * @return 'this' nodefactory as a convenience.\n */\n"},{"file_path":"dataset/org/cowan/tagsoup/tagsoup/1.2.1/org/ccil/cowan/tagsoup/HTMLScanner.java","method":"scan","pos":378,"doc":"/** \n * Scan HTML source, reporting lexical events.\n * @param r0 Reader that provides characters\n * @param h ScanHandler that accepts lexical events.\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"fixWindowsCharacter","pos":1091,"doc":"/** \n * Fixes Microsoft Windows&reg; specific characters. <p> Details about this common problem can be found at  <a href='http://www.cs.tut.fi/~jkorpela/www/windows-chars.html'>http://www.cs.tut.fi/~jkorpela/www/windows-chars.html<\/a>\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseTag","pos":973,"doc":"/** \n * Parse a tag. Parse the name and attributes from a start tag.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2<p> <cite> 3.2.2 Attributes<p> Elements may have associated properties, called attributes, which may have values (by default, or set by authors or scripts). Attribute/value pairs appear before the final \">\" of an element's start tag. Any number of (legal) attribute value pairs, separated by spaces, may appear in an element's start tag. They may appear in any order.<p> In this example, the id attribute is set for an H1 element: <code> &lt;H1 id=\"section1\"&gt; <\/code> This is an identified heading thanks to the id attribute <code> &lt;/H1&gt; <\/code> By default, SGML requires that all attribute values be delimited using either double quotation marks (ASCII decimal 34) or single quotation marks (ASCII decimal 39). Single quote marks can be included within the attribute value when the value is delimited by double quote marks, and vice versa. Authors may also use numeric character references to represent double quotes (&amp;#34;) and single quotes (&amp;#39;). For doublequotes authors can also use the character entity reference &amp;quot;.<p> In certain cases, authors may specify the value of an attribute without any quotation marks. The attribute value may only contain letters (a-z and A-Z), digits (0-9), hyphens (ASCII decimal 45), periods (ASCII decimal 46), underscores (ASCII decimal 95), and colons (ASCII decimal 58). We recommend using quotation marks even when it is possible to eliminate them.<p> Attribute names are always case-insensitive.<p> Attribute values are generally case-insensitive. The definition of each attribute in the reference manual indicates whether its value is case-insensitive.<p> All the attributes defined by this specification are listed in the attribute index.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - outside of any attribute<\/li> <li>state 1 - within attributre name<\/li> <li>state 2 - equals hit<\/li> <li>state 3 - within naked attribute value.<\/li> <li>state 4 - within single quoted attribute value<\/li> <li>state 5 - within double quoted attribute value<\/li> <li>state 6 - whitespaces after attribute name could lead to state 2 (=)or state 0<\/li> <\/ol> <p> The starting point for the various components is stored in an array of integers that match the initiation point for the states one-for-one, i.e. bookmarks[0] is where state 0 began, bookmarks[1] is where state 1 began, etc. Attributes are stored in a <code>Vector<\/code> having one slot for each whitespace or attribute/value pair. The first slot is for attribute name (kind of like a standalone attribute).\n * @param start The position at which to start scanning.\n * @return The parsed tag.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseEntity","pos":648,"doc":"/** \n * Parse an html entity.\n * @param mode mode\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/tags/ImageTag.java","method":"extractImageLocn","pos":71,"doc":"/** \n * Extract the location of the image Given the tag (with attributes), and the url of the html page in which this tag exists, perform best effort to extract the 'intended' URL. Attempts to handle such attributes as: <pre> &lt;IMG SRC=http://www.redgreen.com&gt; - normal &lt;IMG SRC =http://www.redgreen.com&gt; - space between attribute name and equals sign &lt;IMG SRC= http://www.redgreen.com&gt; - space between equals sign and attribute value &lt;IMG SRC = http://www.redgreen.com&gt; - space both sides of equals sign <\/pre>\n * @return The relative URL for the image.\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseRemark","pos":1236,"doc":"/** \n * Parse a comment. Parse a remark markup.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4<p> <cite> 3.2.4 Comments<p> HTML comments have the following syntax:<p> <code> &lt;!-- this is a comment --&gt;<p> &lt;!-- and so is this one,<p> which occupies more than one line --&gt;<p> <\/code> White space is not permitted between the markup declaration open delimiter(\"&lt;!\") and the comment open delimiter (\"--\"), but is permitted between the comment close delimiter (\"--\") and the markup declaration close delimiter (\"&gt;\"). A common error is to include a string of hyphens (\"---\") within a comment. Authors should avoid putting two or more adjacent hyphens inside comments. Information that appears between comments has no special meaning (e.g., character references are not interpreted as such). Note that comments are markup.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - prior to the first open delimiter (first dash)<\/li> <li>state 1 - prior to the second open delimiter (second dash)<\/li> <li>state 2 - prior to the first closing delimiter (first dash)<\/li> <li>state 3 - prior to the second closing delimiter (second dash)<\/li> <li>state 4 - prior to the terminating &gt;<\/li> <\/ol> <p> All comment text (everything excluding the &lt; and &gt;), is included in the remark text. We allow terminators like --!&gt; even though this isn't part of the spec.\n * @param start The position at which to start scanning.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/util/IteratorImpl.java","method":"nextNode","pos":63,"doc":"/** \n * Get the next node.\n * @return The next node in the HTML stream, or null if there are no more nodes.\n * @exception ParserException If an unrecoverable error occurs.\n */\n"},{"file_path":"dataset/org/cowan/tagsoup/tagsoup/1.2.1/org/ccil/cowan/tagsoup/HTMLSchema.java","method":"HTMLSchema","pos":26,"doc":"/** \n * Returns a newly constructed HTMLSchema object independent of any existing ones.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/PPrint.java","method":"printScriptStyle","pos":1837,"doc":"/** \n * Print script and style elements. For XHTML, wrap the content as follows: <pre> JavaScript: //&lt;![CDATA[ content //]]> VBScript: '&lt;![CDATA[ content ']]> CSS: /*&lt;![CDATA[* / content /*]]>* / other: &lt;![CDATA[ content ]]> <\/pre>\n * @param fout\n * @param mode\n * @param indent\n * @param lexer\n * @param node\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Clean.java","method":"bumpObject","pos":2350,"doc":"/** \n * Where appropriate move object elements from head to body.\n * @param lexer Lexer\n * @param html html node\n */\n"},{"file_path":"dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/FilterBuilder.java","method":"makeProgram","pos":687,"doc":"/** \n * Makes a program like: <pre> // Generated by FilterBuilder. http://htmlparser.org // [aced0005737200206f72672e68746d6c7061727365722e66696c746572732e416e6446696c74657224c30516b2b7b2120200015b000b6d5072656469636174657374001c5b4c6f72672f68746d6c7061727365722f4e6f646546696c7465723b78707572001c5b4c6f72672e68746d6c7061727365722e4e6f646546696c7465723b8f17479b1d5f7992020000787000000002737200246f72672e68746d6c7061727365722e66696c746572732e5461674e616d6546696c746572b28b2601a614890f0200014c00056d4e616d657400124c6a6176612f6c616e672f537472696e673b78707400044d455441737200296f72672e68746d6c7061727365722e66696c746572732e48617341747472696275746546696c74657296abdfb3b0714cda0200024c000a6d41747472696275746571007e00064c00066d56616c756571007e000678707400046e616d6570] import org.htmlparser.*; import org.htmlparser.filters.*; import org.htmlparser.beans.*; import org.htmlparser.util.*; public class Test { public static void main (String args[]) { TagNameFilter filter0 = new TagNameFilter (); filter0.setName (\"META\"); HasAttributeFilter filter1 = new HasAttributeFilter (); filter1.setAttributeName (\"name\"); NodeFilter[] array0 = new NodeFilter[2]; array0[0] = filter0; array0[1] = filter1; AndFilter filter2 = new AndFilter (); filter2.setPredicates (array0); NodeFilter[] array1 = new NodeFilter[1]; array1[0] = filter2; FilterBean bean = new FilterBean (); bean.setFilters (array1); if (0 != args.length) { bean.setURL (args[0]); System.out.println (bean.getNodes ().toHtml ()); } else System.out.println (\"Usage: java -classpath .:htmlparser.jar:htmllexer.jar Test <url>\"); } } <\/pre>\n * @param name The name of the class. \n * @param out The buffer to append to.\n * @param bean The bean to extract the filters from to make the program.\n */\n"},{"file_path":"dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/HtmlTreeCellRenderer.java","method":"toHtml","pos":62,"doc":"/** \n * Render the tag as HTML. This is different from the tag's normal toHtml() method in that it doesn't process children or end tags, just the initial tag, and it also wraps the tag in html a label would expect.\n * @see org.htmlparser.Node#toHtml()\n * @param tag The tag to convert to HTML.\n * @return A string suitable for rendering the tag.\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/sax/XMLReader.java","method":"doSAX","pos":616,"doc":"/** \n * Process nodes recursively on the DocumentHandler. Calls methods on the handler based on the type and whether it's an end tag. Processes composite tags recursively. Does rudimentary namespace processing according to the state of  {@link #mNameSpaces}and  {@link #mNameSpacePrefixes}. \n * @param node The htmlparser node to traverse.\n * @exception ParserException If a parse error occurs.\n * @exception SAXException If a SAX error occurs.\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/http/ConnectionManager.java","method":"encode","pos":723,"doc":"/** \n * Encodes a byte array into BASE64 in accordance with <a href=\"http://www.faqs.org/rfcs/rfc2045.html\">RFC 2045<\/a>.\n * @param array The bytes to convert.\n * @return A BASE64 encoded string.\n */\n"}]}