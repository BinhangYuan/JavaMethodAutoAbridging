{"filter":1,"results":[{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":692,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2884,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Page.java","method":"getCharacter","pos":713,"doc":"/** \n * Read the character at the given cursor position. The cursor position can be only behind or equal to the current source position. Returns end of lines (EOL) as \\n, by converting \\r and \\r\\n to \\n, and updates the end-of-line index accordingly. Advances the cursor position by one (or two in the \\r\\n case).\n * @param cursor The position to read at.\n * @return The character at that position, and modifies the cursor toprepare for the next read. If the source is exhausted a zero is returned.\n * @exception ParserException If an IOException on the underlying sourceoccurs, or an attempt is made to read characters in the future (the cursor position is ahead of the underlying stream)\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseValue","pos":3202,"doc":"/** \n * Parse an attribute value.\n * @param name attribute name\n * @param foldCase fold case?\n * @param isempty is attribute empty? Passed as an array reference to allow modification\n * @param pdelim delimiter, passed as an array reference to allow modification\n * @return parsed value\n */\n"},{"file_path":"dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/FilterBuilder.java","method":"makeProgram","pos":687,"doc":"/** \n * Makes a program like: <pre> // Generated by FilterBuilder. http://htmlparser.org // [aced0005737200206f72672e68746d6c7061727365722e66696c746572732e416e6446696c74657224c30516b2b7b2120200015b000b6d5072656469636174657374001c5b4c6f72672f68746d6c7061727365722f4e6f646546696c7465723b78707572001c5b4c6f72672e68746d6c7061727365722e4e6f646546696c7465723b8f17479b1d5f7992020000787000000002737200246f72672e68746d6c7061727365722e66696c746572732e5461674e616d6546696c746572b28b2601a614890f0200014c00056d4e616d657400124c6a6176612f6c616e672f537472696e673b78707400044d455441737200296f72672e68746d6c7061727365722e66696c746572732e48617341747472696275746546696c74657296abdfb3b0714cda0200024c000a6d41747472696275746571007e00064c00066d56616c756571007e000678707400046e616d6570] import org.htmlparser.*; import org.htmlparser.filters.*; import org.htmlparser.beans.*; import org.htmlparser.util.*; public class Test { public static void main (String args[]) { TagNameFilter filter0 = new TagNameFilter (); filter0.setName (\"META\"); HasAttributeFilter filter1 = new HasAttributeFilter (); filter1.setAttributeName (\"name\"); NodeFilter[] array0 = new NodeFilter[2]; array0[0] = filter0; array0[1] = filter1; AndFilter filter2 = new AndFilter (); filter2.setPredicates (array0); NodeFilter[] array1 = new NodeFilter[1]; array1[0] = filter2; FilterBean bean = new FilterBean (); bean.setFilters (array1); if (0 != args.length) { bean.setURL (args[0]); System.out.println (bean.getNodes ().toHtml ()); } else System.out.println (\"Usage: java -classpath .:htmlparser.jar:htmllexer.jar Test <url>\"); } } <\/pre>\n * @param name The name of the class. \n * @param out The buffer to append to.\n * @param bean The bean to extract the filters from to make the program.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2506,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseCDATA","pos":431,"doc":"/** \n * Return CDATA as a text node. Slightly less rigid than  {@link #parseCDATA()} this method provides forparsing CDATA that may contain quoted strings that have embedded ETAGO (\"&lt;/\") delimiters and skips single and multiline comments.\n * @param quotesmart If <code>true<\/code> the strict definition of CDATA isextended to allow for single or double quoted ETAGO (\"&lt;/\") sequences.\n * @return The <code>TextNode<\/code> of the CDATA or <code>null<\/code> if none.\n * @see #parseCDATA()\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/CompositeTagScanner.java","method":"scan","pos":70,"doc":"/** \n * Collect the children. <p>An initial test is performed for an empty XML tag, in which case the start tag and end tag of the returned tag are the same and it has no children.<p> If it's not an empty XML tag, the lexer is repeatedly asked for subsequent nodes until an end tag is found or a node is encountered that matches the tag ender set or end tag ender set. In the latter case, a virtual end tag is created. Each node found that is not the end tag is added to the list of children. The end tag is special and not a child.<p> Nodes that also have a CompositeTagScanner as their scanner are recursed into, which provides the nested structure of an HTML page. This method operates in two possible modes, depending on a private boolean. It can recurse on the JVM stack, which has caused some overflow problems in the past, or it can use the supplied stack argument to nest scanning of child tags within itself. The former is left as an option in the code, mostly to help subsequent modifiers visualize what the internal nesting is doing.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of subsequent nodes.\n * @param stack The parse stack. May contain pending tags that enclosethis tag.\n * @return The resultant tag (may be unchanged).\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/util/ParserUtils.java","method":"splitTags","pos":821,"doc":"/** \n * Split the input string in a string array, considering the tags as delimiter for splitting. <BR>Use NodeFilter class as input parameter instead of tags[] string array.\n * @see ParserUtils#splitTags (String input, String[] tags, boolean recursive, boolean insideTag).\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":3050,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/http/ConnectionManager.java","method":"openConnection","pos":826,"doc":"/** \n * Opens a connection based on a given string. The string is either a file, in which case <code>file://localhost<\/code> is prepended to a canonical path derived from the string, or a url that begins with one of the known protocol strings, i.e. <code>http://<\/code>. Embedded spaces are silently converted to %20 sequences.\n * @param string The name of a file or a url.\n * @return The connection.\n * @exception ParserException if the string is not a valid url or file.\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/ScriptScanner.java","method":"scan","pos":84,"doc":"/** \n * Scan for script. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of CDATA.\n * @param stack The parse stack, <em>not used<\/em>.\n */\n"},{"file_path":"dataset/org/htmlparser/thumbelina/2.1/org/htmlparser/lexerapplications/thumbelina/Thumbelina.java","method":"run","pos":1061,"doc":"/** \n * The main processing loop. Pull suspect URLs off the queue one at a time, fetch and parse it, request images and enqueue further links.\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/http/ConnectionManager.java","method":"parseCookies","pos":1082,"doc":"/** \n * Check for cookie and parse into cookie jar.\n * @param connection The connection to extract cookie information from.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseAttrs","pos":3615,"doc":"/** \n * Parse tag attributes.\n * @param isempty is tag empty?\n * @return parsed attribute/value list\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/http/ConnectionManager.java","method":"openConnection","pos":547,"doc":"/** \n * Opens a connection using the given url.\n * @param url The url to open.\n * @return The connection.\n * @exception ParserException if an i/o exception occurs accessing the url.\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"nextNode","pos":320,"doc":"/** \n * Get the next node from the source.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return A Remark, Text or Tag, or <code>null<\/code> if nomore lexemes are present.\n * @exception ParserException If there is a problem with theunderlying page.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":495,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":3213,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseTag","pos":973,"doc":"/** \n * Parse a tag. Parse the name and attributes from a start tag.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2<p> <cite> 3.2.2 Attributes<p> Elements may have associated properties, called attributes, which may have values (by default, or set by authors or scripts). Attribute/value pairs appear before the final \">\" of an element's start tag. Any number of (legal) attribute value pairs, separated by spaces, may appear in an element's start tag. They may appear in any order.<p> In this example, the id attribute is set for an H1 element: <code> &lt;H1 id=\"section1\"&gt; <\/code> This is an identified heading thanks to the id attribute <code> &lt;/H1&gt; <\/code> By default, SGML requires that all attribute values be delimited using either double quotation marks (ASCII decimal 34) or single quotation marks (ASCII decimal 39). Single quote marks can be included within the attribute value when the value is delimited by double quote marks, and vice versa. Authors may also use numeric character references to represent double quotes (&amp;#34;) and single quotes (&amp;#39;). For doublequotes authors can also use the character entity reference &amp;quot;.<p> In certain cases, authors may specify the value of an attribute without any quotation marks. The attribute value may only contain letters (a-z and A-Z), digits (0-9), hyphens (ASCII decimal 45), periods (ASCII decimal 46), underscores (ASCII decimal 95), and colons (ASCII decimal 58). We recommend using quotation marks even when it is possible to eliminate them.<p> Attribute names are always case-insensitive.<p> Attribute values are generally case-insensitive. The definition of each attribute in the reference manual indicates whether its value is case-insensitive.<p> All the attributes defined by this specification are listed in the attribute index.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - outside of any attribute<\/li> <li>state 1 - within attributre name<\/li> <li>state 2 - equals hit<\/li> <li>state 3 - within naked attribute value.<\/li> <li>state 4 - within single quoted attribute value<\/li> <li>state 5 - within double quoted attribute value<\/li> <li>state 6 - whitespaces after attribute name could lead to state 2 (=)or state 0<\/li> <\/ol> <p> The starting point for the various components is stored in an array of integers that match the initiation point for the states one-for-one, i.e. bookmarks[0] is where state 0 began, bookmarks[1] is where state 1 began, etc. Attributes are stored in a <code>Vector<\/code> having one slot for each whitespace or attribute/value pair. The first slot is for attribute name (kind of like a standalone attribute).\n * @param start The position at which to start scanning.\n * @return The parsed tag.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/beans/StringBean.java","method":"setStrings","pos":313,"doc":"/** \n * Fetch the URL contents. Only do work if there is a valid parser with it's URL set.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Tidy.java","method":"parse","pos":614,"doc":"/** \n * Internal routine that actually does the parsing. The caller can pass either an InputStream or file name. If both are passed, the file name is preferred.\n * @param in input stream (used only if <code>file<\/code> is null)\n * @param file file name\n * @param out output stream\n * @return parsed org.w3c.tidy.Node\n * @throws FileNotFoundException if <code>file<\/code> is not null but it can't be found\n * @throws IOException for errors in reading input stream or file\n */\n"},{"file_path":"dataset/org/jsoup/jsoup/1.6.1/org/jsoup/select/QueryParser.java","method":"parse","pos":40,"doc":"/** \n * Parse the query\n * @return Evaluator\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2639,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2727,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Page.java","method":"setConnection","pos":516,"doc":"/** \n * Set the URLConnection to be used by this page. Starts reading from the given connection. This also resets the current url.\n * @param connection The connection to use.It will be connected by this method.\n * @exception ParserException If 1)the <code>connect()<\/code> method fails or 2)an I/O error occurs opening the input stream or  3)the character set designated in the HTTP header is unsupported or or 4)URL used to create the connection object supplied is not in the right form or syntax \n */\n"},{"file_path":"dataset/org/jsoup/jsoup/1.5.2/org/jsoup/select/QueryParser.java","method":"parse","pos":40,"doc":"/** \n * Parse the query\n * @return Evaluator\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseJsp","pos":1387,"doc":"/** \n * Parse a java server page node. Scan characters until \"%&gt;\" is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/org/htmlparser/sitecapturer/2.1/org/htmlparser/parserapplications/SiteCapturer.java","method":"process","pos":470,"doc":"/** \n * Process a single page.\n * @param filter The filter to apply to the collected nodes.\n * @exception ParserException If a parse error occurs.\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/InputStreamSource.java","method":"setEncoding","pos":224,"doc":"/** \n * Begins reading from the source with the given character set. If the current encoding is the same as the requested encoding, this method is a no-op. Otherwise any subsequent characters read from this page will have been decoded using the given character set.<p> Some magic happens here to obtain this result if characters have already been consumed from this source. Since a Reader cannot be dynamically altered to use a different character set, the underlying stream is reset, a new Source is constructed and a comparison made of the characters read so far with the newly read characters up to the current position. If a difference is encountered, or some other problem occurs, an exception is thrown.\n * @param character_set The character set to use to convert bytes intocharacters.\n * @exception ParserException If a character mismatch occurs betweencharacters already provided and those that would have been returned had the new character set been in effect from the beginning. An exception is also thrown if the underlying stream won't put up with these shenanigans.\n */\n"},{"file_path":"dataset/org/htmlparser/filterbuilder/2.1/org/htmlparser/parserapplications/filterbuilder/HtmlTreeCellRenderer.java","method":"toHtml","pos":62,"doc":"/** \n * Render the tag as HTML. This is different from the tag's normal toHtml() method in that it doesn't process children or end tags, just the initial tag, and it also wraps the tag in html a label would expect.\n * @see org.htmlparser.Node#toHtml()\n * @param tag The tag to convert to HTML.\n * @return A string suitable for rendering the tag.\n */\n"},{"file_path":"dataset/org/jsoup/jsoup/1.6.2/org/jsoup/select/QueryParser.java","method":"parse","pos":40,"doc":"/** \n * Parse the query\n * @return Evaluator\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":1883,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/sax/XMLReader.java","method":"doSAX","pos":616,"doc":"/** \n * Process nodes recursively on the DocumentHandler. Calls methods on the handler based on the type and whether it's an end tag. Processes composite tags recursively. Does rudimentary namespace processing according to the state of  {@link #mNameSpaces}and  {@link #mNameSpacePrefixes}. \n * @param node The htmlparser node to traverse.\n * @exception ParserException If a parse error occurs.\n * @exception SAXException If a SAX error occurs.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":1063,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/Parser.java","method":"main","pos":806,"doc":"/** \n * The main program, which can be executed from the command line.\n * @param args A URL or file name to parse, and an optional tag name to beused as a filter.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":988,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":2009,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseAttribute","pos":2952,"doc":"/** \n * consumes the '>' terminating start tags.\n * @param isempty flag is passed as array so it can be modified\n * @param asp asp Node, passed as array so it can be modified\n * @param php php Node, passed as array so it can be modified\n * @return parsed attribute\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/util/ParserUtils.java","method":"trimTags","pos":1070,"doc":"/** \n * Trim all tags in the input string and return a string like the input one without the tags and their content (optional). <BR>Use NodeFilter class as input parameter instead of tags[] string array.\n * @see ParserUtils#trimTags (String input, String[] tags, boolean recursive, boolean insideTag).\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":592,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parsePI","pos":1568,"doc":"/** \n * Parse an XML processing instruction. Scan characters until \"?&gt;\" is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/org/htmlparser/thumbelina/2.1/org/htmlparser/lexerapplications/thumbelina/Thumbelina.java","method":"extractImageLinks","pos":754,"doc":"/** \n * Get the links of an element of a document. Only gets the links on IMG elements that reference another image. The latter is based on suffix (.jpg, .gif and .png).\n * @param lexer The fully conditioned lexer, ready to rock.\n * @param docbase The url to read.\n * @return The URLs, targets of the IMG links;\n * @exception IOException If the underlying infrastructure throws it.\n * @exception ParserException If there is a problem parsing the url.\n */\n"},{"file_path":"dataset/org/jsoup/jsoup/1.5.1/org/jsoup/select/QueryParser.java","method":"parse","pos":40,"doc":"/** \n * Parse the query\n * @return Evaluator\n */\n"},{"file_path":"dataset/org/jsoup/jsoup/1.6.0/org/jsoup/select/QueryParser.java","method":"parse","pos":40,"doc":"/** \n * Parse the query\n * @return Evaluator\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/util/IteratorImpl.java","method":"nextNode","pos":63,"doc":"/** \n * Get the next node.\n * @return The next node in the HTML stream, or null if there are no more nodes.\n * @exception ParserException If an unrecoverable error occurs.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Lexer.java","method":"parseEntity","pos":648,"doc":"/** \n * Parse an html entity.\n * @param mode mode\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":1746,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseString","pos":744,"doc":"/** \n * Parse a string node. Scan characters until \"&lt;/\", \"&lt;%\", \"&lt;!\" or &lt; followed by a letter is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/ParserImpl.java","method":"parse","pos":266,"doc":"/** \n * @see org.w3c.tidy.Parser#parse(org.w3c.tidy.Lexer,org.w3c.tidy.Node,short)\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/PrototypicalNodeFactory.java","method":"registerTags","pos":294,"doc":"/** \n * Register all known tags in the tag package. Registers tags from the  {@link org.htmlparser.tags tag package} bycalling  {@link #registerTag(Tag) registerTag()}.\n * @return 'this' nodefactory as a convenience.\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseRemark","pos":1236,"doc":"/** \n * Parse a comment. Parse a remark markup.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4<p> <cite> 3.2.4 Comments<p> HTML comments have the following syntax:<p> <code> &lt;!-- this is a comment --&gt;<p> &lt;!-- and so is this one,<p> which occupies more than one line --&gt;<p> <\/code> White space is not permitted between the markup declaration open delimiter(\"&lt;!\") and the comment open delimiter (\"--\"), but is permitted between the comment close delimiter (\"--\") and the markup declaration close delimiter (\"&gt;\"). A common error is to include a string of hyphens (\"---\") within a comment. Authors should avoid putting two or more adjacent hyphens inside comments. Information that appears between comments has no special meaning (e.g., character references are not interpreted as such). Note that comments are markup.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - prior to the first open delimiter (first dash)<\/li> <li>state 1 - prior to the second open delimiter (second dash)<\/li> <li>state 2 - prior to the first closing delimiter (first dash)<\/li> <li>state 3 - prior to the second closing delimiter (second dash)<\/li> <li>state 4 - prior to the terminating &gt;<\/li> <\/ol> <p> All comment text (everything excluding the &lt; and &gt;), is included in the remark text. We allow terminators like --!&gt; even though this isn't part of the spec.\n * @param start The position at which to start scanning.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanUntilEndTag","pos":2102,"doc":"/** \n * Scans the content of <noscript>: it doesn't get parsed but is considered as plain text when feature  {@link HTMLScanner#PARSE_NOSCRIPT_CONTENT} is set to false.\n * @param the tag for which content is scanned (one of \"noscript\", \"noframes\", \"iframe\")\n * @throws IOException\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/ScriptDecoder.java","method":"Decode","pos":267,"doc":"/** \n * Decode script encoded by the Microsoft obfuscator.\n * @param page The source for encoded text.\n * @param cursor The position at which to start decoding.This is advanced to the end of the encoded text.\n * @return The plaintext.\n * @exception ParserException If an error is discovered while decoding.\n */\n"},{"file_path":"dataset/net/sf/jtidy/jtidy/r938/org/w3c/tidy/Tidy.java","method":"parse","pos":384,"doc":"/** \n * Internal routine that actually does the parsing.\n * @param streamIn tidy StreamIn\n * @param o tidy Out\n * @return parsed org.w3c.tidy.Node\n */\n"}]}