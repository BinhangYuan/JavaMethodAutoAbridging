{"filter":1,"results":[{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanLiteral","pos":1226,"doc":"/** \n * Scans a quoted literal. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanCDATA","pos":2291,"doc":"/** \n * Scans a CDATA section. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanComment","pos":2340,"doc":"/** \n * Scans a comment. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanPI","pos":2452,"doc":"/** \n * Scans a processing instruction. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scan","pos":1954,"doc":"/** \n * Scan. \n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseRemark","pos":1236,"doc":"/** \n * Parse a comment. Parse a remark markup.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.4<p> <cite> 3.2.4 Comments<p> HTML comments have the following syntax:<p> <code> &lt;!-- this is a comment --&gt;<p> &lt;!-- and so is this one,<p> which occupies more than one line --&gt;<p> <\/code> White space is not permitted between the markup declaration open delimiter(\"&lt;!\") and the comment open delimiter (\"--\"), but is permitted between the comment close delimiter (\"--\") and the markup declaration close delimiter (\"&gt;\"). A common error is to include a string of hyphens (\"---\") within a comment. Authors should avoid putting two or more adjacent hyphens inside comments. Information that appears between comments has no special meaning (e.g., character references are not interpreted as such). Note that comments are markup.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - prior to the first open delimiter (first dash)<\/li> <li>state 1 - prior to the second open delimiter (second dash)<\/li> <li>state 2 - prior to the first closing delimiter (first dash)<\/li> <li>state 3 - prior to the second closing delimiter (second dash)<\/li> <li>state 4 - prior to the terminating &gt;<\/li> <\/ol> <p> All comment text (everything excluding the &lt; and &gt;), is included in the remark text. We allow terminators like --!&gt; even though this isn't part of the spec.\n * @param start The position at which to start scanning.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/ScriptScanner.java","method":"scan","pos":84,"doc":"/** \n * Scan for script. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of CDATA.\n * @param stack The parse stack, <em>not used<\/em>.\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanEntityRef","pos":1303,"doc":"/** \n * Scans an entity reference. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanDoctype","pos":1168,"doc":"/** \n * Scans a DOCTYPE line. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scan","pos":3089,"doc":"/** \n * Scan. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanCharacters","pos":2241,"doc":"/** \n * Scans characters. \n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseTag","pos":973,"doc":"/** \n * Parse a tag. Parse the name and attributes from a start tag.<p> From the <a href=\"http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2\"> HTML 4.01 Specification, W3C Recommendation 24 December 1999<\/a> http://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2<p> <cite> 3.2.2 Attributes<p> Elements may have associated properties, called attributes, which may have values (by default, or set by authors or scripts). Attribute/value pairs appear before the final \">\" of an element's start tag. Any number of (legal) attribute value pairs, separated by spaces, may appear in an element's start tag. They may appear in any order.<p> In this example, the id attribute is set for an H1 element: <code> &lt;H1 id=\"section1\"&gt; <\/code> This is an identified heading thanks to the id attribute <code> &lt;/H1&gt; <\/code> By default, SGML requires that all attribute values be delimited using either double quotation marks (ASCII decimal 34) or single quotation marks (ASCII decimal 39). Single quote marks can be included within the attribute value when the value is delimited by double quote marks, and vice versa. Authors may also use numeric character references to represent double quotes (&amp;#34;) and single quotes (&amp;#39;). For doublequotes authors can also use the character entity reference &amp;quot;.<p> In certain cases, authors may specify the value of an attribute without any quotation marks. The attribute value may only contain letters (a-z and A-Z), digits (0-9), hyphens (ASCII decimal 45), periods (ASCII decimal 46), underscores (ASCII decimal 95), and colons (ASCII decimal 58). We recommend using quotation marks even when it is possible to eliminate them.<p> Attribute names are always case-insensitive.<p> Attribute values are generally case-insensitive. The definition of each attribute in the reference manual indicates whether its value is case-insensitive.<p> All the attributes defined by this specification are listed in the attribute index.<p> <\/cite> <p> This method uses a state machine with the following states: <ol> <li>state 0 - outside of any attribute<\/li> <li>state 1 - within attributre name<\/li> <li>state 2 - equals hit<\/li> <li>state 3 - within naked attribute value.<\/li> <li>state 4 - within single quoted attribute value<\/li> <li>state 5 - within double quoted attribute value<\/li> <li>state 6 - whitespaces after attribute name could lead to state 2 (=)or state 0<\/li> <\/ol> <p> The starting point for the various components is stored in an array of integers that match the initiation point for the states one-for-one, i.e. bookmarks[0] is where state 0 began, bookmarks[1] is where state 1 began, etc. Attributes are stored in a <code>Vector<\/code> having one slot for each whitespace or attribute/value pair. The first slot is for attribute name (kind of like a standalone attribute).\n * @param start The position at which to start scanning.\n * @return The parsed tag.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanCharacters","pos":3193,"doc":"/** \n * Scan characters. \n */\n"},{"file_path":"dataset/org/htmlparser/htmlparser/2.1/org/htmlparser/scanners/CompositeTagScanner.java","method":"scan","pos":70,"doc":"/** \n * Collect the children. <p>An initial test is performed for an empty XML tag, in which case the start tag and end tag of the returned tag are the same and it has no children.<p> If it's not an empty XML tag, the lexer is repeatedly asked for subsequent nodes until an end tag is found or a node is encountered that matches the tag ender set or end tag ender set. In the latter case, a virtual end tag is created. Each node found that is not the end tag is added to the list of children. The end tag is special and not a child.<p> Nodes that also have a CompositeTagScanner as their scanner are recursed into, which provides the nested structure of an HTML page. This method operates in two possible modes, depending on a private boolean. It can recurse on the JVM stack, which has caused some overflow problems in the past, or it can use the supplied stack argument to nest scanning of child tags within itself. The former is left as an option in the code, mostly to help subsequent modifiers visualize what the internal nesting is doing.\n * @param tag The tag this scanner is responsible for.\n * @param lexer The source of subsequent nodes.\n * @param stack The parse stack. May contain pending tags that enclosethis tag.\n * @return The resultant tag (may be unchanged).\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseString","pos":744,"doc":"/** \n * Parse a string node. Scan characters until \"&lt;/\", \"&lt;%\", \"&lt;!\" or &lt; followed by a letter is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @param quotesmart If <code>true<\/code>, strings ignore quoted contents.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanName","pos":1265,"doc":"/** \n * Scans a name. \n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parsePI","pos":1568,"doc":"/** \n * Parse an XML processing instruction. Scan characters until \"?&gt;\" is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanMarkupContent","pos":2392,"doc":"/** \n * Scans markup content. \n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanUntilEndTag","pos":2102,"doc":"/** \n * Scans the content of <noscript>: it doesn't get parsed but is considered as plain text when feature  {@link HTMLScanner#PARSE_NOSCRIPT_CONTENT} is set to false.\n * @param the tag for which content is scanned (one of \"noscript\", \"noframes\", \"iframe\")\n * @throws IOException\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanStartElement","pos":2569,"doc":"/** \n * Scans a start element. \n * @param empty Is used for a second return value to indicate whetherthe start element tag is empty (e.g. \"/&gt;\").\n */\n"},{"file_path":"dataset/org/cowan/tagsoup/tagsoup/1.2.1/org/ccil/cowan/tagsoup/HTMLScanner.java","method":"scan","pos":378,"doc":"/** \n * Scan HTML source, reporting lexical events.\n * @param r0 Reader that provides characters\n * @param h ScanHandler that accepts lexical events.\n */\n"},{"file_path":"dataset/org/htmlparser/htmllexer/2.1/org/htmlparser/lexer/Lexer.java","method":"parseJsp","pos":1387,"doc":"/** \n * Parse a java server page node. Scan characters until \"%&gt;\" is encountered, or the input stream is exhausted, in which case <code>null<\/code> is returned.\n * @param start The position at which to start scanning.\n * @return The parsed node.\n * @exception ParserException If a problem occurs reading from the source.\n */\n"},{"file_path":"dataset/net/sourceforge/nekohtml/nekohtml/1.9.15/org/cyberneko/html/HTMLScanner.java","method":"scanAttribute","pos":2756,"doc":"/** \n * Scans an attribute, pseudo or real. \n * @param attributes The list of attributes.\n * @param empty      Is used for a second return value to indicate whether the start element tag is empty  (e.g. \"/&gt;\").\n * @param endc       The end character that appears before theclosing angle bracket ('>').\n */\n"}]}