{"sampleIndex":2,"questions":{"11":{"codeB":"protected void retrieveToken(OAuthConsumer consumer,String endpointUrl,HttpParameters customOAuthParams) throws OAuthMessageSignerException, OAuthCommunicationException, OAuthNotAuthorizedException, OAuthExpectationFailedException {\n\tMap<String,String> defaultHeaders=getRequestHeaders();\n\tif(consumer.getConsumerKey() == null || consumer.getConsumerSecret() == null){\n\t\tthrow new OAuthExpectationFailedException(\"Consumer key or secret not set\");\n\t}\n\tHttpRequest request=null;\n\tHttpResponse response=null;\n\ttry {\n\t\trequest=createRequest(endpointUrl);\n\t\tfor (String header : defaultHeaders.keySet()){\n\t\t\trequest.setHeader(header,defaultHeaders.get(header));\n\t\t}\n\t\tif(customOAuthParams != null && !customOAuthParams.isEmpty()){\n\t\t\tconsumer.setAdditionalParameters(customOAuthParams);\n\t\t}\n\t\tif(this.listener != null){\n\t\t\tthis.listener.prepareRequest(request);\n\t\t}\n\t\tconsumer.sign(request);\n\t\tif(this.listener != null){\n\t\t\tthis.listener.prepareSubmission(request);\n\t\t}\n\t\tresponse=sendRequest(request);\n\t\tint statusCode=response.getStatusCode();\n\t\tboolean requestHandled=false;\n\t\tif(this.listener != null){\n\t\t\trequestHandled=this.listener.onResponseReceived(request,response);\n\t\t}\n\t\tif(requestHandled){\n\t\t\treturn;\n\t\t}\n\t\tif(statusCode >= 300){\n\t\t\thandleUnexpectedResponse(statusCode,response);\n\t\t}\n\t\tHttpParameters responseParams=OAuth.decodeForm(response.getContent());\n\t\tString token=responseParams.getFirst(OAuth.OAUTH_TOKEN);\n\t\tString secret=responseParams.getFirst(OAuth.OAUTH_TOKEN_SECRET);\n\t\tresponseParams.remove(OAuth.OAUTH_TOKEN);\n\t\tresponseParams.remove(OAuth.OAUTH_TOKEN_SECRET);\n\t\tsetResponseParameters(responseParams);\n\t\tif(token == null || secret == null){\n\t\t\tthrow new OAuthExpectationFailedException(\"Request token or token secret not set in server reply. \" + \"The service provider you use is probably buggy.\");\n\t\t}\n\t\tconsumer.setTokenWithSecret(token,secret);\n\t} catch (OAuthNotAuthorizedException e){\n\t\tthrow e;\n\t} catch (OAuthExpectationFailedException e){\n\t\tthrow e;\n\t} catch (Exception e){\n\t\tthrow new OAuthCommunicationException(e);\n\t} finally {\n\t\ttry {\n\t\t\tcloseConnection(request,response);\n\t\t} catch (Exception e){\n\t\t\tthrow new OAuthCommunicationException(e);\n\t\t} \n\t} \n}","codeA":"protected OAuthConsumerToken getTokenFromProvider(ProtectedResourceDetails details,URL tokenURL,String httpMethod,OAuthConsumerToken requestToken,Map<String,String> additionalParameters){\n\tboolean isAccessToken=requestToken != null;\n\tif(!isAccessToken){\n\t\trequestToken=new OAuthConsumerToken();\n\t\trequestToken.setNonce(getNonceFactory().generateNonce());\n\t}\n\tInputStream inputStream=readResource(details,tokenURL,httpMethod,requestToken,additionalParameters);\n\tString tokenInfo;\n\ttry {\n\t\tByteArrayOutputStream out=new ByteArrayOutputStream();\n\t\tbyte[] buffer=new byte[1024];\n\t\tint len=inputStream.read(buffer);\n\t\twhile(len >= 0){\n\t\t\tout.write(buffer,0,len);\n\t\t\tlen=inputStream.read(buffer);\n\t\t}\n\t\ttokenInfo=new String(out.toByteArray(),\"UTF-8\");\n\t} catch (IOException e){\n\t\tthrow new OAuthRequestFailedException(\"Unable to read the token.\",e);\n\t} \n\tStringTokenizer tokenProperties=new StringTokenizer(tokenInfo,\"&\");\n\tMap<String,String> tokenPropertyValues=new TreeMap<String,String>();\n\twhile(tokenProperties.hasMoreElements()){\n\t\ttry {\n\t\t\tString tokenProperty=(String)tokenProperties.nextElement();\n\t\t\tint equalsIndex=tokenProperty.indexOf('=');\n\t\t\tif(equalsIndex > 0){\n\t\t\t\tString propertyName=OAuthCodec.oauthDecode(tokenProperty.substring(0,equalsIndex));\n\t\t\t\tString propertyValue=OAuthCodec.oauthDecode(tokenProperty.substring(equalsIndex + 1));\n\t\t\t\ttokenPropertyValues.put(propertyName,propertyValue);\n\t\t\t} else {\n\t\t\t\ttokenProperty=OAuthCodec.oauthDecode(tokenProperty);\n\t\t\t\ttokenPropertyValues.put(tokenProperty,null);\n\t\t\t}\n\t\t} catch (DecoderException e){\n\t\t\tthrow new OAuthRequestFailedException(\"Unable to decode token parameters.\");\n\t\t} \n\t}\n\tString tokenValue=tokenPropertyValues.remove(OAuthProviderParameter.oauth_token.toString());\n\tif(tokenValue == null){\n\t\tthrow new OAuthRequestFailedException(\"OAuth provider failed to return a token.\");\n\t}\n\tString tokenSecret=tokenPropertyValues.remove(OAuthProviderParameter.oauth_token_secret.toString());\n\tif(tokenSecret == null){\n\t\tthrow new OAuthRequestFailedException(\"OAuth provider failed to return a token secret.\");\n\t}\n\tOAuthConsumerToken consumerToken=new OAuthConsumerToken();\n\tconsumerToken.setValue(tokenValue);\n\tconsumerToken.setSecret(tokenSecret);\n\tconsumerToken.setNonce(requestToken.getNonce());\n\tconsumerToken.setResourceId(details.getId());\n\tconsumerToken.setAccessToken(isAccessToken);\n\tif(!tokenPropertyValues.isEmpty()){\n\t\tconsumerToken.setAdditionalParameters(tokenPropertyValues);\n\t}\n\treturn consumerToken;\n}","method":0,"docB":"<p> Implemented by subclasses. The responsibility of this method is to contact the service provider at the given endpoint URL and fetch a request or access token. What kind of token is retrieved solely depends on the URL being used. <\/p> <p> Correct implementations of this method must guarantee the following post-conditions: <ul> <li>the  {@link OAuthConsumer} passed to this method must have a valid{@link OAuth#OAUTH_TOKEN} and {@link OAuth#OAUTH_TOKEN_SECRET} set bycalling  {@link OAuthConsumer#setTokenWithSecret(String,String)}<\/li> <li> {@link #getResponseParameters()} must return the set of queryparameters served by the service provider in the token response, with all OAuth specific parameters being removed<\/li> <\/ul> <\/p>","docA":"Get the consumer token with the given parameters and URL. The determination of whether the retrieved token is an access token depends on whether a request token is provided.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"12":{"codeB":"public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tDiffScope scope=null;\n\tif(diffUnit instanceof XMLDocumentDiffUnit){\n\t\tXMLDocumentDiffUnit du=(XMLDocumentDiffUnit)diffUnit;\n\t\tDocumentType dt1=du.getLeftDoctype();\n\t\tDocumentType dt2=du.getRightDoctype();\n\t} else if(diffUnit instanceof XMLNodeDiffUnit){\n\t\tXMLNodeDiffUnit du=(XMLNodeDiffUnit)diffUnit;\n\t\tNode n1=du.getLeftNode();\n\t\tNode n2=du.getRightNode();\n\t\tif(n1 != null && n2 != null){\n\t\t\tString v1=n1.getNodeValue();\n\t\t\tString v2=n2.getNodeValue();\n\t\t\tif(v1 != null && v2 != null){\n\t\t\t\tif(!v1.equals(v2)){\n\t\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Node value mismatch: \" + v1 + \", \"+ v2);\n\t\t\t\t\tprocessor.processDiffPoint(diffPoint);\n\t\t\t\t}\n\t\t\t} else if(v1 == null && v2 != null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Node value present in right only\");\n\t\t\t\tprocessor.processDiffPoint(diffPoint);\n\t\t\t} else if(v1 != null && v2 == null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Node value present in left only\");\n\t\t\t\tprocessor.processDiffPoint(diffPoint);\n\t\t\t}\n\t\t} else if(n1 == null && n2 != null){\n\t\t} else if(n1 != null && n2 == null){\n\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Node present in left only\");\n\t\t\tprocessor.processDiffPoint(diffPoint);\n\t\t}\n\t} else \n\treturn scope;\n}","codeA":"public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tProperties p1=new Properties();\n\tProperties p2=new Properties();\n\tInputStream is1=null;\n\tInputStream is2=null;\n\ttry {\n\t\tis1=diffUnit.getLeftInputStream();\n\t\tis2=diffUnit.getRightInputStream();\n\t\tp1.load(is1);\n\t\tp2.load(is2);\n\t\tSet<String> keys=new TreeSet<String>();\n\t\tkeys.addAll(p1.stringPropertyNames());\n\t\tkeys.addAll(p2.stringPropertyNames());\n\t\tfor (Iterator<String> it=keys.iterator(); it.hasNext(); ){\n\t\t\tString key=it.next();\n\t\t\tString v1=p1.getProperty(key);\n\t\t\tString v2=p2.getProperty(key);\n\t\t}\n\t} catch (IOException ioe){\n\t\tlog.error(\"Failure comparing properties file: \" + diffUnit.getScopedPath(),ioe);\n\t} finally {\n\t\tif(is2 != null){\n\t\t}\n\t} \n}","method":1,"docB":"Performs a deep XML comparison on <code>diffUnit<\/code>. If <code>diffUnit<\/code> represents part of a DOM, compares the unit and passes any {@link DiffPoint}s found to <code>processor<\/code>. Otherwise, returns a new {@link DiffScope} to process the XML document.","docA":"Performs a Properties comparison on <code>diffUnit<\/code>, and passes any {@link DiffPoint}s found to <code>processor<\/code>. The properties are iterated through and their values compared.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"13":{"codeB":"public Tag scan(Tag tag,Lexer lexer,NodeList stack) throws ParserException {\n\tString language;\n\tString code;\n\tNode content;\n\tint position;\n\tNode node;\n\tAttribute attribute;\n\tVector vector;\n\tcontent=lexer.parseCDATA(!STRICT);\n\tposition=lexer.getPosition();\n\tif(null == node){\n\t\tattribute=new Attribute(\"/script\",null);\n\t\tvector=new Vector();\n\t\tvector.addElement(attribute);\n\t\tnode=lexer.getNodeFactory().createTagNode(lexer.getPage(),position,position,vector);\n\t}\n\tif(null != content){\n\t\ttag.setChildren(new NodeList(content));\n\t\tcontent.setParent(tag);\n\t}\n\tnode.setParent(tag);\n\ttag.doSemanticAction();\n}","codeA":"public Tag scan(Tag tag,Lexer lexer,NodeList stack) throws ParserException {\n\tNode content;\n\tint position;\n\tNode node;\n\tAttribute attribute;\n\tVector vector;\n\tcontent=lexer.parseCDATA();\n\tposition=lexer.getPosition();\n\tif(null == node){\n\t\tattribute=new Attribute(\"/style\",null);\n\t\tvector=new Vector();\n\t\tvector.addElement(attribute);\n\t\tnode=lexer.getNodeFactory().createTagNode(lexer.getPage(),position,position,vector);\n\t}\n\tnode.setParent(tag);\n\ttag.doSemanticAction();\n\treturn (tag);\n}","method":2,"docB":"Scan for style definitions. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.","docA":"Scan for script. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"14":{"codeB":"protected URL[][] extractImageLinks(final Lexer lexer,final URL docbase) throws IOException, ParserException {\n\tHashMap<String,URL> images;\n\tHashMap<String,URL> links;\n\tboolean ina;\n\tNode node;\n\tTag tag;\n\tString name;\n\tTag startatag;\n\tTag imgtag;\n\tString href;\n\tString src;\n\tURL url;\n\tURL[][] ret;\n\timages=new HashMap<String,URL>();\n\tlinks=new HashMap<String,URL>();\n\tina=false;\n\tstartatag=null;\n\timgtag=null;\n\twhile(null != (node=lexer.nextNode())){\n\t\tif(node instanceof Tag){\n\t\t\ttag=(Tag)node;\n\t\t\tname=tag.getTagName();\n\t\t\tif(\"A\".equals(name)){\n\t\t\t\tif(tag.isEndTag()){\n\t\t\t\t\tina=false;\n\t\t\t\t\tif(null != imgtag){\n\t\t\t\t\t\thref=startatag.getAttribute(\"HREF\");\n\t\t\t\t\t\tif(null != href){\n\t\t\t\t\t\t\tif(isImage(href)){\n\t\t\t\t\t\t\t\tsrc=imgtag.getAttribute(\"SRC\");\n\t\t\t\t\t\t\t\tif(null != src)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\turl=new URL(docbase,href);\n\t\t\t\t\t\t\t\t\t\thref=url.toString();\n\t\t\t\t\t\t\t\t\t\tif(!images.containsKey(href))\n\t\t\t\t\t\t\t\t\t\t\timages.put(href,url);\n\t\t\t\t\t\t\t\t\t} catch (MalformedURLException murle){\n\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstartatag=tag;\n\t\t\t\t\timgtag=null;\n\t\t\t\t\tina=true;\n\t\t\t\t\thref=startatag.getAttribute(\"HREF\");\n\t\t\t\t\tif(null != href){\n\t\t\t\t\t\tif(!isImage(href))\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\turl=new URL(docbase,href);\n\t\t\t\t\t\t\t\thref=url.toString();\n\t\t\t\t\t\t\t\tif(!links.containsKey(href))\n\t\t\t\t\t\t\t\t\tlinks.put(href,url);\n\t\t\t\t\t\t\t} catch (MalformedURLException murle){\n\t\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(ina && \"IMG\".equals(name))\n\t\t\t\timgtag=tag;\n\t\t}\n\t}\n\tret=new URL[2][];\n\tret[0]=new URL[images.size()];\n\timages.values().toArray(ret[0]);\n\tret[1]=new URL[links.size()];\n\tlinks.values().toArray(ret[1]);\n\treturn (ret);\n}","codeA":"public String extractImageLocn(){\n\tVector attributes;\n\tint size;\n\tAttribute attribute;\n\tString string;\n\tString data;\n\tint state;\n\tString name;\n\tString ret;\n\tret=\"\";\n\tstate=0;\n\tattributes=getAttributesEx();\n\tsize=attributes.size();\n\tfor (int i=0; (i < size) && (state < 3); i++){\n\t\tattribute=(Attribute)attributes.elementAt(i);\n\t\tstring=attribute.getName();\n\t\tdata=attribute.getValue();\n\t\tswitch (state){\n\t\tcase 0: \n\t\t\tif(null != string){\n\t\t\t\tname=string.toUpperCase(Locale.ENGLISH);\n\t\t\t\tif(name.equals(\"SRC\")){\n\t\t\t\t\tstate=1;\n\t\t\t\t\tif(null != data){\n\t\t\t\t\t\tif(\"\".equals(data))\n\t\t\t\t\t\t\tstate=2;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tret=data;\n\t\t\t\t\t\t\ti=size;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if(name.startsWith(\"SRC\")){\n\t\t\t\t\tstring=string.substring(3);\n\t\t\t\t\tif(string.startsWith(\"\\\"\") && string.endsWith(\"\\\"\") && (1 < string.length()))\n\t\t\t\t\t\tstring=string.substring(1,string.length() - 1);\n\t\t\t\t\tif(string.startsWith(\"'\") && string.endsWith(\"'\") && (1 < string.length()))\n\t\t\t\t\t\tstring=string.substring(1,string.length() - 1);\n\t\t\t\t\tret=string;\n\t\t\t\t\tstate=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tif(null != string){\n\t\t\t\tif(string.startsWith(\"=\")){\n\t\t\t\t\tstate=2;\n\t\t\t\t\tif(1 < string.length()){\n\t\t\t\t\t\tret=string.substring(1);\n\t\t\t\t\t\tstate=0;\n\t\t\t\t\t} else if(null != data){\n\t\t\t\t\t\tret=string.substring(1);\n\t\t\t\t\t\tstate=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tif(null != string){\n\t\t\t\tif(null == data)\n\t\t\t\t\tret=string;\n\t\t\t\tstate=0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"we're not supposed to in state \" + state);\n\t\t}\n\t}\n\tret=ParserUtils.removeChars(ret,'\\n');\n\tret=ParserUtils.removeChars(ret,'\\r');\n\treturn (ret);\n}","method":0,"docB":"Get the links of an element of a document. Only gets the links on IMG elements that reference another image. The latter is based on suffix (.jpg, .gif and .png).","docA":"Extract the location of the image Given the tag (with attributes), and the url of the html page in which this tag exists, perform best effort to extract the 'intended' URL. Attempts to handle such attributes as: <pre> &lt;IMG SRC=http://www.redgreen.com&gt; - normal &lt;IMG SRC =http://www.redgreen.com&gt; - space between attribute name and equals sign &lt;IMG SRC= http://www.redgreen.com&gt; - space between equals sign and attribute value &lt;IMG SRC = http://www.redgreen.com&gt; - space both sides of equals sign <\/pre>\n","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"15":{"codeB":"private StyleProp createProps(StyleProp prop,String style){\n\tint nameEnd;\n\tint valueEnd;\n\tint valueStart=0;\n\tint nameStart=0;\n\tboolean more;\n\tnameStart=0;\n\twhile(nameStart < style.length()){\n\t\twhile(nameStart < style.length() && style.charAt(nameStart) == ' '){\n\t\t\t++nameStart;\n\t\t}\n\t\tnameEnd=nameStart;\n\t\tvalueEnd=valueStart;\n\t\tmore=false;\n\t\tprop=insertProperty(prop,style.substring(nameStart,nameEnd),style.substring(valueStart,valueEnd));\n\t\tif(more){\n\t\t\tnameStart=valueEnd + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n}","codeA":"private void createStyleElement(Lexer lexer,Node doc){\n\tNode node, head, body;\n\tStyle style;\n\tAttVal av;\n\tnode=lexer.newNode(Node.START_TAG,null,0,0,\"style\");\n\tnode.implicit=true;\n\tav=new AttVal(null,null,'\"',\"type\",\"text/css\");\n\tav.dict=AttributeTable.getDefaultAttributeTable().findAttribute(av);\n\tnode.attributes=av;\n\tbody=doc.findBody(lexer.configuration.tt);\n\tlexer.txtstart=lexer.lexsize;\n\tlexer.txtend=lexer.lexsize;\n\tnode.insertNodeAtEnd(lexer.newNode(Node.TEXT_NODE,lexer.lexbuf,lexer.txtstart,lexer.txtend));\n\thead=doc.findHEAD(lexer.configuration.tt);\n\tif(head != null){\n\t\thead.insertNodeAtEnd(node);\n\t}\n}","method":1,"docB":"Create style element using rules from dictionary.","docA":"Create sorted linked list of properties from style string.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"16":{"code_mymethod":{"r10":"public static String expandSystemId(String systemId,String baseSystemId){\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r20":"public static String expandSystemId(String systemId,String baseSystemId){\n\ttry {\n\t\tURI uri=new URI(systemId);\n\t} catch (URI.MalformedURIException e){\n\t} \n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tif(baseSystemId.indexOf(':') != -1){\n\t\t\t\t\tbase=new URI(\"file\",\"\",fixURI(baseSystemId),null,null);\n\t\t\t\t} else {\n\t\t\t\t\tdir=dir + fixURI(baseSystemId);\n\t\t\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r50%":"public static String expandSystemId(String systemId,String baseSystemId){\n\ttry {\n\t\tURI uri=new URI(systemId);\n\t\tif(uri != null){\n\t\t}\n\t} catch (URI.MalformedURIException e){\n\t} \n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\ttry {\n\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t} catch (SecurityException se){\n\t\t\t} \n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tif(baseSystemId.indexOf(':') != -1){\n\t\t\t\t\tbase=new URI(\"file\",\"\",fixURI(baseSystemId),null,null);\n\t\t\t\t} else {\n\t\t\t\t\tdir=dir + fixURI(baseSystemId);\n\t\t\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}"},"code_native":{"r10":"public static String expandSystemId(String systemId,String baseSystemId){\n\tif(systemId == null || systemId.length() == 0){\n\t\treturn systemId;\n\t}\n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r20":"public static String expandSystemId(String systemId,String baseSystemId){\n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tString dir;\n\t\t\t\ttry {\n\t\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t\t} catch (SecurityException se){\n\t\t\t\t\tdir=\"\";\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r50%":"public static String expandSystemId(String systemId,String baseSystemId){\n\tif(systemId == null || systemId.length() == 0){\n\t\treturn systemId;\n\t}\n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\ttry {\n\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t} catch (SecurityException se){\n\t\t\t\tdir=\"\";\n\t\t\t} \n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tString dir;\n\t\t\t\ttry {\n\t\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t\t} catch (SecurityException se){\n\t\t\t\t\tdir=\"\";\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n}"},"method":0,"code_original":"public static String expandSystemId(String systemId,String baseSystemId){\n\tif(systemId == null || systemId.length() == 0){\n\t\treturn systemId;\n\t}\n\ttry {\n\t\tURI uri=new URI(systemId);\n\t\tif(uri != null){\n\t\t\treturn systemId;\n\t\t}\n\t} catch (URI.MalformedURIException e){\n\t} \n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\ttry {\n\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t} catch (SecurityException se){\n\t\t\t\tdir=\"\";\n\t\t\t} \n\t\t\tif(!dir.endsWith(\"/\")){\n\t\t\t\tdir=dir + \"/\";\n\t\t\t}\n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tString dir;\n\t\t\t\ttry {\n\t\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t\t} catch (SecurityException se){\n\t\t\t\t\tdir=\"\";\n\t\t\t\t} \n\t\t\t\tif(baseSystemId.indexOf(':') != -1){\n\t\t\t\t\tbase=new URI(\"file\",\"\",fixURI(baseSystemId),null,null);\n\t\t\t\t} else {\n\t\t\t\t\tif(!dir.endsWith(\"/\")){\n\t\t\t\t\t\tdir=dir + \"/\";\n\t\t\t\t\t}\n\t\t\t\t\tdir=dir + fixURI(baseSystemId);\n\t\t\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\tif(uri == null){\n\t\treturn systemId;\n\t}\n\treturn uri.toString();\n}","type":"T3"},"17":{"code_mymethod":{"r10":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t}\n\t} else {\n\t}\n\treturn newInstance(fallbackClassName,cl,true);\n}","r20":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\treturn newInstance(fallbackClassName,cl,true);\n}","r50%":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\ttry {\n\t\t\t\tif(fLastModified >= 0){\n\t\t\t\t} else {\n\t\t\t\t\tif(propertiesFileExists){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t\tfLastModified=ss.getLastModified(propertiesFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t} \n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\treturn newInstance(fallbackClassName,cl,true);\n}"},"code_native":{"r10":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(factoryClassName != null){\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n}","r20":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(factoryClassName != null){\n\t\tif(DEBUG)\n\t\t\tdebugPrintln(\"found in \" + propertiesFilename + \", value=\"+ factoryClassName);\n\t\treturn newInstance(factoryClassName,cl,true);\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n\treturn newInstance(fallbackClassName,cl,true);\n}","r50%":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tString javah=ss.getSystemProperty(\"java.home\");\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t\tfLastModified=-1;\n\t\t\tfXercesProperties=null;\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\tboolean loadProperties=false;\n\t\t\ttry {\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t\tfXercesProperties=null;\n\t\t\t\tfLastModified=-1;\n\t\t\t} \n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(DEBUG)\n\treturn newInstance(fallbackClassName,cl,true);\n}"},"method":0,"code_original":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\tif(DEBUG)\n\t\t\t\tdebugPrintln(\"found system property, value=\" + systemProp);\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tString javah=ss.getSystemProperty(\"java.home\");\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t\tfLastModified=-1;\n\t\t\tfXercesProperties=null;\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\tboolean loadProperties=false;\n\t\t\ttry {\n\t\t\t\tif(fLastModified >= 0){\n\t\t\t\t\tif(propertiesFileExists && (fLastModified < (fLastModified=ss.getLastModified(propertiesFile)))){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(!propertiesFileExists){\n\t\t\t\t\t\t\tfLastModified=-1;\n\t\t\t\t\t\t\tfXercesProperties=null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(propertiesFileExists){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t\tfLastModified=ss.getLastModified(propertiesFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t\tfXercesProperties=null;\n\t\t\t\tfLastModified=-1;\n\t\t\t} \n\t\t}\n\t\tif(fXercesProperties != null){\n\t\t\tfactoryClassName=fXercesProperties.getProperty(factoryId);\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tif(factoryClassName != null){\n\t\tif(DEBUG)\n\t\t\tdebugPrintln(\"found in \" + propertiesFilename + \", value=\"+ factoryClassName);\n\t\treturn newInstance(factoryClassName,cl,true);\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(provider != null){\n\t\treturn provider;\n\t}\n\tif(fallbackClassName == null){\n\t\tthrow new ConfigurationError(\"Provider for \" + factoryId + \" cannot be found\",null);\n\t}\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n\treturn newInstance(fallbackClassName,cl,true);\n}","type":"T3"},"18":{"code_mymethod":{"r10":"protected void copy(){\n\tif(getCaptureResources()){\n\t\ttry {\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t} finally {\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n}","r20":"protected void copy(){\n\tString link;\n\tString name;\n\tFile file;\n\tFile dir;\n\tbyte[] data;\n\tInputStream in;\n\tif(getCaptureResources()){\n\t\ttry {\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t\ttry {\n\t\t\t\tin=source.openStream();\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile(-1 != (read=in.read(data,0,data.length)))\n\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t} finally {\n\t\t\t\t\tin.close();\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n}","r50%":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tbyte[] data;\n\tInputStream in;\n\tint read;\n\tif(getCaptureResources()){\n\t\traw=makeLocalLink(link,\"\");\n\t\tfile=new File(getTarget(),name);\n\t\ttry {\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t\ttry {\n\t\t\t\tin=source.openStream();\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile(-1 != (read=in.read(data,0,data.length)))\n\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t} finally {\n\t\t\t\t\tin.close();\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n}"},"code_native":{"r10":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tlink=(String)mImages.remove(0);\n}","r20":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tint read;\n\tlink=(String)mImages.remove(0);\n\tif(getCaptureResources()){\n\t\traw=makeLocalLink(link,\"\");\n\t\tname=decode(raw);\n\t\tfile=new File(getTarget(),name);\n\t\tSystem.out.println(\"copying \" + link + \" to \"+ file.getAbsolutePath());\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t}\n}","r50%":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tint read;\n\tlink=(String)mImages.remove(0);\n\tmCopied.add(link);\n\tif(getCaptureResources()){\n\t\tfile=new File(getTarget(),name);\n\t\tSystem.out.println(\"copying \" + link + \" to \"+ file.getAbsolutePath());\n\t\tdir=file.getParentFile();\n\t\ttry {\n\t\t\tsource=new URL(link);\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t} catch (MalformedURLException murle){\n\t\t\tmurle.printStackTrace();\n\t\t} catch (IOException ioe){\n\t\t\tioe.printStackTrace();\n\t\t} \n\t}\n}"},"method":0,"code_original":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tint read;\n\tlink=(String)mImages.remove(0);\n\tmCopied.add(link);\n\tif(getCaptureResources()){\n\t\traw=makeLocalLink(link,\"\");\n\t\tname=decode(raw);\n\t\tfile=new File(getTarget(),name);\n\t\tSystem.out.println(\"copying \" + link + \" to \"+ file.getAbsolutePath());\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t\ttry {\n\t\t\tsource=new URL(link);\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t\ttry {\n\t\t\t\tin=source.openStream();\n\t\t\t\ttry {\n\t\t\t\t\tout=new FileOutputStream(file);\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile(-1 != (read=in.read(data,0,data.length)))\n\t\t\t\t\t\t\tout.write(data,0,read);\n\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t\tfnfe.printStackTrace();\n\t\t\t\t} finally {\n\t\t\t\t\tin.close();\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\tSystem.err.println(\"broken link \" + fnfe.getMessage() + \" ignored\");\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t\tmurle.printStackTrace();\n\t\t} catch (IOException ioe){\n\t\t\tioe.printStackTrace();\n\t\t} \n\t}\n}","type":"T3"},"19":{"code_mymethod":{"r10":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\ttry {\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t} catch (EncodingChangeException ece){\n\t\t} \n\t\ttry {\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t} catch (FileNotFoundException fnfe){\n\t\t} \n\t} catch (ParserException pe){\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t} else \n\t} \n}","r20":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tbookmark=mPages.size();\n\t\ttry {\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(0 != robots.size()){\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"nofollow\")))\n\t\t\t\tfor (int i=bookmark; i < mPages.size(); i++)\n\t\t}\n\t\tdir=file.getParentFile();\n\t\ttry {\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t} catch (FileNotFoundException fnfe){\n\t\t} \n\t} catch (ParserException pe){\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t} else \n\t} \n}","r50%":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tbookmark=mPages.size();\n\t\ttry {\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(0 != robots.size()){\n\t\t\trobot=(MetaTag)robots.elementAt(0);\n\t\t\tcontent=robot.getAttribute(\"content\").toLowerCase();\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"nofollow\")))\n\t\t\t\tfor (int i=bookmark; i < mPages.size(); i++)\n\t\t}\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t\telse if(!dir.isDirectory()){\n\t\t\tdir=new File(dir.getParentFile(),dir.getName() + \".content\");\n\t\t\tfile=new File(dir,file.getName());\n\t\t}\n\t\ttry {\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t} catch (FileNotFoundException fnfe){\n\t\t} \n\t} catch (ParserException pe){\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}"},"code_native":{"r10":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\tPrintWriter out;\n\turl=(String)mPages.remove(0);\n}","r20":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\tPrintWriter out;\n\turl=(String)mPages.remove(0);\n\tSystem.out.println(\"processing \" + url);\n\ttry {\n\t\tbookmark=mPages.size();\n\t\tmParser.setURL(url);\n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t} catch (ParserException pe){\n\t} \n}","r50%":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tmParser.setURL(url);\n\t\ttry {\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t\tmParser.reset();\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t} catch (ParserException pe){\n\t\tString message;\n\t\tmessage=pe.getMessage();\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}"},"method":0,"code_original":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\tPrintWriter out;\n\turl=(String)mPages.remove(0);\n\tSystem.out.println(\"processing \" + url);\n\tmFinished.add(url);\n\ttry {\n\t\tbookmark=mPages.size();\n\t\tmParser.setURL(url);\n\t\ttry {\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t\tmParser.reset();\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(0 != robots.size()){\n\t\t\trobot=(MetaTag)robots.elementAt(0);\n\t\t\tcontent=robot.getAttribute(\"content\").toLowerCase();\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"nofollow\")))\n\t\t\t\tfor (int i=bookmark; i < mPages.size(); i++)\n\t\t\t\t\tmPages.remove(i);\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"noindex\")))\n\t\t\t\treturn;\n\t\t}\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t\telse if(!dir.isDirectory()){\n\t\t\tdir=new File(dir.getParentFile(),dir.getName() + \".content\");\n\t\t\tif(!dir.exists())\n\t\t\t\tdir.mkdirs();\n\t\t\tfile=new File(dir,file.getName());\n\t\t}\n\t\ttry {\n\t\t\tout=new PrintWriter(new FileOutputStream(file));\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t\t\tout.print(list.elementAt(i).toHtml());\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException fnfe){\n\t\t\tfnfe.printStackTrace();\n\t\t} \n\t} catch (ParserException pe){\n\t\tString message;\n\t\tmessage=pe.getMessage();\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}","type":"T3"},"1":{"codes":["private static NodePointer doPredicateName(EvalContext context,NodePointer parent,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tNodePointer child=valuePointer(parent);\n\tif(child instanceof PropertyOwnerPointer){\n\t\tPropertyPointer pointer=((PropertyOwnerPointer)child).getPropertyPointer();\n\t\tif(pointer.isActual()){\n\t\t\treturn doPredicate(context,pointer,steps,currentStep,predicates,currentPredicate + 1);\n\t\t}\n\t} else if(child.isCollection()){\n\t\tNodePointer bestMatch=null;\n\t\tint bestQuality=0;\n\t\tint count=child.getLength();\n\t\tfor (int i=0; i < count; i++){\n\t\t\tchild.setIndex(i);\n\t\t\tNodePointer valuePointer=valuePointer(child);\n\t\t\tNodePointer pointer;\n\t\t\tif((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()){\n\t\t\t\tpointer=doPredicateName(context,valuePointer,steps,currentStep,predicates,currentPredicate);\n\t\t\t} else if(isNameAttributeEqual(valuePointer,key)){\n\t\t\t\tpointer=doPredicate(context,valuePointer,steps,currentStep,predicates,currentPredicate + 1);\n\t\t\t} else {\n\t\t\t\tpointer=null;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tNodePointer found=doPredicatesStandard(context,Collections.singletonList(child),steps,currentStep,predicates,currentPredicate);\n\t}\n\treturn createNullPointerForPredicates(context,child,steps,currentStep,predicates,currentPredicate);\n}","private static NodePointer doStepPredicatesStandard(EvalContext context,NodePointer parent,Step[] steps,int currentStep){\n\tStep step=steps[currentStep];\n\tExpression[] predicates=step.getPredicates();\n\tint axis=step.getAxis();\n\tExpression predicate=predicates[0];\n\tif(predicates.length == 1){\n\t\tNodeIterator it=getNodeIterator(context,parent,step);\n\t\tNodePointer pointer=null;\n\t\tif(it != null){\n\t\t\tif(predicate instanceof NameAttributeTest){\n\t\t\t\tString key=keyFromPredicate(context,predicate);\n\t\t\t\tfor (int i=1; it.setPosition(i); i++){\n\t\t\t\t\tNodePointer ptr=it.getNodePointer();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint index=indexFromPredicate(context,predicate);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tNodeIterator it=getNodeIterator(context,parent,step);\n\t\tif(it != null){\n\t\t\tList list=new ArrayList();\n\t\t\tNodePointer pointer=doPredicatesStandard(context,list,steps,currentStep,predicates,0);\n\t\t}\n\t}\n\treturn createNullPointer(context,parent,steps,currentStep);\n}","private static NodePointer doPredicatesStandard(EvalContext context,List parents,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tif(currentPredicate == predicates.length){\n\t\treturn doStep(context,pointer,steps,currentStep + 1);\n\t}\n\tExpression predicate=predicates[currentPredicate];\n\tif(predicate instanceof NameAttributeTest){\n\t\tString key=keyFromPredicate(context,predicate);\n\t\tList newList=new ArrayList();\n\t\tfor (int i=0; i < parents.size(); i++){\n\t\t}\n\t\treturn doPredicatesStandard(context,newList,steps,currentStep,predicates,currentPredicate + 1);\n\t} else {\n\t\tint index=indexFromPredicate(context,predicate);\n\t\tif(index < 0 || index >= parents.size()){\n\t\t\treturn null;\n\t\t}\n\t\treturn doPredicate(context,ptr,steps,currentStep,predicates,currentPredicate + 1);\n\t}\n}","private static NodePointer doStepNoPredicatesPropertyOwner(EvalContext context,PropertyOwnerPointer parentPointer,Step[] steps,int currentStep){\n\tNodePointer childPointer=createChildPointerForStep(parentPointer,step);\n\tif(childPointer.isCollection()){\n\t\tint bestQuality=0;\n\t\tchildPointer=(NodePointer)childPointer.clone();\n\t\tNodePointer bestMatch=null;\n\t\tint count=childPointer.getLength();\n\t\tfor (int i=0; i < count; i++){\n\t\t\tchildPointer.setIndex(i);\n\t\t\tNodePointer pointer=doStep(context,childPointer,steps,currentStep + 1);\n\t\t\tint quality=computeQuality(pointer);\n\t\t\tif(quality == PERFECT_MATCH){\n\t\t\t\treturn pointer;\n\t\t\t} else if(quality > bestQuality){\n\t\t\t\tbestQuality=quality;\n\t\t\t}\n\t\t}\n\t\treturn createNullPointer(context,childPointer,steps,currentStep);\n\t}\n\treturn doStep(context,childPointer,steps,currentStep + 1);\n}","private static NodePointer doPredicate(EvalContext context,NodePointer parent,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tif(currentPredicate == predicates.length){\n\t\treturn doStep(context,parent,steps,currentStep + 1);\n\t}\n\tif(predicate instanceof NameAttributeTest){\n\t\treturn doPredicateName(context,parent,steps,currentStep,predicates,currentPredicate);\n\t}\n\treturn doPredicateIndex(context,parent,steps,currentStep,predicates,currentPredicate);\n}"],"method":2,"correctSolution":1,"doc":"A path that starts with a standard InfoSet node, e.g. a DOM Node. The method evaluates the first predicate in a special way and then forwards to a general predicate processing method.","type":"T1"},"2":{"codes":["private boolean authenticate(String user,String passwd) throws MessagingException {\n\tString mechs=session.getProperty(\"mail.\" + name + \".auth.mechanisms\");\n\tif(mechs == null)\n\t\tmechs=defaultAuthenticationMechanisms;\n\tString authzid=getAuthorizationId();\n\tif(authzid == null)\n\t\tauthzid=user;\n\tif(enableSASL){\n\t\tif(debug)\n\t\t\tout.println(\"DEBUG SMTP: Authenticate with SASL\");\n\t\tif(sasllogin(getSASLMechanisms(),getSASLRealm(),authzid,user,passwd))\n\t\t\treturn true;\n\t\tif(debug)\n\t\t\tout.println(\"DEBUG SMTP: SASL authentication failed\");\n\t}\n\tif(debug){\n\t\tout.println(\"DEBUG SMTP: Attempt to authenticate\");\n\t\tout.println(\"DEBUG SMTP: check mechanisms: \" + mechs);\n\t}\n\tStringTokenizer st=new StringTokenizer(mechs);\n\twhile(st.hasMoreTokens()){\n\t\tString m=st.nextToken();\n\t\tString dprop=\"mail.\" + name + \".auth.\"+ m.toLowerCase(Locale.ENGLISH)+ \".disable\";\n\t\tboolean disabled=PropUtil.getBooleanSessionProperty(session,dprop,false);\n\t\tif(disabled){\n\t\t\tif(debug)\n\t\t\t\tout.println(\"DEBUG SMTP: mechanism \" + m + \" disabled by property: \"+ dprop);\n\t\t\tcontinue;\n\t\t}\n\t\tm=m.toUpperCase(Locale.ENGLISH);\n\t\tif(!supportsAuthentication(m)){\n\t\t\tif(debug)\n\t\t\t\tout.println(\"DEBUG SMTP: mechanism \" + m + \" not supported by server\");\n\t\t\tcontinue;\n\t\t}\n\t\tAuthenticator a=(Authenticator)authenticators.get(m);\n\t\tif(a == null){\n\t\t\tif(debug)\n\t\t\t\tout.println(\"DEBUG SMTP: \" + \"no authenticator for mechanism \" + m);\n\t\t\tcontinue;\n\t\t}\n\t\treturn a.authenticate(host,authzid,user,passwd);\n\t}\n\tthrow new AuthenticationFailedException(\"No authentication mechansims supported by both server and client\");\n}","public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method,String username,String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {\n\tif(!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE,method.getAuthName()))){\n\t\treturn false;\n\t}\n\tswitch (method){\n\tcase PLAIN:  {\n\t\tint result=sendData(new String(Base64.encodeBase64((\"\\000\" + username + \"\\000\"+ password).getBytes())));\n\t\tif(result == IMAPReply.OK){\n\t\t\tsetState(IMAP.IMAPState.AUTH_STATE);\n\t\t}\n\t\treturn result == IMAPReply.OK;\n\t}\n\tcase CRAM_MD5:  {\n\t\tbyte[] serverChallenge=Base64.decodeBase64(getReplyString().substring(2).trim());\n\t\tMac hmac_md5=Mac.getInstance(\"HmacMD5\");\n\t\thmac_md5.init(new SecretKeySpec(password.getBytes(),\"HmacMD5\"));\n\t\tbyte[] hmacResult=_convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();\n\t\tbyte[] usernameBytes=username.getBytes();\n\t\tbyte[] toEncode=new byte[usernameBytes.length + 1 + hmacResult.length];\n\t\tSystem.arraycopy(usernameBytes,0,toEncode,0,usernameBytes.length);\n\t\ttoEncode[usernameBytes.length]=' ';\n\t\tSystem.arraycopy(hmacResult,0,toEncode,usernameBytes.length + 1,hmacResult.length);\n\t\tint result=sendData(new String(Base64.encodeBase64(toEncode)));\n\t\tif(result == IMAPReply.OK){\n\t\t\tsetState(IMAP.IMAPState.AUTH_STATE);\n\t\t}\n\t\treturn result == IMAPReply.OK;\n\t}\n\tcase LOGIN:  {\n\t\tif(sendData(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT){\n\t\t\treturn false;\n\t\t}\n\t\tint result=sendData(new String(Base64.encodeBase64(password.getBytes())));\n\t\tif(result == IMAPReply.OK){\n\t\t\tsetState(IMAP.IMAPState.AUTH_STATE);\n\t\t}\n\t\treturn result == IMAPReply.OK;\n\t}\n\t}\n\treturn false;\n}","public synchronized void authlogin(String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE LOGIN command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE LOGIN\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tByteArrayOutputStream bos=new ByteArrayOutputStream();\n\t\tOutputStream b64os=new BASE64EncoderStream(bos,Integer.MAX_VALUE);\n\t\tboolean first=true;\n\t\twhile(!done){\n\t\t\ttry {\n\t\t\t\tr=readResponse();\n\t\t\t\tif(r.isContinuation()){\n\t\t\t\t\tString s;\n\t\t\t\t\tif(first){\n\t\t\t\t\t\ts=u;\n\t\t\t\t\t\tfirst=false;\n\t\t\t\t\t} else \n\t\t\t\t\t\ts=p;\n\t\t\t\t\tb64os.write(ASCIIUtility.getBytes(s));\n\t\t\t\t\tb64os.flush();\n\t\t\t\t\tbos.write(CRLF);\n\t\t\t\t\tos.write(bos.toByteArray());\n\t\t\t\t\tos.flush();\n\t\t\t\t\tbos.reset();\n\t\t\t\t} else if(r.isTagged() && r.getTag().equals(tag))\n\t\t\t\t\tdone=true;\n\t\t\t\telse if(r.isBYE())\n\t\t\t\t\tdone=true;\n\t\t\t\telse \n\t\t\t\t\tv.addElement(r);\n\t\t\t} catch (Exception ioex){\n\t\t\t\tr=Response.byeResponse(ioex);\n\t\t\t\tdone=true;\n\t\t\t} \n\t\t}\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE LOGIN command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}","public synchronized void authntlm(String authzid,String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\tString type1Msg=null;\n\tint flags=PropUtil.getIntProperty(props,\"mail.\" + name + \".auth.ntlm.flags\",0);\n\tString domain=props.getProperty(\"mail.\" + name + \".auth.ntlm.domain\",\"\");\n\tNtlm ntlm=new Ntlm(domain,getLocalHost(),u,p,debug ? out : null);\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE NTLM command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE NTLM\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tboolean first=true;\n\t\twhile(!done){\n\t\t\ttry {\n\t\t\t\tr=readResponse();\n\t\t\t\tif(r.isContinuation()){\n\t\t\t\t\tString s;\n\t\t\t\t\tif(first){\n\t\t\t\t\t\ts=ntlm.generateType1Msg(flags);\n\t\t\t\t\t\tfirst=false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts=ntlm.generateType3Msg(r.getRest());\n\t\t\t\t\t}\n\t\t\t\t\tos.write(ASCIIUtility.getBytes(s));\n\t\t\t\t\tos.write(CRLF);\n\t\t\t\t\tos.flush();\n\t\t\t\t} else if(r.isTagged() && r.getTag().equals(tag))\n\t\t\t\t\tdone=true;\n\t\t\t\telse if(r.isBYE())\n\t\t\t\t\tdone=true;\n\t\t\t\telse \n\t\t\t\t\tv.addElement(r);\n\t\t\t} catch (Exception ioex){\n\t\t\t\tr=Response.byeResponse(ioex);\n\t\t\t\tdone=true;\n\t\t\t} \n\t\t}\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE NTLM command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}","public synchronized void authplain(String authzid,String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE PLAIN command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE PLAIN\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tByteArrayOutputStream bos=new ByteArrayOutputStream();\n\t\tOutputStream b64os=new BASE64EncoderStream(bos,Integer.MAX_VALUE);\n\t\twhile(!done){\n\t\t\ttry {\n\t\t\t\tr=readResponse();\n\t\t\t\tif(r.isContinuation()){\n\t\t\t\t\tfinal String nullByte=\"\\0\";\n\t\t\t\t\tString s=(authzid == null ? \"\" : authzid) + nullByte + u+ nullByte+ p;\n\t\t\t\t\tb64os.write(ASCIIUtility.getBytes(s));\n\t\t\t\t\tb64os.flush();\n\t\t\t\t\tbos.write(CRLF);\n\t\t\t\t\tos.write(bos.toByteArray());\n\t\t\t\t\tos.flush();\n\t\t\t\t\tbos.reset();\n\t\t\t\t} else if(r.isTagged() && r.getTag().equals(tag))\n\t\t\t\t\tdone=true;\n\t\t\t\telse if(r.isBYE())\n\t\t\t\t\tdone=true;\n\t\t\t\telse \n\t\t\t\t\tv.addElement(r);\n\t\t\t} catch (Exception ioex){\n\t\t\t\tr=Response.byeResponse(ioex);\n\t\t\t\tdone=true;\n\t\t\t} \n\t\t}\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE PLAIN command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}"],"method":0,"correctSolution":0,"doc":"Performs the actual protocol-specific connection attempt. Will attempt to connect to \"localhost\" if the host was null. Unless mail.smtp.ehlo is set to false, we'll try to identify ourselves using the ESMTP command EHLO. If mail.smtp.auth is set to true, we insist on having a username and password, and will try to authenticate ourselves if the server supports the AUTH extension (RFC 2554).","type":"T1"},"3":{"codes":["public static boolean check(List constraints,Authenticator authenticator,UserRealm realm,String pathInContext,HttpRequest request,HttpResponse response) throws HttpException, IOException {\n\tint dataConstraint=DC_NONE;\n\tObject roles=null;\n\tboolean unauthenticated=false;\n\tif(dataConstraint > DC_NONE){\n\t\tHttpConnection connection=request.getHttpConnection();\n\t\tHttpListener listener=connection.getListener();\n\t\tswitch (dataConstraint){\n\t\tcase SecurityConstraint.DC_INTEGRAL: \n\t\t\tif(listener.isIntegral(connection))\n\t\t\t\tbreak;\n\t\t\tif(listener.getIntegralPort() > 0){\n\t\t\t\tString url=listener.getIntegralScheme() + \"://\" + request.getHost()+ \":\"+ listener.getIntegralPort()+ request.getPath();\n\t\t\t\tif(request.getQuery() != null)\n\t\t\t\t\turl+=\"?\" + request.getQuery();\n\t\t\t\tresponse.setContentLength(0);\n\t\t\t\tresponse.sendRedirect(url);\n\t\t\t} else \n\t\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t\treturn false;\n\t\tcase SecurityConstraint.DC_CONFIDENTIAL: \n\t\t\tif(listener.isConfidential(connection))\n\t\t\t\tbreak;\n\t\t\tif(listener.getConfidentialPort() > 0){\n\t\t\t\tString url=listener.getConfidentialScheme() + \"://\" + request.getHost()+ \":\"+ listener.getConfidentialPort()+ request.getPath();\n\t\t\t\tif(request.getQuery() != null)\n\t\t\t\t\turl+=\"?\" + request.getQuery();\n\t\t\t\tresponse.setContentLength(0);\n\t\t\t\tresponse.sendRedirect(url);\n\t\t\t} else \n\t\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(!unauthenticated && roles != null){\n\t\tif(realm == null){\n\t\t\tHttpContext.sendContextError(response,HttpResponse.__500_Internal_Server_Error,\"Configuration error\");\n\t\t\treturn false;\n\t\t}\n\t\tPrincipal user=null;\n\t\tif(request.getAuthType() != null && request.getAuthUser() != null){\n\t\t\tuser=request.getUserPrincipal();\n\t\t\tif(user == null)\n\t\t\t\tuser=realm.authenticate(request.getAuthUser(),null,request);\n\t\t\tif(user == null && authenticator != null)\n\t\t\t\tuser=authenticator.authenticate(realm,pathInContext,request,response);\n\t\t} else \n\t\tif(user == null)\n\t\t\treturn false;\n\t\telse if(user == __NOBODY)\n\t\t\treturn true;\n\t} else {\n\t}\n\treturn true;\n}","public void handle(HttpRequest request,HttpResponse response) throws HttpException, IOException {\n\tif(!isStarted() || _gracefulStop)\n\t\treturn;\n\tString pathInContext=URI.canonicalPath(request.getPath());\n\tif(_contextPath.length() > 1)\n\t\tpathInContext=pathInContext.substring(_contextPath.length());\n\tif(_redirectNullPath && (pathInContext == null || pathInContext.length() == 0)){\n\t\tStringBuffer buf=request.getRequestURL();\n\t\tbuf.append(\"/\");\n\t\tString q=request.getQuery();\n\t\tif(q != null && q.length() != 0)\n\t\t\tbuf.append(\"?\" + q);\n\t\tresponse.sendRedirect(buf.toString());\n\t\tif(log.isDebugEnabled())\n\t\t\tlog.debug(this + \" consumed all of path \" + request.getPath()+ \", redirect to \"+ buf.toString());\n\t\treturn;\n\t}\n\tString pathParams=null;\n\tint semi=pathInContext.lastIndexOf(';');\n\tif(semi >= 0){\n\t\tint pl=pathInContext.length() - semi;\n\t\tString ep=request.getEncodedPath();\n\t}\n\ttry {\n\t\thandle(pathInContext,pathParams,request,response);\n\t} finally {\n\t\tif(_userRealm != null && request.hasUserPrincipal())\n\t\t\t_userRealm.disassociate(request.getUserPrincipal());\n\t} \n}","public void handle(String pathInContext,String pathParams,HttpRequest httpRequest,HttpResponse httpResponse) throws IOException {\n\tif(!isStarted())\n\t\treturn;\n\tServletHttpRequest request=(ServletHttpRequest)httpRequest.getWrapper();\n\tServletHttpResponse response=(ServletHttpResponse)httpResponse.getWrapper();\n\tMap.Entry servlet=getHolderEntry(pathInContext);\n\tServletHolder servletHolder=servlet == null ? null : (ServletHolder)servlet.getValue();\n\tif(log.isDebugEnabled())\n\t\tlog.debug(\"servlet=\" + servlet);\n\ttry {\n\t\trequest.setRequestedSessionId(pathParams);\n\t\tHttpSession session=request.getSession(false);\n\t\tif(session != null)\n\t\t\t((SessionManager.Session)session).access();\n\t\tif(log.isDebugEnabled())\n\t\t\tlog.debug(\"session=\" + session);\n\t\tif(servletHolder != null)\n\t\t\tdispatch(pathInContext,request,response,servletHolder,Dispatcher.__REQUEST);\n\t} catch (Exception e){\n\t\tlog.debug(LogSupport.EXCEPTION,e);\n\t\tThrowable th=e;\n\t\twhile(th instanceof ServletException){\n\t\t\tlog.warn(LogSupport.EXCEPTION,th);\n\t\t\tThrowable cause=((ServletException)th).getRootCause();\n\t\t\tif(cause == th || cause == null)\n\t\t\t\tbreak;\n\t\t\tth=cause;\n\t\t}\n\t\tif(th instanceof HttpException)\n\t\t\tthrow (HttpException)th;\n\t\thttpResponse.getHttpConnection().forceClose();\n\t\tif(!httpResponse.isCommitted()){\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION_TYPE,th.getClass());\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION,th);\n\t\t} else if(log.isDebugEnabled())\n\t\t\tlog.debug(\"Response already committed for handling \" + th);\n\t} catch (Error e){\n\t\tlog.warn(\"Error for \" + httpRequest.getURI(),e);\n\t\tif(log.isDebugEnabled())\n\t\t\tlog.debug(httpRequest);\n\t\thttpResponse.getHttpConnection().forceClose();\n\t\tif(!httpResponse.isCommitted()){\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION,e);\n\t\t\tresponse.sendError(HttpResponse.__500_Internal_Server_Error,e.getMessage());\n\t\t} else if(log.isDebugEnabled())\n\t\t\tlog.debug(\"Response already committed for handling \",e);\n\t} finally {\n\t} \n}","XObject execute(final XPathContext xpathContext,final int contextNode,final PrefixResolver namespaceContext) throws TransformerException {\n\txpathContext.pushNamespaceContext(namespaceContext);\n\txpathContext.pushCurrentNodeAndExpression(contextNode,contextNode);\n\tXObject xobj=null;\n\ttry {\n\t\txobj=mainExp_.execute(xpathContext);\n\t} catch (final TransformerException te){\n\t\tte.setLocator(mainExp_);\n\t\tfinal ErrorListener el=xpathContext.getErrorListener();\n\t} catch (Exception e){\n\t\tString msg=e.getMessage();\n\t\tfinal TransformerException te=new TransformerException(msg,mainExp_,e);\n\t\tfinal ErrorListener el=xpathContext.getErrorListener();\n\t} finally {\n\t\txpathContext.popNamespaceContext();\n\t\txpathContext.popCurrentNodeAndExpression();\n\t} \n\treturn xobj;\n}","public HttpContext service(HttpRequest request,HttpResponse response) throws IOException, HttpException {\n\tString host=request.getHost();\n\tif(_requestsPerGC > 0 && _gcRequests++ > _requestsPerGC){\n\t\t_gcRequests=0;\n\t\tSystem.gc();\n\t}\n\twhile(true){\n\t\tPathMap contextMap=(PathMap)_virtualHostMap.get(host);\n\t\tif(host == null)\n\t\t\tbreak;\n\t}\n\tsynchronized (this){\n\t\tif(_notFoundContext == null){\n\t\t\t_notFoundContext=new HttpContext();\n\t\t\t_notFoundContext.setContextPath(\"/\");\n\t\t\t_notFoundContext.setHttpServer(this);\n\t\t\ttry {\n\t\t\t\t_notFoundContext.addHandler((NotFoundHandler)Class.forName(\"org.openqa.jetty.http.handler.RootNotFoundHandler\").newInstance());\n\t\t\t} catch (Exception e){\n\t\t\t\t_notFoundContext.addHandler(new NotFoundHandler());\n\t\t\t} \n\t\t\taddComponent(_notFoundContext);\n\t\t}\n\t\t_notFoundContext.handle(request,response);\n\t\tif(!request.isHandled())\n\t\t\tresponse.sendError(HttpResponse.__404_Not_Found);\n\t\treturn _notFoundContext;\n\t}\n}"],"method":1,"correctSolution":4,"doc":"Process a request. Handle the request by passing it to the HttpHandler contained in the mapped HttpContexts. The requests host and path are used to select a list of HttpContexts. Each HttpHandler in these context is offered the request in turn, until the request is handled. If no handler handles the request, 404 Not Found is returned.","type":"T1"},"4":{"codes":["public Resource getResource(String pathInContext) throws IOException {\n\tif(_resourceBase == null)\n\t\treturn null;\n\tResource resource=null;\n\tsynchronized (_cache){\n\t\tCachedResource cached=(CachedResource)_cache.get(pathInContext);\n\t\tif(resource.getAlias() != null){\n\t\t\tlog.warn(\"Alias request of '\" + resource.getAlias() + \"' for '\"+ resource+ \"'\");\n\t\t\treturn null;\n\t\t}\n\t\tlong len=resource.length();\n\t\tif(resource.exists()){\n\t\t\tif(resource.isDirectory()){\n\t\t\t\tif(resource.list() != null)\n\t\t\t\telse \n\t\t\t\t\tlen=0;\n\t\t\t}\n\t\t\tif(len > 0 && len < _maxCachedFileSize && len < _maxCacheSize){\n\t\t\t\tint needed=_maxCacheSize - (int)len;\n\t\t\t\twhile(_cacheSize > needed)\n\t\t\t\t\t_leastRecentlyUsed.invalidate();\n\n\t\t\t\tcached=resource.cache();\n\t\t\t\tnew CachedMetaData(cached,pathInContext);\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\t}\n\treturn resource;\n}","public static JSONObject loadJSON(String resource){\n\tInputStream in=Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);\n\tif(in == null){\n\t\ttry {\n\t\t\tin=new FileInputStream(resource);\n\t\t} catch (FileNotFoundException e){\n\t\t} \n\t}\n\tStringBuilder b=new StringBuilder();\n\tInputStreamReader inputreader=new InputStreamReader(in);\n\tBufferedReader buffreader=new BufferedReader(inputreader);\n\tString line;\n\ttry {\n\t\twhile((line=buffreader.readLine()) != null){\n\t\t}\n\t} catch (IOException e){\n\t} \n\tString json=b.toString();\n\tJSONObject o;\n\treturn o;\n}","public void loadFromGridYml(String resource){\n\tInputStream in=Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);\n\tif(in == null){\n\t\ttry {\n\t\t\tin=new FileInputStream(resource);\n\t\t} catch (FileNotFoundException e){\n\t\t} \n\t}\n\tYaml yaml=new Yaml();\n\tMap<String,Object> hub=(Map<String,Object>)config.get(\"hub\");\n\tList<Map<String,String>> environments=(List<Map<String,String>>)hub.get(\"environments\");\n\tInteger p=(Integer)hub.get(\"port\");\n\tfor (Map<String,String> environment : environments){\n\t\tgetGrid1Mapping().put(environment.get(\"name\"),environment.get(\"browser\"));\n\t}\n\tInteger poll=(Integer)hub.get(\"remoteControlPollingIntervalInSeconds\");\n\tif(poll != null){\n\t\tallParams.put(RegistrationRequest.NODE_POLLING,poll.intValue() * 1000);\n\t\tcleanupCycle=poll.intValue() * 1000;\n\t}\n\tInteger timeout=(Integer)hub.get(\"sessionMaxIdleTimeInSeconds\");\n\tInteger port=(Integer)hub.get(RegistrationRequest.PORT);\n\tInteger newSessionWait=(Integer)hub.get(\"newSessionMaxWaitTimeInSeconds\");\n\tallParams.put(RegistrationRequest.MAX_SESSION,1);\n}","public static Resource newResource(String resource) throws MalformedURLException, IOException {\n\tURL url=null;\n\ttry {\n\t\turl=new URL(resource);\n\t} catch (MalformedURLException e){\n\t\tif(!resource.startsWith(\"ftp:\") && !resource.startsWith(\"file:\") && !resource.startsWith(\"jar:\")){\n\t\t\ttry {\n\t\t\t\tFile file=new File(resource).getCanonicalFile();\n\t\t\t\turl=file.toURI().toURL();\n\t\t\t\tURLConnection connection=url.openConnection();\n\t\t\t\tFileResource fileResource=new FileResource(url,connection,file);\n\t\t\t\treturn fileResource;\n\t\t\t} catch (Exception e2){\n\t\t\t} \n\t\t} else {\n\t\t\tlog.warn(\"Bad Resource: \" + resource);\n\t\t\tthrow e;\n\t\t}\n\t} \n\treturn newResource(url);\n}","public String getListHTML(String base,boolean parent) throws IOException {\n\tif(!isDirectory())\n\t\treturn null;\n\tString[] ls=list();\n\tif(ls == null)\n\t\treturn null;\n\tArrays.sort(ls);\n\tString title=\"Directory: \" + URI.decodePath(base);\n\tStringBuffer buf=new StringBuffer(4096);\n\tbuf.append(\"<HTML><HEAD><TITLE>\");\n\tbuf.append(\"<\/TITLE><\/HEAD><BODY>\\n<H1>\");\n\tif(parent){\n\t\tbuf.append(URI.encodePath(URI.addPaths(base,\"../\")));\n\t}\n\tDateFormat dfmt=DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.MEDIUM);\n\tfor (int i=0; i < ls.length; i++){\n\t\tString encoded=URI.encodePath(ls[i]);\n\t\tResource item=addPath(encoded);\n\t\tString path=URI.addPaths(base,encoded);\n\t}\n\tbuf.append(\"<\/BODY><\/HTML>\\n\");\n\treturn buf.toString();\n}"],"method":2,"correctSolution":0,"doc":"Get a resource from the context. Cached Resources are returned if the resource fits within the LRU cache.  Directories may have CachedResources returned, but the caller must use the CachedResource.setCachedData method to set the formatted directory content.","type":"T1"},"5":{"codes":["protected void scandir(File dir,String vpath,boolean fast){\n\tif(dir == null){\n\t\tthrow new BuildException(\"dir must not be null.\");\n\t} else if(!dir.exists()){\n\t\tthrow new BuildException(dir + \" doesn't exists.\");\n\t} else if(!dir.isDirectory()){\n\t\tthrow new BuildException(dir + \" is not a directory.\");\n\t}\n\tif(fast && hasBeenScanned(vpath)){\n\t\treturn;\n\t}\n\tsetState(\"Scan directory: %s\",vpath);\n\tString[] newfiles=dir.list();\n\tif(newfiles == null){\n\t\tthrow new BuildException(\"IO error scanning directory \" + dir.getAbsolutePath());\n\t}\n\tif(!followSymlinks){\n\t\tList<String> noLinks=new ArrayList<String>();\n\t\tfor (int i=0; i < newfiles.length; i++){\n\t\t\ttry {\n\t\t\t\tif(FILE_UTILS.isSymbolicLink(dir,newfiles[i])){\n\t\t\t\t\tString name=vpath + newfiles[i];\n\t\t\t\t\tFile file=new File(dir,newfiles[i]);\n\t\t\t\t\t(file.isDirectory() ? dirsExcluded : filesExcluded).add(name);\n\t\t\t\t} else {\n\t\t\t\t\tnoLinks.add(newfiles[i]);\n\t\t\t\t}\n\t\t\t} catch (IOException ioe){\n\t\t\t\tString msg=\"IOException caught while checking \" + \"for links, couldn't get canonical path!\";\n\t\t\t\tSystem.err.println(msg);\n\t\t\t\tnoLinks.add(newfiles[i]);\n\t\t\t} \n\t\t}\n\t\tnewfiles=noLinks.toArray(new String[noLinks.size()]);\n\t}\n\tfor (int i=0; i < newfiles.length; i++){\n\t\tString name=vpath + newfiles[i];\n\t\tFile file=new File(dir,newfiles[i]);\n\t\tif(file.isDirectory()){\n\t\t\tif(isIncluded(name)){\n\t\t\t\taccountForIncludedDir(name,file,fast);\n\t\t\t} else {\n\t\t\t\teverythingIncluded=false;\n\t\t\t\tdirsNotIncluded.add(name);\n\t\t\t\tif(fast && couldHoldIncluded(name) && !contentsExcluded(name)){\n\t\t\t\t\tscandir(file,name + File.separator,fast);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!fast){\n\t\t\t\tscandir(file,name + File.separator,fast);\n\t\t\t}\n\t\t} else if(file.isFile()){\n\t\t\tif(isIncluded(name)){\n\t\t\t\taccountForIncludedFile(name,file,dir);\n\t\t\t} else {\n\t\t\t\teverythingIncluded=false;\n\t\t\t\tfilesNotIncluded.add(name);\n\t\t\t}\n\t\t}\n\t}\n}","public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tString scopedPath=diffUnit.getScopedPath();\n\tfor (Iterator<Pattern> it=excludes.iterator(); it.hasNext(); ){\n\t\tPattern pattern=it.next();\n\t\tif(pattern.matcher(scopedPath).matches()){\n\t\t\tlog.debug(\"Skipping unit due to exclude: \" + scopedPath);\n\t\t\treturn null;\n\t\t}\n\t}\n\tlog.debug(\"Processing unit \" + scopedPath);\n\tboolean leftExists=diffUnit.leftExists();\n\tboolean rightExists=diffUnit.rightExists();\n\tboolean leftIsDir=diffUnit.leftIsDir();\n\tboolean rightIsDir=diffUnit.rightIsDir();\n\tif(leftExists && !rightExists){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Exists in left only\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(rightExists && !leftExists){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Exists in right only\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(leftIsDir != rightIsDir){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Dir/File mismatch\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(!leftIsDir && !rightIsDir){\n\t\tboolean foundHandler=false;\n\t\tfor (Iterator<Map.Entry<String,DiffUnitProcessor>> it=fileHandlers.entrySet().iterator(); it.hasNext(); ){\n\t\t\tMap.Entry<String,DiffUnitProcessor> entry=it.next();\n\t\t\tString regex=entry.getKey();\n\t\t\tif(scopedPath.matches(regex)){\n\t\t\t\tDiffUnitProcessor fileHandler=entry.getValue();\n\t\t\t\tDiffScope childScope=fileHandler.processDiffUnit(diffUnit,processor);\n\t\t\t\tif(childScope != null){\n\t\t\t\t\tchildScope.scan(this,processor);\n\t\t\t\t}\n\t\t\t\tfoundHandler=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!foundHandler){\n\t\t\tlog.error(\"No applicable handler found for path: \" + scopedPath);\n\t\t}\n\t}\n\treturn null;\n}","protected void slowScan(){\n\tsynchronized (slowScanLock){\n\t\tif(haveSlowResults){\n\t\t\treturn;\n\t\t}\n\t\tif(slowScanning){\n\t\t\twhile(slowScanning){\n\t\t\t\ttry {\n\t\t\t\t\tslowScanLock.wait();\n\t\t\t\t} catch (InterruptedException e){\n\t\t\t\t} \n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tslowScanning=true;\n\t}\n\ttry {\n\t\tsynchronized (this){\n\t\t\tfor (String excluded : dirsExcluded){\n\t\t\t\tif(!couldHoldIncluded(excluded)){\n\t\t\t\t\tscandir(new File(basedir,excluded),excluded + File.separator,false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (String notIncluded : dirsNotIncluded){\n\t\t\t\tif(!couldHoldIncluded(notIncluded)){\n\t\t\t\t\tscandir(new File(basedir,notIncluded),notIncluded + File.separator,false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclearCaches();\n\t\t}\n\t} finally {\n\t\tsynchronized (slowScanLock){\n\t\t\thaveSlowResults=true;\n\t\t\tslowScanning=false;\n\t\t\tslowScanLock.notifyAll();\n\t\t}\n\t} \n}","private void checkIncludePatterns(){\n\tHashtable newroots=new Hashtable();\n\tfor (String include : includes){\n\t\tnewroots.put(SelectorUtils.rtrimWildcardTokens(include),include);\n\t}\n\tif(newroots.containsKey(\"\")){\n\t\tscandir(basedir,\"\",true);\n\t} else {\n\t\tEnumeration enum2=newroots.keys();\n\t\tFile canonBase=null;\n\t\ttry {\n\t\t\tcanonBase=basedir.getCanonicalFile();\n\t\t} catch (IOException ex){\n\t\t\tthrow new BuildException(ex);\n\t\t} \n\t\twhile(enum2.hasMoreElements()){\n\t\t\tString currentelement=(String)enum2.nextElement();\n\t\t\tString originalpattern=(String)newroots.get(currentelement);\n\t\t\tFile myfile=new File(basedir,currentelement);\n\t\t\tif(myfile.exists()){\n\t\t\t\ttry {\n\t\t\t\t\tFile canonFile=myfile.getCanonicalFile();\n\t\t\t\t\tString path=FILE_UTILS.removeLeadingPath(canonBase,canonFile);\n\t\t\t\t\tif(!path.equals(currentelement) || ON_VMS){\n\t\t\t\t\t\tmyfile=findFile(basedir,currentelement,true);\n\t\t\t\t\t\tif(myfile != null){\n\t\t\t\t\t\t\tcurrentelement=FILE_UTILS.removeLeadingPath(basedir,myfile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException ex){\n\t\t\t\t\tthrow new BuildException(ex);\n\t\t\t\t} \n\t\t\t}\n\t\t\tif((myfile == null || !myfile.exists()) && !isCaseSensitive()){\n\t\t\t\tFile f=findFile(basedir,currentelement,false);\n\t\t\t\tif(f != null && f.exists()){\n\t\t\t\t\tcurrentelement=FILE_UTILS.removeLeadingPath(basedir,f);\n\t\t\t\t\tmyfile=f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(myfile != null && myfile.exists()){\n\t\t\t\tif(!followSymlinks && isSymlink(basedir,currentelement)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(myfile.isDirectory()){\n\t\t\t\t\tif(isIncluded(currentelement) && currentelement.length() > 0){\n\t\t\t\t\t\taccountForIncludedDir(currentelement,myfile,true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(currentelement.length() > 0){\n\t\t\t\t\t\t\tif(currentelement.charAt(currentelement.length() - 1) != File.separatorChar){\n\t\t\t\t\t\t\t\tcurrentelement=currentelement + File.separatorChar;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscandir(myfile,currentelement,true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tboolean included=isCaseSensitive() ? originalpattern.equals(currentelement) : originalpattern.equalsIgnoreCase(currentelement);\n\t\t\t\t\tif(included){\n\t\t\t\t\t\taccountForIncludedFile(currentelement,myfile,null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","public void scan() throws IllegalStateException {\n\tsynchronized (scanLock){\n\t\tif(scanning){\n\t\t\twhile(scanning){\n\t\t\t\ttry {\n\t\t\t\t\tscanLock.wait();\n\t\t\t\t} catch (InterruptedException e){\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t}\n\t\t\tif(illegal != null){\n\t\t\t\tthrow illegal;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tscanning=true;\n\t}\n\ttry {\n\t\tsynchronized (this){\n\t\t\tillegal=null;\n\t\t\tclearResults();\n\t\t\tif(basedir == null){\n\t\t\t\tillegal=new IllegalStateException(\"No basedir set\");\n\t\t\t} else {\n\t\t\t\tif(!basedir.exists()){\n\t\t\t\t\tillegal=new IllegalStateException(\"basedir \" + basedir + \" does not exist\");\n\t\t\t\t}\n\t\t\t\tif(!basedir.isDirectory()){\n\t\t\t\t\tillegal=new IllegalStateException(\"basedir \" + basedir + \" is not a directory\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(illegal != null){\n\t\t\t\tthrow illegal;\n\t\t\t}\n\t\t\tif(isIncluded(\"\")){\n\t\t\t\tif(!isExcluded(\"\")){\n\t\t\t\t\tif(isSelected(\"\",basedir)){\n\t\t\t\t\t\tdirsIncluded.add(\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdirsDeselected.add(\"\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdirsExcluded.add(\"\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdirsNotIncluded.add(\"\");\n\t\t\t}\n\t\t\tcheckIncludePatterns();\n\t\t\tclearCaches();\n\t\t}\n\t} finally {\n\t\tsynchronized (scanLock){\n\t\t\tscanning=false;\n\t\t\tscanLock.notifyAll();\n\t\t}\n\t} \n}"],"method":0,"correctSolution":0,"doc":"Scan the given directory for files and directories. Found files and directories are placed in their respective collections, based on the matching of includes, excludes, and the selectors.  When a directory is found, it is scanned recursively.","type":"T1"},"6":{"codes":["protected void doSAX(Node node) throws ParserException, SAXException {\n\tTag tag;\n\tTag end;\n\tif(node instanceof Remark){\n\t\tString text=mParser.getLexer().getPage().getText(node.getStartPosition(),node.getEndPosition());\n\t\tmContentHandler.ignorableWhitespace(text.toCharArray(),0,text.length());\n\t} else if(node instanceof Text){\n\t\tString text=mParser.getLexer().getPage().getText(node.getStartPosition(),node.getEndPosition());\n\t\ttext=Translate.decode(text);\n\t\tmContentHandler.characters(text.toCharArray(),0,text.length());\n\t} else if(node instanceof Tag){\n\t\ttag=(Tag)node;\n\t\tif(mNameSpacePrefixes)\n\t\t\tmParts[2]=tag.getTagName();\n\t\telse if(mNameSpaces)\n\t\t\tmParts[2]=\"\";\n\t\telse \n\t\t\tmParts[2]=tag.getTagName();\n\t\tNodeList children=tag.getChildren();\n\t\tif(null != children)\n\t\t\tfor (int i=0; i < children.size(); i++)\n\t\t\t\tdoSAX(children.elementAt(i));\n\t}\n}","public static void main(String[] argv) throws IOException, SAXException {\n\tint optind=getopts(options,argv);\n\tif(hasOption(options,\"--version\")){\n\t\tSystem.err.println(\"TagSoup version 1.2.1\");\n\t\treturn;\n\t}\n\tif(argv.length == optind){\n\t\tprocess(\"\",System.out);\n\t} else if(hasOption(options,\"--files\")){\n\t\tfor (int i=optind; i < argv.length; i++){\n\t\t\tString src=argv[i];\n\t\t\tString dst;\n\t\t\tint j=src.lastIndexOf('.');\n\t\t\tSystem.err.println(\"src: \" + src + \" dst: \"+ dst);\n\t\t}\n\t} else {\n\t}\n}","protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tmParser.setURL(url);\n\t\ttry {\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t\tmParser.reset();\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t} catch (ParserException pe){\n\t\tString message;\n\t\tmessage=pe.getMessage();\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}","protected Node parsePI(int start) throws ParserException {\n\tboolean done;\n\tchar ch;\n\tint state;\n\tVector attributes;\n\tint code;\n\tdone=false;\n\tstate=0;\n\tcode=0;\n\tattributes=new Vector();\n\twhile(!done){\n\t\tch=mPage.getCharacter(mCursor);\n\t\tswitch (state){\n\t\tcase 0: \n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tswitch (ch){\n\t\t\tcase '>': \n\t\t\t\tstate=3;\n\t\t\t\tdone=true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\"': \n\t\t\tswitch (ch){\n\t\t\tcase Page.EOF: \n\t\t\t\tdone=true;\n\t\t\t\tbreak;\n\t\t\tcase '\"': \n\t\t\t\tstate=1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\'': \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Somehow managed to get into invalid state  \" + state);\n\t\t}\n\t}\n\treturn (makeTag(start,mCursor.getPosition(),attributes));\n}","public void run(){\n\tURL link;\n\tint original;\n\tint index;\n\tString href;\n\tURL[][] urls;\n\twhile(true){\n\t\ttry {\n\t\t\tif(null != link){\n\t\t\t\turls=getImageLinks(link);\n\t\t\t\tfetch(urls[0]);\n\t\t\t\tappend(filter(urls[1]));\n\t\t\t} else \n\t\t\t\tThread.sleep(100);\n\t\t\tif(!mActive)\n\t\t} catch (Throwable t){\n\t\t\tt.printStackTrace();\n\t\t} \n\t}\n}"],"method":1,"correctSolution":4,"doc":"The main processing loop. Pull suspect URLs off the queue one at a time, fetch and parse it, request images and enqueue further links.","type":"T1"},"7":{"codeB":"@Override protected Socket _openDataConnection_(int command,String arg) throws IOException {\n\tSocket socket=super._openDataConnection_(command,arg);\n\t_prepareDataSocket_(socket);\n\tif(socket instanceof SSLSocket){\n\t\tSSLSocket sslSocket=(SSLSocket)socket;\n\t\tsslSocket.setUseClientMode(isClientMode);\n\t\tsslSocket.setEnableSessionCreation(isCreation);\n\t\tif(!isClientMode){\n\t\t\tsslSocket.setNeedClientAuth(isNeedClientAuth);\n\t\t\tsslSocket.setWantClientAuth(isWantClientAuth);\n\t\t}\n\t}\n\treturn socket;\n}","codeA":"protected Socket _openDataConnection_(String command,String arg) throws IOException {\n\tfinal boolean isInet6Address=getRemoteAddress() instanceof Inet6Address;\n\tSocket socket;\n\tif(__dataConnectionMode == ACTIVE_LOCAL_DATA_CONNECTION_MODE){\n\t\tServerSocket server=_serverSocketFactory_.createServerSocket(getActivePort(),1,getHostAddress());\n\t\ttry {\n\t\t\tif(isInet6Address){\n\t\t\t} else {\n\t\t\t\tif(!FTPReply.isPositiveCompletion(port(getReportHostAddress(),server.getLocalPort()))){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(__dataTimeout >= 0){\n\t\t\t\tserver.setSoTimeout(__dataTimeout);\n\t\t\t}\n\t\t\tsocket=server.accept();\n\t\t} finally {\n\t\t\tserver.close();\n\t\t} \n\t} else {\n\t\tboolean attemptEPSV=isUseEPSVwithIPv4() || isInet6Address;\n\t\tif(attemptEPSV && epsv() == FTPReply.ENTERING_EPSV_MODE){\n\t\t\t_parseExtendedPassiveModeReply(_replyLines.get(0));\n\t\t} else {\n\t\t\tif(isInet6Address){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(pasv() != FTPReply.ENTERING_PASSIVE_MODE){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t_parsePassiveModeReply(_replyLines.get(0));\n\t\t}\n\t\tsocket=_socketFactory_.createSocket();\n\t\tsocket.connect(new InetSocketAddress(__passiveHost,__passivePort),connectTimeout);\n\t}\n\treturn socket;\n}","method":2,"docB":"Returns a socket of the data connection. Wrapped as an SSLSocket, which carries out handshake processing.","docA":"Establishes a data connection with the FTP server, returning a Socket for the connection if successful.  If a restart offset has been set with setRestartOffset(long), a REST command is issued to the server with the offset as an argument before establishing the data connection.  Active mode connections also cause a local PORT command to be issued.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"8":{"codeB":"@Override protected char[] escape(int cp){\n\tif(cp < safeOctets.length && safeOctets[cp]){\n\t\treturn null;\n\t} else if(cp == ' ' && plusForSpace){\n\t\treturn URI_ESCAPED_SPACE;\n\t} else if(cp <= 0x7F){\n\t\tchar[] dest=new char[3];\n\t\tdest[0]='%';\n\t\tdest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tdest[1]=UPPER_HEX_DIGITS[cp >>> 4];\n\t\treturn dest;\n\t} else if(cp <= 0x7ff){\n\t\tchar[] dest=new char[6];\n\t\tdest[0]='%';\n\t\tdest[3]='%';\n\t\tdest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[1]=UPPER_HEX_DIGITS[0xC | cp];\n\t\treturn dest;\n\t} else if(cp <= 0xffff){\n\t\tchar[] dest=new char[9];\n\t\tdest[0]='%';\n\t\tdest[1]='E';\n\t\tdest[3]='%';\n\t\tdest[6]='%';\n\t\tdest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[2]=UPPER_HEX_DIGITS[cp];\n\t\treturn dest;\n\t} else if(cp <= 0x10ffff){\n\t\tchar[] dest=new char[12];\n\t\tdest[0]='%';\n\t\tdest[1]='F';\n\t\tdest[3]='%';\n\t\tdest[6]='%';\n\t\tdest[9]='%';\n\t\tdest[11]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[10]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[2]=UPPER_HEX_DIGITS[cp & 0x7];\n\t\treturn dest;\n\t} else {\n\t\tthrow new IllegalArgumentException(\"Invalid unicode character value \" + cp);\n\t}\n}","codeA":"protected final String escapeSlow(String s,int index){\n\tint end=s.length();\n\tchar[] dest=DEST_TL.get();\n\tint destIndex=0;\n\tint unescapedChunkStart=0;\n\twhile(index < end){\n\t\tint cp=codePointAt(s,index,end);\n\t\tif(cp < 0){\n\t\t\tthrow new IllegalArgumentException(\"Trailing high surrogate at end of input\");\n\t\t}\n\t\tchar[] escaped=escape(cp);\n\t\tif(escaped != null){\n\t\t\tint charsSkipped=index - unescapedChunkStart;\n\t\t\tint sizeNeeded=destIndex + charsSkipped + escaped.length;\n\t\t\tif(dest.length < sizeNeeded){\n\t\t\t\tint destLength=sizeNeeded + (end - index) + DEST_PAD;\n\t\t\t\tdest=growBuffer(dest,destIndex,destLength);\n\t\t\t}\n\t\t\tif(charsSkipped > 0){\n\t\t\t\ts.getChars(unescapedChunkStart,index,dest,destIndex);\n\t\t\t\tdestIndex+=charsSkipped;\n\t\t\t}\n\t\t\tif(escaped.length > 0){\n\t\t\t\tSystem.arraycopy(escaped,0,dest,destIndex,escaped.length);\n\t\t\t\tdestIndex+=escaped.length;\n\t\t\t}\n\t\t}\n\t\tunescapedChunkStart=index + (Character.isSupplementaryCodePoint(cp) ? 2 : 1);\n\t\tindex=nextEscapeIndex(s,unescapedChunkStart,end);\n\t}\n\tint charsSkipped=end - unescapedChunkStart;\n\tif(charsSkipped > 0){\n\t\tint endIndex=destIndex + charsSkipped;\n\t\tif(dest.length < endIndex){\n\t\t\tdest=growBuffer(dest,destIndex,endIndex);\n\t\t}\n\t\ts.getChars(unescapedChunkStart,end,dest,destIndex);\n\t\tdestIndex=endIndex;\n\t}\n\treturn new String(dest,0,destIndex);\n}","method":0,"docB":"Escapes the given Unicode code point in UTF-8.","docA":"Returns the escaped form of a given literal string, starting at the given index. It is protected to allow subclasses to override the fastpath escaping function to inline their escaping test.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"9":{"codeB":"public void submit(String buttonName,String buttonValue){\n\tList<HtmlElement> l=new LinkedList<HtmlElement>();\n\tl.addAll(getForm().getInputsByName(buttonName));\n\tl.addAll(getForm().getButtonsByName(buttonName));\n\ttry {\n\t\tfor (int i=0; i < l.size(); i++){\n\t\t\tObject o=l.get(i);\n\t\t\tif(o instanceof HtmlSubmitInput){\n\t\t\t\tHtmlSubmitInput inpt=(HtmlSubmitInput)o;\n\t\t\t\tif(inpt.getValueAttribute().equals(buttonValue)){\n\t\t\t\t\tinpt.click();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (FailingHttpStatusCodeException e){\n\t\treturn;\n\t} catch (IOException e){\n\t\tthrow new RuntimeException(\"HtmlUnit Error submitting form using submit button with name [\" + buttonName + \"] and value [\"+ buttonValue+ \"]\",e);\n\t} \n}","codeA":"public Page submit(final SubmittableElement submitElement) throws IOException {\n\tfinal HtmlPage htmlPage=(HtmlPage)getPage();\n\tfinal List<NameValuePair> parameters=getParameterListForSubmit(submitElement);\n\tfinal HttpMethod method;\n\tfinal String methodAttribute=getMethodAttribute();\n\tString actionUrl=getActionAttribute();\n\tif(HttpMethod.GET == method){\n\t\tfinal String anchor=StringUtils.substringAfter(actionUrl,\"#\");\n\t\tactionUrl=StringUtils.substringBefore(actionUrl,\"#\");\n\t\tfinal NameValuePair[] pairs=new NameValuePair[parameters.size()];\n\t\tparameters.toArray(pairs);\n\t\tfinal String queryFromFields=EncodingUtil.formUrlEncode(pairs,getPage().getPageEncoding());\n\t\tactionUrl=StringUtils.substringBefore(actionUrl,\"?\");\n\t\tfinal BrowserVersion browserVersion=getPage().getWebClient().getBrowserVersion();\n\t\tparameters.clear();\n\t}\n\tfinal URL url;\n\ttry {\n\t\tif(actionUrl.length() == 0){\n\t\t\turl=htmlPage.getWebResponse().getRequestSettings().getUrl();\n\t\t} else if(actionUrl.startsWith(\"?\")){\n\t\t\tString urlString=htmlPage.getWebResponse().getRequestSettings().getUrl().toExternalForm();\n\t\t\turl=new URL(urlString + actionUrl);\n\t\t} else {\n\t\t\turl=htmlPage.getFullyQualifiedUrl(actionUrl);\n\t\t}\n\t} catch (final MalformedURLException e){\n\t\tthrow new IllegalArgumentException(\"Not a valid url: \" + actionUrl);\n\t} \n\tfinal WebRequestSettings settings=new WebRequestSettings(url,method);\n\tsettings.setRequestParameters(parameters);\n\tsettings.setEncodingType(FormEncodingType.getInstance(getEnctypeAttribute()));\n\tsettings.setCharset(getSubmitCharset());\n\tsettings.setAdditionalHeader(\"Referer\",htmlPage.getWebResponse().getRequestSettings().getUrl().toExternalForm());\n\tfinal WebWindow webWindow=htmlPage.getEnclosingWindow();\n\treturn htmlPage.getWebClient().getPage(webWindow,htmlPage.getResolvedTarget(getTargetAttribute()),settings);\n}","method":1,"docB":"Submit this form to the server. If parameter is null, then the submission is treated as if it was triggered by JavaScript, and the onsubmit handler will not be executed.","docA":"Submit the current form with the specifed submit button.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"20":{"code_mymethod":{"r10":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","r20":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","r50%":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPDataPacket data;\n\tbeginBufferedOps();\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\t\t\t\twhile(true){\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treceived=bufferedReceive();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} catch (SocketException e){\n\t\t\t\t\t\t} catch (InterruptedIOException e){\n\t\t\t\t\t\t} catch (TFTPPacketException e){\n\t\t\t\t\t\t} \n\t\t\t\t\t}while(timeouts < __maxTimeouts)\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tif(lastBlock == block){\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\toutput.write(data.getData(),data.getDataOffset(),dataLength);\n\t\t\t\t\t\t\t\t} catch (IOException e){\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t++block;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiscardPackets();\n\t\t\t\t\t\t\t\tcontinue _receivePacket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}"},"code_native":{"r10":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tbufferedSend(sent);\n\treturn bytesRead;\n}","r20":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","r50%":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\t\t\t\twhile(true){\n\t\t\t\t\ttimeouts=0;\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tdata=(TFTPDataPacket)received;\n\t\t\t\t\t\t\tdataLength=data.getDataLength();\n\t\t\t\t\t\t\tlastBlock=data.getBlockNumber();\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Received unexpected packet type.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror=new TFTPErrorPacket(received.getAddress(),received.getPort(),TFTPErrorPacket.UNKNOWN_TID,\"Unexpected host or port.\");\n\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}"},"method":0,"code_original":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tif(mode == TFTP.ASCII_MODE){\n\t\toutput=new FromNetASCIIOutputStream(output);\n\t}\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\t\t\t\twhile(true){\n\t\t\t\t\ttimeouts=0;\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treceived=bufferedReceive();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} catch (SocketException e){\n\t\t\t\t\t\t\tif(++timeouts >= __maxTimeouts){\n\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\tthrow new IOException(\"Connection timed out.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t} catch (InterruptedIOException e){\n\t\t\t\t\t\t\tif(++timeouts >= __maxTimeouts){\n\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\tthrow new IOException(\"Connection timed out.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t} catch (TFTPPacketException e){\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Bad packet: \" + e.getMessage());\n\t\t\t\t\t\t} \n\t\t\t\t\t}while(timeouts < __maxTimeouts)\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tdata=(TFTPDataPacket)received;\n\t\t\t\t\t\t\tdataLength=data.getDataLength();\n\t\t\t\t\t\t\tlastBlock=data.getBlockNumber();\n\t\t\t\t\t\t\tif(lastBlock == block){\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\toutput.write(data.getData(),data.getDataOffset(),dataLength);\n\t\t\t\t\t\t\t\t} catch (IOException e){\n\t\t\t\t\t\t\t\t\terror=new TFTPErrorPacket(host,hostPort,TFTPErrorPacket.OUT_OF_SPACE,\"File write failed.\");\n\t\t\t\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t++block;\n\t\t\t\t\t\t\t\tif(block > 65535){\n\t\t\t\t\t\t\t\t\tblock=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak _receivePacket;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiscardPackets();\n\t\t\t\t\t\t\t\tif(lastBlock == (block == 0 ? 65535 : (block - 1))){\n\t\t\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue _receivePacket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Received unexpected packet type.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror=new TFTPErrorPacket(received.getAddress(),received.getPort(),TFTPErrorPacket.UNKNOWN_TID,\"Unexpected host or port.\");\n\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","type":"T3"},"10":{"codeB":"public static MultivaluedMap<String,String> getEntityParameters(ClientRequest request,Providers providers){\n\tObject entity=request.getEntity();\n\tString method=request.getMethod();\n\tMediaType mediaType=getMediaType(request);\n\tif(entity instanceof MultivaluedMap){\n\t\treturn (MultivaluedMap)entity;\n\t}\n\tType entityType=entity.getClass();\n\tif(entity instanceof GenericEntity){\n\t\tfinal GenericEntity generic=(GenericEntity)entity;\n\t\tentityType=generic.getType();\n\t\tentity=generic.getEntity();\n\t}\n\tfinal Class entityClass=entity.getClass();\n\tByteArrayOutputStream out=new ByteArrayOutputStream();\n\tByteArrayInputStream in=new ByteArrayInputStream(out.toByteArray());\n\tMessageBodyReader reader=providers.getMessageBodyReader(MultivaluedMap.class,MultivaluedMap.class,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE);\n\ttry {\n\t\treturn (MultivaluedMap<String,String>)reader.readFrom(MultivaluedMap.class,MultivaluedMap.class,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE,null,in);\n\t} catch (IOException ioe){\n\t} \n}","codeA":"protected SortedMap<String,SortedSet<String>> loadSignificantParametersForSignatureBaseString(HttpServletRequest request){\n\tSortedMap<String,SortedSet<String>> significantParameters=new TreeMap<String,SortedSet<String>>();\n\twhile(parameterNames.hasMoreElements()){\n\t\tString parameterName=(String)parameterNames.nextElement();\n\t\tString[] values=request.getParameterValues(parameterName);\n\t\tfor (String parameterValue : values){\n\t\t\tparameterName=oauthEncode(parameterName);\n\t\t\tparameterValue=oauthEncode(parameterValue);\n\t\t\tSortedSet<String> significantValues=significantParameters.get(parameterName);\n\t\t\tif(significantValues == null){\n\t\t\t\tsignificantValues=new TreeSet<String>();\n\t\t\t\tsignificantParameters.put(parameterName,significantValues);\n\t\t\t}\n\t\t}\n\t}\n\tMap<String,String> oauthParams=parseParameters(request);\n\toauthParams.remove(\"realm\");\n\tSet<String> parsedParams=oauthParams.keySet();\n\tfor (String parameterName : parsedParams){\n\t\tString parameterValue=oauthParams.get(parameterName);\n\t\tSortedSet<String> significantValues=significantParameters.get(parameterName);\n\t}\n\tsignificantParameters.remove(OAuthConsumerParameter.oauth_signature.toString());\n\treturn significantParameters;\n}","method":2,"docB":"Gets the parameters (name-to-value map) that are to be used to calculate the signature base string. The parameters will be encoded by oauthEncode method.","docA":"Gets the parameters from a request as a map. If the request does not have a POST method, or the media type is not x-www-form-urlencoded, then null is returned.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]}}}