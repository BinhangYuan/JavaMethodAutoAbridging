{"sampleIndex":0,"questions":{"11":{"codeB":"protected void retrieveToken(OAuthConsumer consumer,String endpointUrl,HttpParameters customOAuthParams) throws OAuthMessageSignerException, OAuthCommunicationException, OAuthNotAuthorizedException, OAuthExpectationFailedException {\n\tHttpRequest request=null;\n\tHttpResponse response=null;\n\ttry {\n\t\trequest=createRequest(endpointUrl);\n\t\tconsumer.sign(request);\n\t\tresponse=sendRequest(request);\n\t\tboolean requestHandled=false;\n\t\tHttpParameters responseParams=OAuth.decodeForm(response.getContent());\n\t\tString token=responseParams.getFirst(OAuth.OAUTH_TOKEN);\n\t\tString secret=responseParams.getFirst(OAuth.OAUTH_TOKEN_SECRET);\n\t\tresponseParams.remove(OAuth.OAUTH_TOKEN);\n\t\tresponseParams.remove(OAuth.OAUTH_TOKEN_SECRET);\n\t\tsetResponseParameters(responseParams);\n\t\tif(token == null || secret == null){\n\t\t\tthrow new OAuthExpectationFailedException(\"Request token or token secret not set in server reply. \" + \"The service provider you use is probably buggy.\");\n\t\t}\n\t\tconsumer.setTokenWithSecret(token,secret);\n\t} catch (OAuthNotAuthorizedException e){\n\t\tthrow e;\n\t} catch (OAuthExpectationFailedException e){\n\t\tthrow e;\n\t} catch (Exception e){\n\t\tthrow new OAuthCommunicationException(e);\n\t} finally {\n\t\ttry {\n\t\t\tcloseConnection(request,response);\n\t\t} catch (Exception e){\n\t\t\tthrow new OAuthCommunicationException(e);\n\t\t} \n\t} \n}","codeA":"protected OAuthConsumerToken getTokenFromProvider(ProtectedResourceDetails details,URL tokenURL,String httpMethod,OAuthConsumerToken requestToken,Map<String,String> additionalParameters){\n\tboolean isAccessToken=requestToken != null;\n\tif(!isAccessToken){\n\t\trequestToken=new OAuthConsumerToken();\n\t\trequestToken.setNonce(getNonceFactory().generateNonce());\n\t}\n\tInputStream inputStream=readResource(details,tokenURL,httpMethod,requestToken,additionalParameters);\n\tString tokenInfo;\n\ttry {\n\t\tByteArrayOutputStream out=new ByteArrayOutputStream();\n\t\tbyte[] buffer=new byte[1024];\n\t\tint len=inputStream.read(buffer);\n\t\twhile(len >= 0){\n\t\t\tout.write(buffer,0,len);\n\t\t\tlen=inputStream.read(buffer);\n\t\t}\n\t\ttokenInfo=new String(out.toByteArray(),\"UTF-8\");\n\t} catch (IOException e){\n\t} \n\tMap<String,String> tokenPropertyValues=new TreeMap<String,String>();\n\tString tokenValue=tokenPropertyValues.remove(OAuthProviderParameter.oauth_token.toString());\n\tString tokenSecret=tokenPropertyValues.remove(OAuthProviderParameter.oauth_token_secret.toString());\n\tOAuthConsumerToken consumerToken=new OAuthConsumerToken();\n\tconsumerToken.setValue(tokenValue);\n\tconsumerToken.setSecret(tokenSecret);\n\tconsumerToken.setNonce(requestToken.getNonce());\n\tconsumerToken.setResourceId(details.getId());\n\tconsumerToken.setAccessToken(isAccessToken);\n\treturn consumerToken;\n}","method":1,"docB":"<p> Implemented by subclasses. The responsibility of this method is to contact the service provider at the given endpoint URL and fetch a request or access token. What kind of token is retrieved solely depends on the URL being used. <\/p> <p> Correct implementations of this method must guarantee the following post-conditions: <ul> <li>the  {@link OAuthConsumer} passed to this method must have a valid{@link OAuth#OAUTH_TOKEN} and {@link OAuth#OAUTH_TOKEN_SECRET} set bycalling  {@link OAuthConsumer#setTokenWithSecret(String,String)}<\/li> <li> {@link #getResponseParameters()} must return the set of queryparameters served by the service provider in the token response, with all OAuth specific parameters being removed<\/li> <\/ul> <\/p>","docA":"Get the consumer token with the given parameters and URL. The determination of whether the retrieved token is an access token depends on whether a request token is provided.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"12":{"codeB":"public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tif(diffUnit instanceof XMLDocumentDiffUnit){\n\t\tXMLDocumentDiffUnit du=(XMLDocumentDiffUnit)diffUnit;\n\t} else if(diffUnit instanceof XMLNodeDiffUnit){\n\t\tif(n1 != null && n2 != null){\n\t\t\tString v1=n1.getNodeValue();\n\t\t\tString v2=n2.getNodeValue();\n\t\t\tif(v1 != null && v2 != null){\n\t\t\t} else if(v1 == null && v2 != null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Node value present in right only\");\n\t\t\t} else \n\t\t} else if(n1 == null && n2 != null){\n\t\t} else \n\t} else if(diffUnit instanceof XMLAttributeDiffUnit){\n\t\tXMLAttributeDiffUnit du=(XMLAttributeDiffUnit)diffUnit;\n\t\tString name=du.getAttributeName();\n\t\tif(!du.leftExists()){\n\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Attribute present in right only: \" + name);\n\t\t} else if(!du.rightExists()){\n\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Attribute present in left only: \" + name);\n\t\t} else {\n\t\t\tNode n1=du.getLeftAttributeNode();\n\t\t\tNode n2=du.getRightAttributeNode();\n\t\t\tString v1=n1.getNodeValue();\n\t\t\tString v2=n2.getNodeValue();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tInputStream is1=diffUnit.getLeftInputStream();\n\t\t\tInputStream is2=diffUnit.getRightInputStream();\n\t\t\tString scopedPath=diffUnit.getScopedPath();\n\t\t\tscope=createScope(scopedPath,is1,is2);\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n\treturn scope;\n}","codeA":"public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tProperties p1=new Properties();\n\tProperties p2=new Properties();\n\tInputStream is1=null;\n\tInputStream is2=null;\n\ttry {\n\t\tis1=diffUnit.getLeftInputStream();\n\t\tis2=diffUnit.getRightInputStream();\n\t\tSet<String> keys=new TreeSet<String>();\n\t\tkeys.addAll(p2.stringPropertyNames());\n\t\tfor (Iterator<String> it=keys.iterator(); it.hasNext(); ){\n\t\t\tString key=it.next();\n\t\t\tString v1=p1.getProperty(key);\n\t\t\tString v2=p2.getProperty(key);\n\t\t\tif(v1 == null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Property in right only: \" + key);\n\t\t\t} else if(v2 == null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Property in left only: \" + key);\n\t\t\t} else if(!v1.equals(v2)){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Property value mismatch for key \" + key + \": \"+ v1+ \", \"+ v2);\n\t\t\t\tprocessor.processDiffPoint(diffPoint);\n\t\t\t}\n\t\t}\n\t} catch (IOException ioe){\n\t} finally {\n\t} \n\treturn null;\n}","method":2,"docB":"Performs a deep XML comparison on <code>diffUnit<\/code>. If <code>diffUnit<\/code> represents part of a DOM, compares the unit and passes any {@link DiffPoint}s found to <code>processor<\/code>. Otherwise, returns a new {@link DiffScope} to process the XML document.","docA":"Performs a Properties comparison on <code>diffUnit<\/code>, and passes any {@link DiffPoint}s found to <code>processor<\/code>. The properties are iterated through and their values compared.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"13":{"codeB":"public Tag scan(Tag tag,Lexer lexer,NodeList stack) throws ParserException {\n\tString language;\n\tString code;\n\tNode content;\n\tint position;\n\tNode node;\n\tAttribute attribute;\n\tVector vector;\n\tif(tag instanceof ScriptTag){\n\t\tlanguage=((ScriptTag)tag).getLanguage();\n\t\tif((null != language) && (language.equalsIgnoreCase(\"JScript.Encode\") || language.equalsIgnoreCase(\"VBScript.Encode\"))){\n\t\t\tcode=ScriptDecoder.Decode(lexer.getPage(),lexer.getCursor());\n\t\t\t((ScriptTag)tag).setScriptCode(code);\n\t\t}\n\t}\n\tcontent=lexer.parseCDATA(!STRICT);\n\tposition=lexer.getPosition();\n\tnode=lexer.nextNode(false);\n\tif(null != node)\n\t\tif(!(node instanceof Tag) || !(((Tag)node).isEndTag() && ((Tag)node).getTagName().equals(tag.getIds()[0]))){\n\t\t\tlexer.setPosition(position);\n\t\t\tnode=null;\n\t\t}\n\tif(null == node){\n\t\tattribute=new Attribute(\"/script\",null);\n\t\tvector=new Vector();\n\t\tvector.addElement(attribute);\n\t\tnode=lexer.getNodeFactory().createTagNode(lexer.getPage(),position,position,vector);\n\t}\n\ttag.setEndTag((Tag)node);\n\tif(null != content){\n\t\ttag.setChildren(new NodeList(content));\n\t\tcontent.setParent(tag);\n\t}\n\tnode.setParent(tag);\n\ttag.doSemanticAction();\n\treturn (tag);\n}","codeA":"public Tag scan(Tag tag,Lexer lexer,NodeList stack) throws ParserException {\n\tNode content;\n\tint position;\n\tNode node;\n\tAttribute attribute;\n\tVector vector;\n\tcontent=lexer.parseCDATA();\n\tposition=lexer.getPosition();\n\tnode=lexer.nextNode(false);\n\tif(null != node)\n\t\tif(!(node instanceof Tag) || !(((Tag)node).isEndTag() && ((Tag)node).getTagName().equals(tag.getIds()[0]))){\n\t\t\tlexer.setPosition(position);\n\t\t\tnode=null;\n\t\t}\n\tif(null == node){\n\t\tattribute=new Attribute(\"/style\",null);\n\t\tvector=new Vector();\n\t\tvector.addElement(attribute);\n\t\tnode=lexer.getNodeFactory().createTagNode(lexer.getPage(),position,position,vector);\n\t}\n\ttag.setEndTag((Tag)node);\n\tif(null != content){\n\t\ttag.setChildren(new NodeList(content));\n\t\tcontent.setParent(tag);\n\t}\n\tnode.setParent(tag);\n\ttag.doSemanticAction();\n\treturn (tag);\n}","method":0,"docB":"Scan for style definitions. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.","docA":"Scan for script. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"14":{"codeB":"protected URL[][] extractImageLinks(final Lexer lexer,final URL docbase) throws IOException, ParserException {\n\tHashMap<String,URL> images;\n\tHashMap<String,URL> links;\n\tboolean ina;\n\tNode node;\n\tTag tag;\n\tString name;\n\tTag startatag;\n\tTag imgtag;\n\tString href;\n\tString src;\n\tURL url;\n\tURL[][] ret;\n\timages=new HashMap<String,URL>();\n\tlinks=new HashMap<String,URL>();\n\tina=false;\n\tstartatag=null;\n\timgtag=null;\n\twhile(null != (node=lexer.nextNode())){\n\t\tif(node instanceof Tag){\n\t\t\ttag=(Tag)node;\n\t\t\tname=tag.getTagName();\n\t\t\tif(\"A\".equals(name)){\n\t\t\t} else if(ina && \"IMG\".equals(name))\n\t\t\t\timgtag=tag;\n\t\t}\n\t}\n\tret=new URL[2][];\n\tret[0]=new URL[images.size()];\n\timages.values().toArray(ret[0]);\n\tret[1]=new URL[links.size()];\n\tlinks.values().toArray(ret[1]);\n\treturn (ret);\n}","codeA":"public String extractImageLocn(){\n\tVector attributes;\n\tint size;\n\tAttribute attribute;\n\tString string;\n\tString data;\n\tint state;\n\tString name;\n\tString ret;\n\tret=\"\";\n\tstate=0;\n\tattributes=getAttributesEx();\n\tsize=attributes.size();\n\tfor (int i=0; (i < size) && (state < 3); i++){\n\t\tattribute=(Attribute)attributes.elementAt(i);\n\t\tstring=attribute.getName();\n\t\tdata=attribute.getValue();\n\t\tswitch (state){\n\t\tcase 0: \n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tif(null != string){\n\t\t\t\tif(null == data)\n\t\t\t\t\tret=string;\n\t\t\t\tstate=0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"we're not supposed to in state \" + state);\n\t\t}\n\t}\n\tret=ParserUtils.removeChars(ret,'\\n');\n\treturn (ret);\n}","method":1,"docB":"Get the links of an element of a document. Only gets the links on IMG elements that reference another image. The latter is based on suffix (.jpg, .gif and .png).","docA":"Extract the location of the image Given the tag (with attributes), and the url of the html page in which this tag exists, perform best effort to extract the 'intended' URL. Attempts to handle such attributes as: <pre> &lt;IMG SRC=http://www.redgreen.com&gt; - normal &lt;IMG SRC =http://www.redgreen.com&gt; - space between attribute name and equals sign &lt;IMG SRC= http://www.redgreen.com&gt; - space between equals sign and attribute value &lt;IMG SRC = http://www.redgreen.com&gt; - space both sides of equals sign <\/pre>\n","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"15":{"codeB":"private StyleProp createProps(StyleProp prop,String style){\n\tint nameEnd;\n\tint valueEnd;\n\tint nameStart=0;\n\tboolean more;\n\twhile(nameStart < style.length()){\n\t\twhile(nameStart < style.length() && style.charAt(nameStart) == ' '){\n\t\t}\n\t\twhile(nameEnd < style.length()){\n\t\t\t++nameEnd;\n\t\t}\n\t\twhile(valueStart < style.length() && style.charAt(valueStart) == ' '){\n\t\t\t++valueStart;\n\t\t}\n\t\tvalueEnd=valueStart;\n\t\twhile(valueEnd < style.length()){\n\t\t\tif(style.charAt(valueEnd) == ';'){\n\t\t\t\tmore=true;\n\t\t\t}\n\t\t\t++valueEnd;\n\t\t}\n\t\tprop=insertProperty(prop,style.substring(nameStart,nameEnd),style.substring(valueStart,valueEnd));\n\t}\n\treturn prop;\n}","codeA":"private void createStyleElement(Lexer lexer,Node doc){\n\tNode node, head, body;\n\tStyle style;\n\tAttVal av;\n\tav=new AttVal(null,null,'\"',\"type\",\"text/css\");\n\tbody=doc.findBody(lexer.configuration.tt);\n\tlexer.txtstart=lexer.lexsize;\n\tfor (style=lexer.styles; style != null; style=style.next){\n\t\tlexer.addCharToLexer(' ');\n\t\tlexer.addStringLiteral(style.tag);\n\t\tlexer.addCharToLexer('.');\n\t\tlexer.addStringLiteral(style.tagClass);\n\t\tlexer.addCharToLexer(' ');\n\t\tlexer.addCharToLexer('{');\n\t\tlexer.addStringLiteral(style.properties);\n\t\tlexer.addCharToLexer('}');\n\t\tlexer.addCharToLexer('\\n');\n\t}\n\tlexer.txtend=lexer.lexsize;\n\thead=doc.findHEAD(lexer.configuration.tt);\n}","method":2,"docB":"Create style element using rules from dictionary.","docA":"Create sorted linked list of properties from style string.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"16":{"code_mymethod":{"r10":"public static String expandSystemId(String systemId,String baseSystemId){\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r20":"public static String expandSystemId(String systemId,String baseSystemId){\n\ttry {\n\t\tURI uri=new URI(systemId);\n\t} catch (URI.MalformedURIException e){\n\t} \n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tif(baseSystemId.indexOf(':') != -1){\n\t\t\t\t\tbase=new URI(\"file\",\"\",fixURI(baseSystemId),null,null);\n\t\t\t\t} else {\n\t\t\t\t\tdir=dir + fixURI(baseSystemId);\n\t\t\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r50%":"public static String expandSystemId(String systemId,String baseSystemId){\n\ttry {\n\t\tURI uri=new URI(systemId);\n\t\tif(uri != null){\n\t\t}\n\t} catch (URI.MalformedURIException e){\n\t} \n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\ttry {\n\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t} catch (SecurityException se){\n\t\t\t} \n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tif(baseSystemId.indexOf(':') != -1){\n\t\t\t\t\tbase=new URI(\"file\",\"\",fixURI(baseSystemId),null,null);\n\t\t\t\t} else {\n\t\t\t\t\tdir=dir + fixURI(baseSystemId);\n\t\t\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}"},"code_native":{"r10":"public static String expandSystemId(String systemId,String baseSystemId){\n\tif(systemId == null || systemId.length() == 0){\n\t\treturn systemId;\n\t}\n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r20":"public static String expandSystemId(String systemId,String baseSystemId){\n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tString dir;\n\t\t\t\ttry {\n\t\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t\t} catch (SecurityException se){\n\t\t\t\t\tdir=\"\";\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\treturn uri.toString();\n}","r50%":"public static String expandSystemId(String systemId,String baseSystemId){\n\tif(systemId == null || systemId.length() == 0){\n\t\treturn systemId;\n\t}\n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\ttry {\n\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t} catch (SecurityException se){\n\t\t\t\tdir=\"\";\n\t\t\t} \n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tString dir;\n\t\t\t\ttry {\n\t\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t\t} catch (SecurityException se){\n\t\t\t\t\tdir=\"\";\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n}"},"method":0,"code_original":"public static String expandSystemId(String systemId,String baseSystemId){\n\tif(systemId == null || systemId.length() == 0){\n\t\treturn systemId;\n\t}\n\ttry {\n\t\tURI uri=new URI(systemId);\n\t\tif(uri != null){\n\t\t\treturn systemId;\n\t\t}\n\t} catch (URI.MalformedURIException e){\n\t} \n\tString id=fixURI(systemId);\n\tURI base=null;\n\tURI uri=null;\n\ttry {\n\t\tif(baseSystemId == null || baseSystemId.length() == 0 || baseSystemId.equals(systemId)){\n\t\t\tString dir;\n\t\t\ttry {\n\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t} catch (SecurityException se){\n\t\t\t\tdir=\"\";\n\t\t\t} \n\t\t\tif(!dir.endsWith(\"/\")){\n\t\t\t\tdir=dir + \"/\";\n\t\t\t}\n\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbase=new URI(fixURI(baseSystemId));\n\t\t\t} catch (URI.MalformedURIException e){\n\t\t\t\tString dir;\n\t\t\t\ttry {\n\t\t\t\t\tdir=fixURI(System.getProperty(\"user.dir\"));\n\t\t\t\t} catch (SecurityException se){\n\t\t\t\t\tdir=\"\";\n\t\t\t\t} \n\t\t\t\tif(baseSystemId.indexOf(':') != -1){\n\t\t\t\t\tbase=new URI(\"file\",\"\",fixURI(baseSystemId),null,null);\n\t\t\t\t} else {\n\t\t\t\t\tif(!dir.endsWith(\"/\")){\n\t\t\t\t\t\tdir=dir + \"/\";\n\t\t\t\t\t}\n\t\t\t\t\tdir=dir + fixURI(baseSystemId);\n\t\t\t\t\tbase=new URI(\"file\",\"\",dir,null,null);\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\turi=new URI(base,id);\n\t} catch (URI.MalformedURIException e){\n\t} \n\tif(uri == null){\n\t\treturn systemId;\n\t}\n\treturn uri.toString();\n}","type":"T3"},"17":{"code_mymethod":{"r10":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t}\n\t} else {\n\t}\n\treturn newInstance(fallbackClassName,cl,true);\n}","r20":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\treturn newInstance(fallbackClassName,cl,true);\n}","r50%":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\ttry {\n\t\t\t\tif(fLastModified >= 0){\n\t\t\t\t} else {\n\t\t\t\t\tif(propertiesFileExists){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t\tfLastModified=ss.getLastModified(propertiesFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t} \n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\treturn newInstance(fallbackClassName,cl,true);\n}"},"code_native":{"r10":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(factoryClassName != null){\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n}","r20":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(factoryClassName != null){\n\t\tif(DEBUG)\n\t\t\tdebugPrintln(\"found in \" + propertiesFilename + \", value=\"+ factoryClassName);\n\t\treturn newInstance(factoryClassName,cl,true);\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n\treturn newInstance(fallbackClassName,cl,true);\n}","r50%":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tString javah=ss.getSystemProperty(\"java.home\");\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t\tfLastModified=-1;\n\t\t\tfXercesProperties=null;\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\tboolean loadProperties=false;\n\t\t\ttry {\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t\tfXercesProperties=null;\n\t\t\t\tfLastModified=-1;\n\t\t\t} \n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(DEBUG)\n\treturn newInstance(fallbackClassName,cl,true);\n}"},"method":0,"code_original":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\tif(DEBUG)\n\t\t\t\tdebugPrintln(\"found system property, value=\" + systemProp);\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tString javah=ss.getSystemProperty(\"java.home\");\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t\tfLastModified=-1;\n\t\t\tfXercesProperties=null;\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\tboolean loadProperties=false;\n\t\t\ttry {\n\t\t\t\tif(fLastModified >= 0){\n\t\t\t\t\tif(propertiesFileExists && (fLastModified < (fLastModified=ss.getLastModified(propertiesFile)))){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(!propertiesFileExists){\n\t\t\t\t\t\t\tfLastModified=-1;\n\t\t\t\t\t\t\tfXercesProperties=null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(propertiesFileExists){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t\tfLastModified=ss.getLastModified(propertiesFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t\tfXercesProperties=null;\n\t\t\t\tfLastModified=-1;\n\t\t\t} \n\t\t}\n\t\tif(fXercesProperties != null){\n\t\t\tfactoryClassName=fXercesProperties.getProperty(factoryId);\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tif(factoryClassName != null){\n\t\tif(DEBUG)\n\t\t\tdebugPrintln(\"found in \" + propertiesFilename + \", value=\"+ factoryClassName);\n\t\treturn newInstance(factoryClassName,cl,true);\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(provider != null){\n\t\treturn provider;\n\t}\n\tif(fallbackClassName == null){\n\t\tthrow new ConfigurationError(\"Provider for \" + factoryId + \" cannot be found\",null);\n\t}\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n\treturn newInstance(fallbackClassName,cl,true);\n}","type":"T3"},"18":{"code_mymethod":{"r10":"protected void copy(){\n\tif(getCaptureResources()){\n\t\ttry {\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t} finally {\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n}","r20":"protected void copy(){\n\tString link;\n\tString name;\n\tFile file;\n\tFile dir;\n\tbyte[] data;\n\tInputStream in;\n\tif(getCaptureResources()){\n\t\ttry {\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t\ttry {\n\t\t\t\tin=source.openStream();\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile(-1 != (read=in.read(data,0,data.length)))\n\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t} finally {\n\t\t\t\t\tin.close();\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n}","r50%":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tbyte[] data;\n\tInputStream in;\n\tint read;\n\tif(getCaptureResources()){\n\t\traw=makeLocalLink(link,\"\");\n\t\tfile=new File(getTarget(),name);\n\t\ttry {\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t\ttry {\n\t\t\t\tin=source.openStream();\n\t\t\t\ttry {\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile(-1 != (read=in.read(data,0,data.length)))\n\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t} finally {\n\t\t\t\t\tin.close();\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n}"},"code_native":{"r10":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tlink=(String)mImages.remove(0);\n}","r20":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tint read;\n\tlink=(String)mImages.remove(0);\n\tif(getCaptureResources()){\n\t\traw=makeLocalLink(link,\"\");\n\t\tname=decode(raw);\n\t\tfile=new File(getTarget(),name);\n\t\tSystem.out.println(\"copying \" + link + \" to \"+ file.getAbsolutePath());\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t}\n}","r50%":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tint read;\n\tlink=(String)mImages.remove(0);\n\tmCopied.add(link);\n\tif(getCaptureResources()){\n\t\tfile=new File(getTarget(),name);\n\t\tSystem.out.println(\"copying \" + link + \" to \"+ file.getAbsolutePath());\n\t\tdir=file.getParentFile();\n\t\ttry {\n\t\t\tsource=new URL(link);\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t} catch (MalformedURLException murle){\n\t\t\tmurle.printStackTrace();\n\t\t} catch (IOException ioe){\n\t\t\tioe.printStackTrace();\n\t\t} \n\t}\n}"},"method":0,"code_original":"protected void copy(){\n\tString link;\n\tString raw;\n\tString name;\n\tFile file;\n\tFile dir;\n\tURL source;\n\tbyte[] data;\n\tInputStream in;\n\tFileOutputStream out;\n\tint read;\n\tlink=(String)mImages.remove(0);\n\tmCopied.add(link);\n\tif(getCaptureResources()){\n\t\traw=makeLocalLink(link,\"\");\n\t\tname=decode(raw);\n\t\tfile=new File(getTarget(),name);\n\t\tSystem.out.println(\"copying \" + link + \" to \"+ file.getAbsolutePath());\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t\ttry {\n\t\t\tsource=new URL(link);\n\t\t\tdata=new byte[TRANSFER_SIZE];\n\t\t\ttry {\n\t\t\t\tin=source.openStream();\n\t\t\t\ttry {\n\t\t\t\t\tout=new FileOutputStream(file);\n\t\t\t\t\ttry {\n\t\t\t\t\t\twhile(-1 != (read=in.read(data,0,data.length)))\n\t\t\t\t\t\t\tout.write(data,0,read);\n\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tout.close();\n\t\t\t\t\t} \n\t\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\t\tfnfe.printStackTrace();\n\t\t\t\t} finally {\n\t\t\t\t\tin.close();\n\t\t\t\t} \n\t\t\t} catch (FileNotFoundException fnfe){\n\t\t\t\tSystem.err.println(\"broken link \" + fnfe.getMessage() + \" ignored\");\n\t\t\t} \n\t\t} catch (MalformedURLException murle){\n\t\t\tmurle.printStackTrace();\n\t\t} catch (IOException ioe){\n\t\t\tioe.printStackTrace();\n\t\t} \n\t}\n}","type":"T3"},"19":{"code_mymethod":{"r10":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\ttry {\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t} catch (EncodingChangeException ece){\n\t\t} \n\t\ttry {\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t} catch (FileNotFoundException fnfe){\n\t\t} \n\t} catch (ParserException pe){\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t} else \n\t} \n}","r20":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tbookmark=mPages.size();\n\t\ttry {\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(0 != robots.size()){\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"nofollow\")))\n\t\t\t\tfor (int i=bookmark; i < mPages.size(); i++)\n\t\t}\n\t\tdir=file.getParentFile();\n\t\ttry {\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t} catch (FileNotFoundException fnfe){\n\t\t} \n\t} catch (ParserException pe){\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t} else \n\t} \n}","r50%":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tbookmark=mPages.size();\n\t\ttry {\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(0 != robots.size()){\n\t\t\trobot=(MetaTag)robots.elementAt(0);\n\t\t\tcontent=robot.getAttribute(\"content\").toLowerCase();\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"nofollow\")))\n\t\t\t\tfor (int i=bookmark; i < mPages.size(); i++)\n\t\t}\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t\telse if(!dir.isDirectory()){\n\t\t\tdir=new File(dir.getParentFile(),dir.getName() + \".content\");\n\t\t\tfile=new File(dir,file.getName());\n\t\t}\n\t\ttry {\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t} catch (FileNotFoundException fnfe){\n\t\t} \n\t} catch (ParserException pe){\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}"},"code_native":{"r10":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\tPrintWriter out;\n\turl=(String)mPages.remove(0);\n}","r20":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\tPrintWriter out;\n\turl=(String)mPages.remove(0);\n\tSystem.out.println(\"processing \" + url);\n\ttry {\n\t\tbookmark=mPages.size();\n\t\tmParser.setURL(url);\n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t} catch (ParserException pe){\n\t} \n}","r50%":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tmParser.setURL(url);\n\t\ttry {\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t\tmParser.reset();\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t} catch (ParserException pe){\n\t\tString message;\n\t\tmessage=pe.getMessage();\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}"},"method":0,"code_original":"protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\tPrintWriter out;\n\turl=(String)mPages.remove(0);\n\tSystem.out.println(\"processing \" + url);\n\tmFinished.add(url);\n\ttry {\n\t\tbookmark=mPages.size();\n\t\tmParser.setURL(url);\n\t\ttry {\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t\tmParser.reset();\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(0 != robots.size()){\n\t\t\trobot=(MetaTag)robots.elementAt(0);\n\t\t\tcontent=robot.getAttribute(\"content\").toLowerCase();\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"nofollow\")))\n\t\t\t\tfor (int i=bookmark; i < mPages.size(); i++)\n\t\t\t\t\tmPages.remove(i);\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"noindex\")))\n\t\t\t\treturn;\n\t\t}\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t\telse if(!dir.isDirectory()){\n\t\t\tdir=new File(dir.getParentFile(),dir.getName() + \".content\");\n\t\t\tif(!dir.exists())\n\t\t\t\tdir.mkdirs();\n\t\t\tfile=new File(dir,file.getName());\n\t\t}\n\t\ttry {\n\t\t\tout=new PrintWriter(new FileOutputStream(file));\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t\t\tout.print(list.elementAt(i).toHtml());\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException fnfe){\n\t\t\tfnfe.printStackTrace();\n\t\t} \n\t} catch (ParserException pe){\n\t\tString message;\n\t\tmessage=pe.getMessage();\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}","type":"T3"},"1":{"codes":["private static NodePointer doPredicateName(EvalContext context,NodePointer parent,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tExpression predicate=predicates[currentPredicate];\n\tString key=keyFromPredicate(context,predicate);\n\tNodePointer child=valuePointer(parent);\n\tif(child instanceof PropertyOwnerPointer){\n\t\tPropertyPointer pointer=((PropertyOwnerPointer)child).getPropertyPointer();\n\t\tpointer.setPropertyName(key);\n\t\tif(pointer.isActual()){\n\t\t\treturn doPredicate(context,pointer,steps,currentStep,predicates,currentPredicate + 1);\n\t\t}\n\t} else if(child.isCollection()){\n\t\tNodePointer bestMatch=null;\n\t\tint bestQuality=0;\n\t\tchild=(NodePointer)child.clone();\n\t\tint count=child.getLength();\n\t\tfor (int i=0; i < count; i++){\n\t\t\tchild.setIndex(i);\n\t\t\tNodePointer valuePointer=valuePointer(child);\n\t\t\tNodePointer pointer;\n\t\t\tif((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()){\n\t\t\t\tpointer=doPredicateName(context,valuePointer,steps,currentStep,predicates,currentPredicate);\n\t\t\t} else if(isNameAttributeEqual(valuePointer,key)){\n\t\t\t\tpointer=doPredicate(context,valuePointer,steps,currentStep,predicates,currentPredicate + 1);\n\t\t\t} else {\n\t\t\t\tpointer=null;\n\t\t\t}\n\t\t\tif(pointer != null){\n\t\t\t\tint quality=computeQuality(pointer);\n\t\t\t\tif(quality == PERFECT_MATCH){\n\t\t\t\t\treturn pointer;\n\t\t\t\t}\n\t\t\t\tif(quality > bestQuality){\n\t\t\t\t\tbestMatch=(NodePointer)pointer.clone();\n\t\t\t\t\tbestQuality=quality;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bestMatch != null){\n\t\t\treturn bestMatch;\n\t\t}\n\t} else {\n\t\tNodePointer found=doPredicatesStandard(context,Collections.singletonList(child),steps,currentStep,predicates,currentPredicate);\n\t\tif(found != null){\n\t\t\treturn found;\n\t\t}\n\t}\n\treturn createNullPointerForPredicates(context,child,steps,currentStep,predicates,currentPredicate);\n}","private static NodePointer doStepPredicatesStandard(EvalContext context,NodePointer parent,Step[] steps,int currentStep){\n\tStep step=steps[currentStep];\n\tExpression[] predicates=step.getPredicates();\n\tint axis=step.getAxis();\n\tif(axis == Compiler.AXIS_SELF){\n\t\treturn doPredicate(context,parent,steps,currentStep,predicates,0);\n\t}\n\tExpression predicate=predicates[0];\n\tif(predicates.length == 1){\n\t\tNodeIterator it=getNodeIterator(context,parent,step);\n\t\tNodePointer pointer=null;\n\t\tif(it != null){\n\t\t\tif(predicate instanceof NameAttributeTest){\n\t\t\t\tString key=keyFromPredicate(context,predicate);\n\t\t\t\tfor (int i=1; it.setPosition(i); i++){\n\t\t\t\t\tNodePointer ptr=it.getNodePointer();\n\t\t\t\t\tif(isNameAttributeEqual(ptr,key)){\n\t\t\t\t\t\tpointer=ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint index=indexFromPredicate(context,predicate);\n\t\t\t\tif(it.setPosition(index + 1)){\n\t\t\t\t\tpointer=it.getNodePointer();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pointer != null){\n\t\t\treturn doStep(context,pointer,steps,currentStep + 1);\n\t\t}\n\t} else {\n\t\tNodeIterator it=getNodeIterator(context,parent,step);\n\t\tif(it != null){\n\t\t\tList list=new ArrayList();\n\t\t\tfor (int i=1; it.setPosition(i); i++){\n\t\t\t\tlist.add(it.getNodePointer());\n\t\t\t}\n\t\t\tNodePointer pointer=doPredicatesStandard(context,list,steps,currentStep,predicates,0);\n\t\t\tif(pointer != null){\n\t\t\t\treturn pointer;\n\t\t\t}\n\t\t}\n\t}\n\treturn createNullPointer(context,parent,steps,currentStep);\n}","private static NodePointer doPredicatesStandard(EvalContext context,List parents,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tif(parents.size() == 0){\n\t\treturn null;\n\t}\n\tif(currentPredicate == predicates.length){\n\t\tNodePointer pointer=(NodePointer)parents.get(0);\n\t\treturn doStep(context,pointer,steps,currentStep + 1);\n\t}\n\tExpression predicate=predicates[currentPredicate];\n\tif(predicate instanceof NameAttributeTest){\n\t\tString key=keyFromPredicate(context,predicate);\n\t\tList newList=new ArrayList();\n\t\tfor (int i=0; i < parents.size(); i++){\n\t\t\tNodePointer pointer=(NodePointer)parents.get(i);\n\t\t\tif(isNameAttributeEqual(pointer,key)){\n\t\t\t\tnewList.add(pointer);\n\t\t\t}\n\t\t}\n\t\tif(newList.size() == 0){\n\t\t\treturn null;\n\t\t}\n\t\treturn doPredicatesStandard(context,newList,steps,currentStep,predicates,currentPredicate + 1);\n\t} else {\n\t\tint index=indexFromPredicate(context,predicate);\n\t\tif(index < 0 || index >= parents.size()){\n\t\t\treturn null;\n\t\t}\n\t\tNodePointer ptr=(NodePointer)parents.get(index);\n\t\treturn doPredicate(context,ptr,steps,currentStep,predicates,currentPredicate + 1);\n\t}\n}","private static NodePointer doStepNoPredicatesPropertyOwner(EvalContext context,PropertyOwnerPointer parentPointer,Step[] steps,int currentStep){\n\tStep step=steps[currentStep];\n\tNodePointer childPointer=createChildPointerForStep(parentPointer,step);\n\tif(childPointer == null){\n\t\treturn null;\n\t}\n\tif(!childPointer.isActual()){\n\t\treturn createNullPointer(context,parentPointer,steps,currentStep);\n\t}\n\tif(currentStep == steps.length - 1){\n\t\treturn childPointer;\n\t}\n\tif(childPointer.isCollection()){\n\t\tint bestQuality=0;\n\t\tchildPointer=(NodePointer)childPointer.clone();\n\t\tNodePointer bestMatch=null;\n\t\tint count=childPointer.getLength();\n\t\tfor (int i=0; i < count; i++){\n\t\t\tchildPointer.setIndex(i);\n\t\t\tNodePointer pointer=doStep(context,childPointer,steps,currentStep + 1);\n\t\t\tint quality=computeQuality(pointer);\n\t\t\tif(quality == PERFECT_MATCH){\n\t\t\t\treturn pointer;\n\t\t\t} else if(quality > bestQuality){\n\t\t\t\tbestQuality=quality;\n\t\t\t\tbestMatch=(NodePointer)pointer.clone();\n\t\t\t}\n\t\t}\n\t\tif(bestMatch != null){\n\t\t\treturn bestMatch;\n\t\t}\n\t\treturn createNullPointer(context,childPointer,steps,currentStep);\n\t}\n\treturn doStep(context,childPointer,steps,currentStep + 1);\n}","private static NodePointer doPredicate(EvalContext context,NodePointer parent,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tif(currentPredicate == predicates.length){\n\t\treturn doStep(context,parent,steps,currentStep + 1);\n\t}\n\tExpression predicate=predicates[currentPredicate];\n\tif(predicate instanceof NameAttributeTest){\n\t\treturn doPredicateName(context,parent,steps,currentStep,predicates,currentPredicate);\n\t}\n\treturn doPredicateIndex(context,parent,steps,currentStep,predicates,currentPredicate);\n}"],"method":0,"correctSolution":1,"doc":"A path that starts with a standard InfoSet node, e.g. a DOM Node. The method evaluates the first predicate in a special way and then forwards to a general predicate processing method.","type":"T1"},"2":{"codes":["private boolean authenticate(String user,String passwd) throws MessagingException {\n\tString mechs=session.getProperty(\"mail.\" + name + \".auth.mechanisms\");\n\tif(mechs == null)\n\tString authzid=getAuthorizationId();\n\tif(enableSASL){\n\t\tif(debug)\n\t\t\tout.println(\"DEBUG SMTP: Authenticate with SASL\");\n\t\tif(sasllogin(getSASLMechanisms(),getSASLRealm(),authzid,user,passwd))\n\t\t\treturn true;\n\t\tif(debug)\n\t\t\tout.println(\"DEBUG SMTP: SASL authentication failed\");\n\t}\n\tStringTokenizer st=new StringTokenizer(mechs);\n\twhile(st.hasMoreTokens()){\n\t\tString m=st.nextToken();\n\t\tString dprop=\"mail.\" + name + \".auth.\"+ m.toLowerCase(Locale.ENGLISH)+ \".disable\";\n\t\tboolean disabled=PropUtil.getBooleanSessionProperty(session,dprop,false);\n\t\tm=m.toUpperCase(Locale.ENGLISH);\n\t\tAuthenticator a=(Authenticator)authenticators.get(m);\n\t\treturn a.authenticate(host,authzid,user,passwd);\n\t}\n\tthrow new AuthenticationFailedException(\"No authentication mechansims supported by both server and client\");\n}","public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method,String username,String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {\n\tswitch (method){\n\tcase CRAM_MD5:  {\n\t\tbyte[] serverChallenge=Base64.decodeBase64(getReplyString().substring(2).trim());\n\t\tMac hmac_md5=Mac.getInstance(\"HmacMD5\");\n\t\thmac_md5.init(new SecretKeySpec(password.getBytes(),\"HmacMD5\"));\n\t\tbyte[] hmacResult=_convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();\n\t\tbyte[] usernameBytes=username.getBytes();\n\t\tbyte[] toEncode=new byte[usernameBytes.length + 1 + hmacResult.length];\n\t\tSystem.arraycopy(usernameBytes,0,toEncode,0,usernameBytes.length);\n\t\ttoEncode[usernameBytes.length]=' ';\n\t\tSystem.arraycopy(hmacResult,0,toEncode,usernameBytes.length + 1,hmacResult.length);\n\t\tint result=sendData(new String(Base64.encodeBase64(toEncode)));\n\t\treturn result == IMAPReply.OK;\n\t}\n\tcase LOGIN:  {\n\t\tint result=sendData(new String(Base64.encodeBase64(password.getBytes())));\n\t\treturn result == IMAPReply.OK;\n\t}\n\t}\n\treturn false;\n}","public synchronized void authlogin(String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE LOGIN command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE LOGIN\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tByteArrayOutputStream bos=new ByteArrayOutputStream();\n\t\tOutputStream b64os=new BASE64EncoderStream(bos,Integer.MAX_VALUE);\n\t\tboolean first=true;\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE LOGIN command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}","public synchronized void authntlm(String authzid,String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\tString type1Msg=null;\n\tint flags=PropUtil.getIntProperty(props,\"mail.\" + name + \".auth.ntlm.flags\",0);\n\tString domain=props.getProperty(\"mail.\" + name + \".auth.ntlm.domain\",\"\");\n\tNtlm ntlm=new Ntlm(domain,getLocalHost(),u,p,debug ? out : null);\n\ttry {\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE NTLM\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tboolean first=true;\n\t\twhile(!done){\n\t\t}\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE NTLM command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}","public synchronized void authplain(String authzid,String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE PLAIN command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE PLAIN\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tByteArrayOutputStream bos=new ByteArrayOutputStream();\n\t\tOutputStream b64os=new BASE64EncoderStream(bos,Integer.MAX_VALUE);\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE PLAIN command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n}"],"method":1,"correctSolution":0,"doc":"Performs the actual protocol-specific connection attempt. Will attempt to connect to \"localhost\" if the host was null. Unless mail.smtp.ehlo is set to false, we'll try to identify ourselves using the ESMTP command EHLO. If mail.smtp.auth is set to true, we insist on having a username and password, and will try to authenticate ourselves if the server supports the AUTH extension (RFC 2554).","type":"T1"},"3":{"codes":["public static boolean check(List constraints,Authenticator authenticator,UserRealm realm,String pathInContext,HttpRequest request,HttpResponse response) throws HttpException, IOException {\n\tObject roles=null;\n\tfor (int c=0; c < constraints.size(); c++){\n\t\tSecurityConstraint sc=(SecurityConstraint)constraints.get(c);\n\t\tif(!unauthenticated && !forbidden){\n\t\t\tif(sc.getAuthenticate()){\n\t\t\t\tif(sc.isAnyRole()){\n\t\t\t\t\troles=ANY_ROLE;\n\t\t\t\t} else {\n\t\t\t\t\tList scr=sc.getRoles();\n\t\t\t\t}\n\t\t\t} else \n\t\t}\n\t}\n\tif(dataConstraint > DC_NONE){\n\t\tHttpConnection connection=request.getHttpConnection();\n\t\tHttpListener listener=connection.getListener();\n\t\tswitch (dataConstraint){\n\t\tcase SecurityConstraint.DC_INTEGRAL: \n\t\t\tif(listener.getIntegralPort() > 0){\n\t\t\t\tString url=listener.getIntegralScheme() + \"://\" + request.getHost()+ \":\"+ listener.getIntegralPort()+ request.getPath();\n\t\t\t\tif(request.getQuery() != null)\n\t\t\t\t\turl+=\"?\" + request.getQuery();\n\t\t\t\tresponse.setContentLength(0);\n\t\t\t\tresponse.sendRedirect(url);\n\t\t\t} else \n\t\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t}\n\t}\n\tif(!unauthenticated && roles != null){\n\t\tif(realm == null){\n\t\t\tHttpContext.sendContextError(response,HttpResponse.__500_Internal_Server_Error,\"Configuration error\");\n\t\t}\n\t\tPrincipal user=null;\n\t\tif(request.getAuthType() != null && request.getAuthUser() != null){\n\t\t\tif(user == null && authenticator != null)\n\t\t\t\tuser=authenticator.authenticate(realm,pathInContext,request,response);\n\t\t} else if(authenticator != null){\n\t\t\tuser=authenticator.authenticate(realm,pathInContext,request,response);\n\t\t} else {\n\t\t\tlog.warn(\"Mis-configured Authenticator for \" + request.getPath());\n\t\t\tHttpContext.sendContextError(response,HttpResponse.__500_Internal_Server_Error,\"Configuration error\");\n\t\t}\n\t\tif(roles != ANY_ROLE){\n\t\t\tfor (int r=LazyList.size(roles); r-- > 0; ){\n\t\t\t}\n\t\t\tif(!inRole){\n\t\t\t\tlog.warn(\"AUTH FAILURE: role for \" + user.getName());\n\t\t\t\tif(\"BASIC\".equalsIgnoreCase(authenticator.getAuthMethod()))\n\t\t\t\t\t((BasicAuthenticator)authenticator).sendChallenge(realm,response);\n\t\t\t\telse \n\t\t\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,\"User not in required role\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\trequest.setUserPrincipal(HttpRequest.__NOT_CHECKED);\n\t}\n}","public void handle(HttpRequest request,HttpResponse response) throws HttpException, IOException {\n\tif(!isStarted() || _gracefulStop)\n\t\treturn;\n\tif(_hosts != null && _hosts.size() > 0){\n\t\tObject o=request.getHttpConnection().getConnection();\n\t\tif(o instanceof Socket){\n\t\t\tSocket s=(Socket)o;\n\t\t\tif(!_hosts.contains(s.getLocalAddress())){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tString pathInContext=URI.canonicalPath(request.getPath());\n\tif(_redirectNullPath && (pathInContext == null || pathInContext.length() == 0)){\n\t\tStringBuffer buf=request.getRequestURL();\n\t\tString q=request.getQuery();\n\t\tresponse.sendRedirect(buf.toString());\n\t\treturn;\n\t}\n\tString pathParams=null;\n\tint semi=pathInContext.lastIndexOf(';');\n\tif(semi >= 0){\n\t\tint pl=pathInContext.length() - semi;\n\t\tString ep=request.getEncodedPath();\n\t\tif(';' == ep.charAt(ep.length() - pl)){\n\t\t\tpathInContext=pathInContext.substring(0,semi);\n\t\t}\n\t}\n\ttry {\n\t\thandle(pathInContext,pathParams,request,response);\n\t} finally {\n\t} \n}","public void handle(String pathInContext,String pathParams,HttpRequest httpRequest,HttpResponse httpResponse) throws IOException {\n\tif(!isStarted())\n\t\treturn;\n\tServletHttpRequest request=(ServletHttpRequest)httpRequest.getWrapper();\n\tServletHttpResponse response=(ServletHttpResponse)httpResponse.getWrapper();\n\tif(request == null){\n\t\trequest=new ServletHttpRequest(this,pathInContext,httpRequest);\n\t\tresponse=new ServletHttpResponse(request,httpResponse);\n\t\thttpRequest.setWrapper(request);\n\t\thttpResponse.setWrapper(response);\n\t} else {\n\t\trequest.recycle(this,pathInContext);\n\t\tresponse.recycle();\n\t}\n\tMap.Entry servlet=getHolderEntry(pathInContext);\n\tServletHolder servletHolder=servlet == null ? null : (ServletHolder)servlet.getValue();\n\ttry {\n\t\tif(servlet != null){\n\t\t\tString servletPathSpec=(String)servlet.getKey();\n\t\t\trequest.setServletPaths(PathMap.pathMatch(servletPathSpec,pathInContext),PathMap.pathInfo(servletPathSpec,pathInContext),servletHolder);\n\t\t}\n\t\trequest.setRequestedSessionId(pathParams);\n\t\tHttpSession session=request.getSession(false);\n\t\tif(servletHolder != null)\n\t\t\tdispatch(pathInContext,request,response,servletHolder,Dispatcher.__REQUEST);\n\t} catch (Exception e){\n\t\tThrowable th=e;\n\t\twhile(th instanceof ServletException){\n\t\t\tlog.warn(LogSupport.EXCEPTION,th);\n\t\t\tThrowable cause=((ServletException)th).getRootCause();\n\t\t}\n\t\tif(th instanceof EOFException)\n\t\telse if(log.isDebugEnabled() || !(th instanceof java.io.IOException)){\n\t\t}\n\t\tif(!httpResponse.isCommitted()){\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION_TYPE,th.getClass());\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION,th);\n\t\t\tif(th instanceof UnavailableException){\n\t\t\t\tUnavailableException ue=(UnavailableException)th;\n\t\t\t\tif(ue.isPermanent())\n\t\t\t\telse \n\t\t\t\t\tresponse.sendError(HttpResponse.__503_Service_Unavailable,e.getMessage());\n\t\t\t} else \n\t\t} else \n\t} catch (Error e){\n\t\tif(!httpResponse.isCommitted()){\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION_TYPE,e.getClass());\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION,e);\n\t\t} else \n\t} finally {\n\t} \n}","XObject execute(final XPathContext xpathContext,final int contextNode,final PrefixResolver namespaceContext) throws TransformerException {\n\txpathContext.pushNamespaceContext(namespaceContext);\n\txpathContext.pushCurrentNodeAndExpression(contextNode,contextNode);\n\tXObject xobj=null;\n\ttry {\n\t\txobj=mainExp_.execute(xpathContext);\n\t} catch (final TransformerException te){\n\t\tif(null != el){\n\t\t} else {\n\t\t\tthrow te;\n\t\t}\n\t} catch (Exception e){\n\t\tif(null != el){\n\t\t} else {\n\t\t\tthrow te;\n\t\t}\n\t} finally {\n\t\txpathContext.popNamespaceContext();\n\t\txpathContext.popCurrentNodeAndExpression();\n\t} \n\treturn xobj;\n}","public HttpContext service(HttpRequest request,HttpResponse response) throws IOException, HttpException {\n\tString host=request.getHost();\n\twhile(true){\n\t\tPathMap contextMap=(PathMap)_virtualHostMap.get(host);\n\t\tif(contextMap != null){\n\t\t\tList contextLists=contextMap.getMatches(request.getPath());\n\t\t\tif(contextLists != null){\n\t\t\t\tfor (int i=0; i < contextLists.size(); i++){\n\t\t\t\t\tMap.Entry entry=(Map.Entry)contextLists.get(i);\n\t\t\t\t\tList contextList=(List)entry.getValue();\n\t\t\t\t\tfor (int j=0; j < contextList.size(); j++){\n\t\t\t\t\t\tHttpContext context=(HttpContext)contextList.get(j);\n\t\t\t\t\t\tcontext.handle(request,response);\n\t\t\t\t\t\tif(request.isHandled())\n\t\t\t\t\t\t\treturn context;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thost=null;\n\t}\n\tsynchronized (this){\n\t\tif(_notFoundContext == null){\n\t\t\t_notFoundContext=new HttpContext();\n\t\t\t_notFoundContext.setContextPath(\"/\");\n\t\t\t_notFoundContext.setHttpServer(this);\n\t\t\taddComponent(_notFoundContext);\n\t\t}\n\t\treturn _notFoundContext;\n\t}\n}"],"method":2,"correctSolution":4,"doc":"Process a request. Handle the request by passing it to the HttpHandler contained in the mapped HttpContexts. The requests host and path are used to select a list of HttpContexts. Each HttpHandler in these context is offered the request in turn, until the request is handled. If no handler handles the request, 404 Not Found is returned.","type":"T1"},"4":{"codes":["public Resource getResource(String pathInContext) throws IOException {\n\tif(log.isTraceEnabled())\n\t\tlog.trace(\"getResource \" + pathInContext);\n\tif(_resourceBase == null)\n\t\treturn null;\n\tResource resource=null;\n\tsynchronized (_cache){\n\t\tCachedResource cached=(CachedResource)_cache.get(pathInContext);\n\t\tif(cached != null){\n\t\t\tif(log.isTraceEnabled())\n\t\t\t\tlog.trace(\"CACHE HIT: \" + cached);\n\t\t\tCachedMetaData cmd=(CachedMetaData)cached.getAssociate();\n\t\t\tif(cmd != null && cmd.isValid())\n\t\t\t\treturn cached;\n\t\t}\n\t\tresource=_resourceBase.addPath(_resourceBase.encode(pathInContext));\n\t\tif(log.isTraceEnabled())\n\t\t\tlog.trace(\"CACHE MISS: \" + resource);\n\t\tif(resource == null)\n\t\t\treturn null;\n\t\tif(resource.getAlias() != null){\n\t\t\tlog.warn(\"Alias request of '\" + resource.getAlias() + \"' for '\"+ resource+ \"'\");\n\t\t\treturn null;\n\t\t}\n\t\tlong len=resource.length();\n\t\tif(resource.exists()){\n\t\t\tif(!resource.isDirectory() && pathInContext.endsWith(\"/\"))\n\t\t\t\treturn null;\n\t\t\tif(resource.isDirectory()){\n\t\t\t\tif(resource.list() != null)\n\t\t\t\t\tlen=resource.list().length * 100;\n\t\t\t\telse \n\t\t\t\t\tlen=0;\n\t\t\t}\n\t\t\tif(len > 0 && len < _maxCachedFileSize && len < _maxCacheSize){\n\t\t\t\tint needed=_maxCacheSize - (int)len;\n\t\t\t\twhile(_cacheSize > needed)\n\t\t\t\t\t_leastRecentlyUsed.invalidate();\n\n\t\t\t\tcached=resource.cache();\n\t\t\t\tif(log.isTraceEnabled())\n\t\t\t\t\tlog.trace(\"CACHED: \" + resource);\n\t\t\t\tnew CachedMetaData(cached,pathInContext);\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\t}\n\tnew ResourceMetaData(resource);\n\treturn resource;\n}","public static JSONObject loadJSON(String resource){\n\tInputStream in=Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);\n\tif(in == null){\n\t\ttry {\n\t\t\tin=new FileInputStream(resource);\n\t\t} catch (FileNotFoundException e){\n\t\t} \n\t}\n\tif(in == null){\n\t\tthrow new RuntimeException(resource + \" is not a valid resource.\");\n\t}\n\tStringBuilder b=new StringBuilder();\n\tInputStreamReader inputreader=new InputStreamReader(in);\n\tBufferedReader buffreader=new BufferedReader(inputreader);\n\tString line;\n\ttry {\n\t\twhile((line=buffreader.readLine()) != null){\n\t\t\tb.append(line);\n\t\t}\n\t} catch (IOException e){\n\t\tthrow new GridConfigurationException(\"Cannot read file \" + resource + \" , \"+ e.getMessage(),e);\n\t} \n\tString json=b.toString();\n\tJSONObject o;\n\ttry {\n\t\to=new JSONObject(json);\n\t} catch (JSONException e){\n\t\tthrow new GridConfigurationException(\"Wrong format for the JSON input : \" + e.getMessage(),e);\n\t} \n\treturn o;\n}","public void loadFromGridYml(String resource){\n\tInputStream in=Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);\n\tif(in == null){\n\t\ttry {\n\t\t\tin=new FileInputStream(resource);\n\t\t} catch (FileNotFoundException e){\n\t\t} \n\t}\n\tif(in == null){\n\t\tthrow new InvalidParameterException(resource + \" is not a valid resource.\");\n\t}\n\tYaml yaml=new Yaml();\n\tMap<String,Object> config=(Map<String,Object>)yaml.load(in);\n\tMap<String,Object> hub=(Map<String,Object>)config.get(\"hub\");\n\tList<Map<String,String>> environments=(List<Map<String,String>>)hub.get(\"environments\");\n\tInteger p=(Integer)hub.get(\"port\");\n\tif(p != null){\n\t\tthis.port=p;\n\t}\n\tfor (Map<String,String> environment : environments){\n\t\tgetGrid1Mapping().put(environment.get(\"name\"),environment.get(\"browser\"));\n\t}\n\tInteger poll=(Integer)hub.get(\"remoteControlPollingIntervalInSeconds\");\n\tif(poll != null){\n\t\tallParams.put(RegistrationRequest.NODE_POLLING,poll.intValue() * 1000);\n\t\tcleanupCycle=poll.intValue() * 1000;\n\t}\n\tInteger timeout=(Integer)hub.get(\"sessionMaxIdleTimeInSeconds\");\n\tif(timeout != null){\n\t\ttimeout=timeout.intValue() * 1000;\n\t}\n\tInteger port=(Integer)hub.get(RegistrationRequest.PORT);\n\tif(port != null){\n\t\tport=port.intValue();\n\t}\n\tInteger newSessionWait=(Integer)hub.get(\"newSessionMaxWaitTimeInSeconds\");\n\tif(newSessionWait != null){\n\t\tnewSessionWaitTimeout=newSessionWait.intValue() * 1000;\n\t}\n\tallParams.put(RegistrationRequest.MAX_SESSION,1);\n}","public static Resource newResource(String resource) throws MalformedURLException, IOException {\n\tURL url=null;\n\ttry {\n\t\turl=new URL(resource);\n\t} catch (MalformedURLException e){\n\t\tif(!resource.startsWith(\"ftp:\") && !resource.startsWith(\"file:\") && !resource.startsWith(\"jar:\")){\n\t\t\ttry {\n\t\t\t\tif(resource.startsWith(\"./\"))\n\t\t\t\t\tresource=resource.substring(2);\n\t\t\t\tFile file=new File(resource).getCanonicalFile();\n\t\t\t\turl=file.toURI().toURL();\n\t\t\t\tURLConnection connection=url.openConnection();\n\t\t\t\tFileResource fileResource=new FileResource(url,connection,file);\n\t\t\t\treturn fileResource;\n\t\t\t} catch (Exception e2){\n\t\t\t\tlog.debug(LogSupport.EXCEPTION,e2);\n\t\t\t\tthrow e;\n\t\t\t} \n\t\t} else {\n\t\t\tlog.warn(\"Bad Resource: \" + resource);\n\t\t\tthrow e;\n\t\t}\n\t} \n\tString nurl=url.toString();\n\tif(nurl.length() > 0 && nurl.charAt(nurl.length() - 1) != resource.charAt(resource.length() - 1)){\n\t\tif((nurl.charAt(nurl.length() - 1) != '/' || nurl.charAt(nurl.length() - 2) != resource.charAt(resource.length() - 1)) && (resource.charAt(resource.length() - 1) != '/' || resource.charAt(resource.length() - 2) != nurl.charAt(nurl.length() - 1))){\n\t\t\treturn new BadResource(url,\"Trailing special characters stripped by URL in \" + resource);\n\t\t}\n\t}\n\treturn newResource(url);\n}","public String getListHTML(String base,boolean parent) throws IOException {\n\tif(!isDirectory())\n\t\treturn null;\n\tString[] ls=list();\n\tif(ls == null)\n\t\treturn null;\n\tArrays.sort(ls);\n\tString title=\"Directory: \" + URI.decodePath(base);\n\ttitle=StringUtil.replace(StringUtil.replace(title,\"<\",\"&lt;\"),\">\",\"&gt;\");\n\tStringBuffer buf=new StringBuffer(4096);\n\tbuf.append(\"<HTML><HEAD><TITLE>\");\n\tbuf.append(title);\n\tbuf.append(\"<\/TITLE><\/HEAD><BODY>\\n<H1>\");\n\tbuf.append(title);\n\tbuf.append(\"<\/H1><TABLE BORDER=0>\");\n\tif(parent){\n\t\tbuf.append(\"<TR><TD><A HREF=\");\n\t\tbuf.append(URI.encodePath(URI.addPaths(base,\"../\")));\n\t\tbuf.append(\">Parent Directory<\/A><\/TD><TD><\/TD><TD><\/TD><\/TR>\\n\");\n\t}\n\tDateFormat dfmt=DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.MEDIUM);\n\tfor (int i=0; i < ls.length; i++){\n\t\tString encoded=URI.encodePath(ls[i]);\n\t\tResource item=addPath(encoded);\n\t\tbuf.append(\"<TR><TD><A HREF=\\\"\");\n\t\tString path=URI.addPaths(base,encoded);\n\t\tif(item.isDirectory() && !path.endsWith(\"/\"))\n\t\t\tpath=URI.addPaths(path,\"/\");\n\t\tbuf.append(path);\n\t\tbuf.append(\"\\\">\");\n\t\tbuf.append(StringUtil.replace(StringUtil.replace(ls[i],\"<\",\"&lt;\"),\">\",\"&gt;\"));\n\t\tbuf.append(\"&nbsp;\");\n\t\tbuf.append(\"<\/TD><TD ALIGN=right>\");\n\t\tbuf.append(item.length());\n\t\tbuf.append(\" bytes&nbsp;<\/TD><TD>\");\n\t\tbuf.append(dfmt.format(new Date(item.lastModified())));\n\t\tbuf.append(\"<\/TD><\/TR>\\n\");\n\t}\n\tbuf.append(\"<\/TABLE>\\n\");\n\tbuf.append(\"<\/BODY><\/HTML>\\n\");\n\treturn buf.toString();\n}"],"method":0,"correctSolution":0,"doc":"Get a resource from the context. Cached Resources are returned if the resource fits within the LRU cache.  Directories may have CachedResources returned, but the caller must use the CachedResource.setCachedData method to set the formatted directory content.","type":"T1"},"5":{"codes":["protected void scandir(File dir,String vpath,boolean fast){\n\tif(dir == null){\n\t\tthrow new BuildException(\"dir must not be null.\");\n\t} else if(!dir.exists()){\n\t\tthrow new BuildException(dir + \" doesn't exists.\");\n\t} else if(!dir.isDirectory()){\n\t\tthrow new BuildException(dir + \" is not a directory.\");\n\t}\n\tif(fast && hasBeenScanned(vpath)){\n\t\treturn;\n\t}\n\tString[] newfiles=dir.list();\n\tif(!followSymlinks){\n\t\tList<String> noLinks=new ArrayList<String>();\n\t\tfor (int i=0; i < newfiles.length; i++){\n\t\t\ttry {\n\t\t\t\tif(FILE_UTILS.isSymbolicLink(dir,newfiles[i])){\n\t\t\t\t\tString name=vpath + newfiles[i];\n\t\t\t\t\tFile file=new File(dir,newfiles[i]);\n\t\t\t\t\t(file.isDirectory() ? dirsExcluded : filesExcluded).add(name);\n\t\t\t\t} else {\n\t\t\t\t\tnoLinks.add(newfiles[i]);\n\t\t\t\t}\n\t\t\t} catch (IOException ioe){\n\t\t\t\tString msg=\"IOException caught while checking \" + \"for links, couldn't get canonical path!\";\n\t\t\t\tSystem.err.println(msg);\n\t\t\t\tnoLinks.add(newfiles[i]);\n\t\t\t} \n\t\t}\n\t\tnewfiles=noLinks.toArray(new String[noLinks.size()]);\n\t}\n}","public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tString scopedPath=diffUnit.getScopedPath();\n\tfor (Iterator<Pattern> it=excludes.iterator(); it.hasNext(); ){\n\t\tPattern pattern=it.next();\n\t}\n\tboolean leftExists=diffUnit.leftExists();\n\tboolean rightExists=diffUnit.rightExists();\n\tboolean leftIsDir=diffUnit.leftIsDir();\n\tboolean rightIsDir=diffUnit.rightIsDir();\n\tif(leftExists && !rightExists){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Exists in left only\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(rightExists && !leftExists){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Exists in right only\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(leftIsDir != rightIsDir){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Dir/File mismatch\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(!leftIsDir && !rightIsDir){\n\t\tboolean foundHandler=false;\n\t}\n\treturn null;\n}","protected void slowScan(){\n\tsynchronized (slowScanLock){\n\t\tif(haveSlowResults){\n\t\t\treturn;\n\t\t}\n\t\tif(slowScanning){\n\t\t\twhile(slowScanning){\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tslowScanning=true;\n\t}\n\ttry {\n\t} finally {\n\t\tsynchronized (slowScanLock){\n\t\t\thaveSlowResults=true;\n\t\t\tslowScanning=false;\n\t\t\tslowScanLock.notifyAll();\n\t\t}\n\t} \n}","private void checkIncludePatterns(){\n\tHashtable newroots=new Hashtable();\n\tif(newroots.containsKey(\"\")){\n\t} else {\n\t\tEnumeration enum2=newroots.keys();\n\t\tFile canonBase=null;\n\t\ttry {\n\t\t\tcanonBase=basedir.getCanonicalFile();\n\t\t} catch (IOException ex){\n\t\t\tthrow new BuildException(ex);\n\t\t} \n\t\twhile(enum2.hasMoreElements()){\n\t\t\tString currentelement=(String)enum2.nextElement();\n\t\t\tString originalpattern=(String)newroots.get(currentelement);\n\t\t\tFile myfile=new File(basedir,currentelement);\n\t\t\tif(myfile.exists()){\n\t\t\t\ttry {\n\t\t\t\t\tFile canonFile=myfile.getCanonicalFile();\n\t\t\t\t\tString path=FILE_UTILS.removeLeadingPath(canonBase,canonFile);\n\t\t\t\t} catch (IOException ex){\n\t\t\t\t\tthrow new BuildException(ex);\n\t\t\t\t} \n\t\t\t}\n\t\t\tif((myfile == null || !myfile.exists()) && !isCaseSensitive()){\n\t\t\t\tFile f=findFile(basedir,currentelement,false);\n\t\t\t\tif(f != null && f.exists()){\n\t\t\t\t\tcurrentelement=FILE_UTILS.removeLeadingPath(basedir,f);\n\t\t\t\t\tmyfile=f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(myfile != null && myfile.exists()){\n\t\t\t}\n\t\t}\n\t}\n}","public void scan() throws IllegalStateException {\n\tsynchronized (scanLock){\n\t\tif(scanning){\n\t\t\twhile(scanning){\n\t\t\t\ttry {\n\t\t\t\t\tscanLock.wait();\n\t\t\t\t} catch (InterruptedException e){\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tscanning=true;\n\t}\n\ttry {\n\t\tsynchronized (this){\n\t\t\tillegal=null;\n\t\t\tclearResults();\n\t\t\tif(illegal != null){\n\t\t\t\tthrow illegal;\n\t\t\t}\n\t\t\tcheckIncludePatterns();\n\t\t\tclearCaches();\n\t\t}\n\t} finally {\n\t\tsynchronized (scanLock){\n\t\t\tscanning=false;\n\t\t\tscanLock.notifyAll();\n\t\t}\n\t} \n}"],"method":1,"correctSolution":0,"doc":"Scan the given directory for files and directories. Found files and directories are placed in their respective collections, based on the matching of includes, excludes, and the selectors.  When a directory is found, it is scanned recursively.","type":"T1"},"6":{"codes":["protected void doSAX(Node node) throws ParserException, SAXException {\n\tTag tag;\n\tif(node instanceof Remark){\n\t\tString text=mParser.getLexer().getPage().getText(node.getStartPosition(),node.getEndPosition());\n\t\tmContentHandler.ignorableWhitespace(text.toCharArray(),0,text.length());\n\t} else if(node instanceof Text){\n\t\tString text=mParser.getLexer().getPage().getText(node.getStartPosition(),node.getEndPosition());\n\t\ttext=Translate.decode(text);\n\t\tmContentHandler.characters(text.toCharArray(),0,text.length());\n\t} else if(node instanceof Tag){\n\t\tif(mNameSpacePrefixes)\n\t\telse if(mNameSpaces)\n\t\telse \n\t\tNodeList children=tag.getChildren();\n\t\tif(null != children)\n\t\t\tfor (int i=0; i < children.size(); i++)\n\t\t\t\tdoSAX(children.elementAt(i));\n\t\tif(null != end){\n\t\t\tif(mNameSpacePrefixes)\n\t\t\t\tmParts[2]=end.getTagName();\n\t\t\telse if(mNameSpaces)\n\t\t\telse \n\t\t\t\tmParts[2]=end.getTagName();\n\t\t\tmContentHandler.endElement(mParts[0],mParts[1],mParts[2]);\n\t\t}\n\t}\n}","public static void main(String[] argv) throws IOException, SAXException {\n\tint optind=getopts(options,argv);\n\tif(hasOption(options,\"--help\")){\n\t\treturn;\n\t}\n\tif(hasOption(options,\"--version\")){\n\t\treturn;\n\t}\n\tif(argv.length == optind){\n\t} else if(hasOption(options,\"--files\")){\n\t\tfor (int i=optind; i < argv.length; i++){\n\t\t\tString src=argv[i];\n\t\t\tString dst;\n\t\t\tint j=src.lastIndexOf('.');\n\t\t\tOutputStream os=new FileOutputStream(dst);\n\t\t}\n\t} else {\n\t\tfor (int i=optind; i < argv.length; i++){\n\t\t}\n\t}\n}","protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tbookmark=mPages.size();\n\t\ttry {\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(0 != robots.size()){\n\t\t\trobot=(MetaTag)robots.elementAt(0);\n\t\t\tcontent=robot.getAttribute(\"content\").toLowerCase();\n\t\t\tif((-1 != content.indexOf(\"none\")) || (-1 != content.indexOf(\"nofollow\")))\n\t\t\t\tfor (int i=bookmark; i < mPages.size(); i++)\n\t\t}\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t\tif(!dir.exists())\n\t\t\tdir.mkdirs();\n\t\telse if(!dir.isDirectory()){\n\t\t\tdir=new File(dir.getParentFile(),dir.getName() + \".content\");\n\t\t\tfile=new File(dir,file.getName());\n\t\t}\n\t\ttry {\n\t\t\tfor (int i=0; i < list.size(); i++)\n\t\t} catch (FileNotFoundException fnfe){\n\t\t} \n\t} catch (ParserException pe){\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}","protected Node parsePI(int start) throws ParserException {\n\tboolean done;\n\tchar ch;\n\tint state;\n\tVector attributes;\n\tint code;\n\tstate=0;\n\tcode=0;\n\tattributes=new Vector();\n\twhile(!done){\n\t\tch=mPage.getCharacter(mCursor);\n\t\tswitch (state){\n\t\tcase 0: \n\t\t\tswitch (ch){\n\t\t\tcase '?': \n\t\t\t\tcode=mCursor.getPosition();\n\t\t\t\tattributes.addElement(new PageAttribute(mPage,start + 1,code,-1,-1,(char)0));\n\t\t\t\tstate=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tswitch (ch){\n\t\t\tcase Page.EOF: \n\t\t\tcase '>': \n\t\t\tcase '\\'': \n\t\t\tcase '\"': \n\t\t\tcase '?': \n\t\t\t}\n\t\tcase 2: \n\t\t\tswitch (ch){\n\t\t\tcase Page.EOF: \n\t\t\t\tbreak;\n\t\t\tcase '>': \n\t\t\t}\n\t\tcase '\"': \n\t\t\tswitch (ch){\n\t\t\tcase Page.EOF: \n\t\t\t\tbreak;\n\t\t\tcase '\"': \n\t\t\t}\n\t\tcase '\\'': \n\t\t\tswitch (ch){\n\t\t\tcase Page.EOF: \n\t\t\t\tbreak;\n\t\t\tcase '\\'': \n\t\t\t}\n\t\t}\n\t}\n\treturn (makeTag(start,mCursor.getPosition(),attributes));\n}","public void run(){\n\tURL link;\n\tint original;\n\tint index;\n\tString href;\n\tURL[][] urls;\n\twhile(true){\n\t\ttry {\n\t\t\tsynchronized (mUrls){\n\t\t\t}\n\t\t\tif(null != link){\n\t\t\t\tupdateQueueSize(original,mUrls.size());\n\t\t\t\tsetCurrentURL(href);\n\t\t\t\tmVisited.put(href,link);\n\t\t\t\tupdateVisitedSize(mVisited.size() - 1,mVisited.size());\n\t\t\t\turls=getImageLinks(link);\n\t\t\t\tfetch(urls[0]);\n\t\t\t} else \n\t\t\tif(!mActive)\n\t\t} catch (Throwable t){\n\t\t} \n\t}\n}"],"method":2,"correctSolution":4,"doc":"The main processing loop. Pull suspect URLs off the queue one at a time, fetch and parse it, request images and enqueue further links.","type":"T1"},"7":{"codeB":"@Override protected Socket _openDataConnection_(int command,String arg) throws IOException {\n\tSocket socket=super._openDataConnection_(command,arg);\n\t_prepareDataSocket_(socket);\n\tif(socket instanceof SSLSocket){\n\t\tSSLSocket sslSocket=(SSLSocket)socket;\n\t\tsslSocket.setUseClientMode(isClientMode);\n\t\tsslSocket.setEnableSessionCreation(isCreation);\n\t\tif(!isClientMode){\n\t\t\tsslSocket.setNeedClientAuth(isNeedClientAuth);\n\t\t\tsslSocket.setWantClientAuth(isWantClientAuth);\n\t\t}\n\t\tif(suites != null){\n\t\t\tsslSocket.setEnabledCipherSuites(suites);\n\t\t}\n\t\tif(protocols != null){\n\t\t\tsslSocket.setEnabledProtocols(protocols);\n\t\t}\n\t\tsslSocket.startHandshake();\n\t}\n\treturn socket;\n}","codeA":"protected Socket _openDataConnection_(String command,String arg) throws IOException {\n\tif(__dataConnectionMode != ACTIVE_LOCAL_DATA_CONNECTION_MODE && __dataConnectionMode != PASSIVE_LOCAL_DATA_CONNECTION_MODE){\n\t\treturn null;\n\t}\n\tfinal boolean isInet6Address=getRemoteAddress() instanceof Inet6Address;\n\tSocket socket;\n\tif(__dataConnectionMode == ACTIVE_LOCAL_DATA_CONNECTION_MODE){\n\t\tServerSocket server=_serverSocketFactory_.createServerSocket(getActivePort(),1,getHostAddress());\n\t\ttry {\n\t\t\tif(isInet6Address){\n\t\t\t\tif(!FTPReply.isPositiveCompletion(eprt(getReportHostAddress(),server.getLocalPort()))){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(!FTPReply.isPositiveCompletion(port(getReportHostAddress(),server.getLocalPort()))){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif((__restartOffset > 0) && !restart(__restartOffset)){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!FTPReply.isPositivePreliminary(sendCommand(command,arg))){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(__dataTimeout >= 0){\n\t\t\t\tserver.setSoTimeout(__dataTimeout);\n\t\t\t}\n\t\t\tsocket=server.accept();\n\t\t} finally {\n\t\t\tserver.close();\n\t\t} \n\t} else {\n\t\tboolean attemptEPSV=isUseEPSVwithIPv4() || isInet6Address;\n\t\tif(attemptEPSV && epsv() == FTPReply.ENTERING_EPSV_MODE){\n\t\t\t_parseExtendedPassiveModeReply(_replyLines.get(0));\n\t\t} else {\n\t\t\tif(isInet6Address){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(pasv() != FTPReply.ENTERING_PASSIVE_MODE){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t_parsePassiveModeReply(_replyLines.get(0));\n\t\t}\n\t\tsocket=_socketFactory_.createSocket();\n\t\tsocket.connect(new InetSocketAddress(__passiveHost,__passivePort),connectTimeout);\n\t\tif((__restartOffset > 0) && !restart(__restartOffset)){\n\t\t\tsocket.close();\n\t\t\treturn null;\n\t\t}\n\t\tif(!FTPReply.isPositivePreliminary(sendCommand(command,arg))){\n\t\t\tsocket.close();\n\t\t\treturn null;\n\t\t}\n\t}\n\tif(__remoteVerificationEnabled && !verifyRemote(socket)){\n\t\tsocket.close();\n\t\tthrow new IOException(\"Host attempting data connection \" + socket.getInetAddress().getHostAddress() + \" is not same as server \"+ getRemoteAddress().getHostAddress());\n\t}\n\tif(__dataTimeout >= 0){\n\t\tsocket.setSoTimeout(__dataTimeout);\n\t}\n\treturn socket;\n}","method":0,"docB":"Returns a socket of the data connection. Wrapped as an SSLSocket, which carries out handshake processing.","docA":"Establishes a data connection with the FTP server, returning a Socket for the connection if successful.  If a restart offset has been set with setRestartOffset(long), a REST command is issued to the server with the offset as an argument before establishing the data connection.  Active mode connections also cause a local PORT command to be issued.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"8":{"codeB":"@Override protected char[] escape(int cp){\n\tif(cp < safeOctets.length && safeOctets[cp]){\n\t} else if(cp == ' ' && plusForSpace){\n\t} else if(cp <= 0x7F){\n\t} else if(cp <= 0x7ff){\n\t\tchar[] dest=new char[6];\n\t\tdest[0]='%';\n\t\tdest[3]='%';\n\t\tdest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[1]=UPPER_HEX_DIGITS[0xC | cp];\n\t\treturn dest;\n\t} else if(cp <= 0xffff){\n\t\tchar[] dest=new char[9];\n\t\tdest[0]='%';\n\t\tdest[1]='E';\n\t\tdest[3]='%';\n\t\tdest[6]='%';\n\t\tdest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[2]=UPPER_HEX_DIGITS[cp];\n\t} else \n}","codeA":"protected final String escapeSlow(String s,int index){\n\tint end=s.length();\n\tchar[] dest=DEST_TL.get();\n\tint destIndex=0;\n\tint unescapedChunkStart=0;\n\twhile(index < end){\n\t\tint cp=codePointAt(s,index,end);\n\t\tif(cp < 0){\n\t\t\tthrow new IllegalArgumentException(\"Trailing high surrogate at end of input\");\n\t\t}\n\t\tchar[] escaped=escape(cp);\n\t\tunescapedChunkStart=index + (Character.isSupplementaryCodePoint(cp) ? 2 : 1);\n\t}\n\tint charsSkipped=end - unescapedChunkStart;\n\tif(charsSkipped > 0){\n\t\tint endIndex=destIndex + charsSkipped;\n\t\ts.getChars(unescapedChunkStart,end,dest,destIndex);\n\t\tdestIndex=endIndex;\n\t}\n\treturn new String(dest,0,destIndex);\n}","method":1,"docB":"Escapes the given Unicode code point in UTF-8.","docA":"Returns the escaped form of a given literal string, starting at the given index. It is protected to allow subclasses to override the fastpath escaping function to inline their escaping test.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"9":{"codeB":"public void submit(String buttonName,String buttonValue){\n\tList<HtmlElement> l=new LinkedList<HtmlElement>();\n\ttry {\n\t\tfor (int i=0; i < l.size(); i++){\n\t\t\tObject o=l.get(i);\n\t\t\tif(o instanceof HtmlSubmitInput){\n\t\t\t\tHtmlSubmitInput inpt=(HtmlSubmitInput)o;\n\t\t\t\tif(inpt.getValueAttribute().equals(buttonValue)){\n\t\t\t\t\tinpt.click();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(o instanceof HtmlButton){\n\t\t\t\tHtmlButton inpt=(HtmlButton)o;\n\t\t\t\tif(inpt.getTypeAttribute().equals(\"submit\") && inpt.getValueAttribute().equals(buttonValue)){\n\t\t\t\t\tinpt.click();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (FailingHttpStatusCodeException e){\n\t} catch (IOException e){\n\t} \n}","codeA":"public Page submit(final SubmittableElement submitElement) throws IOException {\n\tfinal HtmlPage htmlPage=(HtmlPage)getPage();\n\tfinal List<NameValuePair> parameters=getParameterListForSubmit(submitElement);\n\tfinal HttpMethod method;\n\tfinal String methodAttribute=getMethodAttribute();\n\tString actionUrl=getActionAttribute();\n\tif(HttpMethod.GET == method){\n\t\tfinal String anchor=StringUtils.substringAfter(actionUrl,\"#\");\n\t\tactionUrl=StringUtils.substringBefore(actionUrl,\"#\");\n\t\tfinal NameValuePair[] pairs=new NameValuePair[parameters.size()];\n\t\tparameters.toArray(pairs);\n\t\tfinal String queryFromFields=EncodingUtil.formUrlEncode(pairs,getPage().getPageEncoding());\n\t\tactionUrl=StringUtils.substringBefore(actionUrl,\"?\");\n\t\tfinal BrowserVersion browserVersion=getPage().getWebClient().getBrowserVersion();\n\t\tparameters.clear();\n\t}\n\tfinal URL url;\n\ttry {\n\t\tif(actionUrl.length() == 0){\n\t\t\turl=htmlPage.getWebResponse().getRequestSettings().getUrl();\n\t\t} else if(actionUrl.startsWith(\"?\")){\n\t\t\tString urlString=htmlPage.getWebResponse().getRequestSettings().getUrl().toExternalForm();\n\t\t\tif(urlString.indexOf('?') != -1){\n\t\t\t\turlString=urlString.substring(0,urlString.indexOf('?'));\n\t\t\t}\n\t\t\turl=new URL(urlString + actionUrl);\n\t\t} else {\n\t\t\turl=htmlPage.getFullyQualifiedUrl(actionUrl);\n\t\t}\n\t} catch (final MalformedURLException e){\n\t} \n\tfinal WebRequestSettings settings=new WebRequestSettings(url,method);\n\tsettings.setRequestParameters(parameters);\n\tsettings.setEncodingType(FormEncodingType.getInstance(getEnctypeAttribute()));\n\tsettings.setCharset(getSubmitCharset());\n\tsettings.setAdditionalHeader(\"Referer\",htmlPage.getWebResponse().getRequestSettings().getUrl().toExternalForm());\n\tfinal WebWindow webWindow=htmlPage.getEnclosingWindow();\n\treturn htmlPage.getWebClient().getPage(webWindow,htmlPage.getResolvedTarget(getTargetAttribute()),settings);\n}","method":2,"docB":"Submit this form to the server. If parameter is null, then the submission is treated as if it was triggered by JavaScript, and the onsubmit handler will not be executed.","docA":"Submit the current form with the specifed submit button.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]},"20":{"code_mymethod":{"r10":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","r20":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","r50%":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPDataPacket data;\n\tbeginBufferedOps();\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\t\t\t\twhile(true){\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treceived=bufferedReceive();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} catch (SocketException e){\n\t\t\t\t\t\t} catch (InterruptedIOException e){\n\t\t\t\t\t\t} catch (TFTPPacketException e){\n\t\t\t\t\t\t} \n\t\t\t\t\t}while(timeouts < __maxTimeouts)\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tif(lastBlock == block){\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\toutput.write(data.getData(),data.getDataOffset(),dataLength);\n\t\t\t\t\t\t\t\t} catch (IOException e){\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t++block;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiscardPackets();\n\t\t\t\t\t\t\t\tcontinue _receivePacket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}"},"code_native":{"r10":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tbufferedSend(sent);\n\treturn bytesRead;\n}","r20":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","r50%":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\t\t\t\twhile(true){\n\t\t\t\t\ttimeouts=0;\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tdata=(TFTPDataPacket)received;\n\t\t\t\t\t\t\tdataLength=data.getDataLength();\n\t\t\t\t\t\t\tlastBlock=data.getBlockNumber();\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Received unexpected packet type.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror=new TFTPErrorPacket(received.getAddress(),received.getPort(),TFTPErrorPacket.UNKNOWN_TID,\"Unexpected host or port.\");\n\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}"},"method":0,"code_original":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tif(mode == TFTP.ASCII_MODE){\n\t\toutput=new FromNetASCIIOutputStream(output);\n\t}\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket:\n :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket:\n :\n\t\t\t\twhile(true){\n\t\t\t\t\ttimeouts=0;\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treceived=bufferedReceive();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} catch (SocketException e){\n\t\t\t\t\t\t\tif(++timeouts >= __maxTimeouts){\n\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\tthrow new IOException(\"Connection timed out.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t} catch (InterruptedIOException e){\n\t\t\t\t\t\t\tif(++timeouts >= __maxTimeouts){\n\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\tthrow new IOException(\"Connection timed out.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t} catch (TFTPPacketException e){\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Bad packet: \" + e.getMessage());\n\t\t\t\t\t\t} \n\t\t\t\t\t}while(timeouts < __maxTimeouts)\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tdata=(TFTPDataPacket)received;\n\t\t\t\t\t\t\tdataLength=data.getDataLength();\n\t\t\t\t\t\t\tlastBlock=data.getBlockNumber();\n\t\t\t\t\t\t\tif(lastBlock == block){\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\toutput.write(data.getData(),data.getDataOffset(),dataLength);\n\t\t\t\t\t\t\t\t} catch (IOException e){\n\t\t\t\t\t\t\t\t\terror=new TFTPErrorPacket(host,hostPort,TFTPErrorPacket.OUT_OF_SPACE,\"File write failed.\");\n\t\t\t\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t++block;\n\t\t\t\t\t\t\t\tif(block > 65535){\n\t\t\t\t\t\t\t\t\tblock=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak _receivePacket;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiscardPackets();\n\t\t\t\t\t\t\t\tif(lastBlock == (block == 0 ? 65535 : (block - 1))){\n\t\t\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue _receivePacket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Received unexpected packet type.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror=new TFTPErrorPacket(received.getAddress(),received.getPort(),TFTPErrorPacket.UNKNOWN_TID,\"Unexpected host or port.\");\n\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","type":"T3"},"10":{"codeB":"public static MultivaluedMap<String,String> getEntityParameters(ClientRequest request,Providers providers){\n\tObject entity=request.getEntity();\n\tString method=request.getMethod();\n\tMediaType mediaType=getMediaType(request);\n\tif(entity == null || method == null || !method.equalsIgnoreCase(\"POST\") || mediaType == null || !mediaType.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE)){\n\t\treturn new MultivaluedMapImpl();\n\t}\n\tif(entity instanceof MultivaluedMap){\n\t\treturn (MultivaluedMap)entity;\n\t}\n\tType entityType=entity.getClass();\n\tif(entity instanceof GenericEntity){\n\t\tfinal GenericEntity generic=(GenericEntity)entity;\n\t\tentityType=generic.getType();\n\t\tentity=generic.getEntity();\n\t}\n\tfinal Class entityClass=entity.getClass();\n\tByteArrayOutputStream out=new ByteArrayOutputStream();\n\tMessageBodyWriter writer=providers.getMessageBodyWriter(entityClass,entityType,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE);\n\ttry {\n\t\twriter.writeTo(entity,entityClass,entityType,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE,null,out);\n\t} catch (WebApplicationException wae){\n\t\tthrow new IllegalStateException(wae);\n\t} catch (IOException ioe){\n\t\tthrow new IllegalStateException(ioe);\n\t} \n\tByteArrayInputStream in=new ByteArrayInputStream(out.toByteArray());\n\tMessageBodyReader reader=providers.getMessageBodyReader(MultivaluedMap.class,MultivaluedMap.class,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE);\n\ttry {\n\t\treturn (MultivaluedMap<String,String>)reader.readFrom(MultivaluedMap.class,MultivaluedMap.class,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE,null,in);\n\t} catch (IOException ioe){\n\t\tthrow new IllegalStateException(ioe);\n\t} \n}","codeA":"protected SortedMap<String,SortedSet<String>> loadSignificantParametersForSignatureBaseString(HttpServletRequest request){\n\tSortedMap<String,SortedSet<String>> significantParameters=new TreeMap<String,SortedSet<String>>();\n\tEnumeration parameterNames=request.getParameterNames();\n\twhile(parameterNames.hasMoreElements()){\n\t\tString parameterName=(String)parameterNames.nextElement();\n\t\tString[] values=request.getParameterValues(parameterName);\n\t\tif(values == null){\n\t\t\tvalues=new String[]{\"\"};\n\t\t}\n\t\tfor (String parameterValue : values){\n\t\t\tif(parameterValue == null){\n\t\t\t\tparameterValue=\"\";\n\t\t\t}\n\t\t\tparameterName=oauthEncode(parameterName);\n\t\t\tparameterValue=oauthEncode(parameterValue);\n\t\t\tSortedSet<String> significantValues=significantParameters.get(parameterName);\n\t\t\tif(significantValues == null){\n\t\t\t\tsignificantValues=new TreeSet<String>();\n\t\t\t\tsignificantParameters.put(parameterName,significantValues);\n\t\t\t}\n\t\t\tsignificantValues.add(parameterValue);\n\t\t}\n\t}\n\tMap<String,String> oauthParams=parseParameters(request);\n\toauthParams.remove(\"realm\");\n\tSet<String> parsedParams=oauthParams.keySet();\n\tfor (String parameterName : parsedParams){\n\t\tString parameterValue=oauthParams.get(parameterName);\n\t\tif(parameterValue == null){\n\t\t\tparameterValue=\"\";\n\t\t}\n\t\tparameterName=oauthEncode(parameterName);\n\t\tparameterValue=oauthEncode(parameterValue);\n\t\tSortedSet<String> significantValues=significantParameters.get(parameterName);\n\t\tif(significantValues == null){\n\t\t\tsignificantValues=new TreeSet<String>();\n\t\t\tsignificantParameters.put(parameterName,significantValues);\n\t\t}\n\t\tsignificantValues.add(parameterValue);\n\t}\n\tsignificantParameters.remove(OAuthConsumerParameter.oauth_signature.toString());\n\treturn significantParameters;\n}","method":0,"docB":"Gets the parameters (name-to-value map) that are to be used to calculate the signature base string. The parameters will be encoded by oauthEncode method.","docA":"Gets the parameters from a request as a map. If the request does not have a POST method, or the media type is not x-www-form-urlencoded, then null is returned.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Mehtod B mactches Description B.","Method A mactches Description B, Mehtod A mactches Description B.","Impossible to decide."]}}}