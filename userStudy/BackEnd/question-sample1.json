{"sampleIndex":1,"questions":{"11":{"codeB":"@Override protected Socket _openDataConnection_(int command,String arg) throws IOException {\n\tSocket socket=super._openDataConnection_(command,arg);\n\t_prepareDataSocket_(socket);\n\tif(socket instanceof SSLSocket){\n\t\tSSLSocket sslSocket=(SSLSocket)socket;\n\t\tsslSocket.setUseClientMode(isClientMode);\n\t\tsslSocket.setEnableSessionCreation(isCreation);\n\t\tif(!isClientMode){\n\t\t\tsslSocket.setNeedClientAuth(isNeedClientAuth);\n\t\t\tsslSocket.setWantClientAuth(isWantClientAuth);\n\t\t}\n\t\tif(suites != null){\n\t\t\tsslSocket.setEnabledCipherSuites(suites);\n\t\t}\n\t\tif(protocols != null){\n\t\t\tsslSocket.setEnabledProtocols(protocols);\n\t\t}\n\t\tsslSocket.startHandshake();\n\t}\n\treturn socket;\n}","practice":false,"codeA":"protected Socket _openDataConnection_(String command,String arg) throws IOException {\n\tif(__dataConnectionMode != ACTIVE_LOCAL_DATA_CONNECTION_MODE && __dataConnectionMode != PASSIVE_LOCAL_DATA_CONNECTION_MODE){\n\t\treturn null;\n\t}\n\tfinal boolean isInet6Address=getRemoteAddress() instanceof Inet6Address;\n\tSocket socket;\n\tif(__dataConnectionMode == ACTIVE_LOCAL_DATA_CONNECTION_MODE){\n\t\tServerSocket server=_serverSocketFactory_.createServerSocket(getActivePort(),1,getHostAddress());\n\t\ttry {\n\t\t\tif(isInet6Address){\n\t\t\t\tif(!FTPReply.isPositiveCompletion(eprt(getReportHostAddress(),server.getLocalPort()))){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(!FTPReply.isPositiveCompletion(port(getReportHostAddress(),server.getLocalPort()))){\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif((__restartOffset > 0) && !restart(__restartOffset)){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!FTPReply.isPositivePreliminary(sendCommand(command,arg))){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(__dataTimeout >= 0){\n\t\t\t\tserver.setSoTimeout(__dataTimeout);\n\t\t\t}\n\t\t\tsocket=server.accept();\n\t\t} finally {\n\t\t\tserver.close();\n\t\t} \n\t} else {\n\t\tboolean attemptEPSV=isUseEPSVwithIPv4() || isInet6Address;\n\t\tif(attemptEPSV && epsv() == FTPReply.ENTERING_EPSV_MODE){\n\t\t\t_parseExtendedPassiveModeReply(_replyLines.get(0));\n\t\t} else {\n\t\t\tif(isInet6Address){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(pasv() != FTPReply.ENTERING_PASSIVE_MODE){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t_parsePassiveModeReply(_replyLines.get(0));\n\t\t}\n\t\tsocket=_socketFactory_.createSocket();\n\t\tsocket.connect(new InetSocketAddress(__passiveHost,__passivePort),connectTimeout);\n\t\tif((__restartOffset > 0) && !restart(__restartOffset)){\n\t\t\tsocket.close();\n\t\t\treturn null;\n\t\t}\n\t\tif(!FTPReply.isPositivePreliminary(sendCommand(command,arg))){\n\t\t\tsocket.close();\n\t\t\treturn null;\n\t\t}\n\t}\n\tif(__remoteVerificationEnabled && !verifyRemote(socket)){\n\t\tsocket.close();\n\t\tthrow new IOException(\"Host attempting data connection \" + socket.getInetAddress().getHostAddress() + \" is not same as server \"+ getRemoteAddress().getHostAddress());\n\t}\n\tif(__dataTimeout >= 0){\n\t\tsocket.setSoTimeout(__dataTimeout);\n\t}\n\treturn socket;\n}","method":0,"docB":"Returns a socket of the data connection. Wrapped as an SSLSocket, which carries out handshake processing.","docA":"Establishes a data connection with the FTP server, returning a Socket for the connection if successful.  If a restart offset has been set with setRestartOffset(long), a REST command is issued to the server with the offset as an argument before establishing the data connection.  Active mode connections also cause a local PORT command to be issued.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"22":{"code_mymethod":{"r15":"private void combineMultisegmentNames(boolean keepConsistentOnFailure) throws ParseException {\n\ttry {\n\t\twhile(it.hasNext()){\n\t\t\tString name=(String)it.next();\n\t\t\tfor (segment=0; ; segment++){\n\t\t\t\tObject v=slist.get(sname);\n\t\t\t\tString value=null;\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tif(keepConsistentOnFailure || success){\n\t\t\tif(slist.size() > 0){\n\t\t\t\twhile(sit.hasNext()){\n\t\t\t\t\tObject v=sit.next();\n\t\t\t\t\tif(v instanceof Value){\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}","r50%":"private void combineMultisegmentNames(boolean keepConsistentOnFailure) throws ParseException {\n\ttry {\n\t\tIterator it=multisegmentNames.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tString name=(String)it.next();\n\t\t\tStringBuffer sb=new StringBuffer();\n\t\t\tMultiValue mv=new MultiValue();\n\t\t\tString charset=null;\n\t\t\tint segment;\n\t\t\tfor (segment=0; ; segment++){\n\t\t\t\tString sname=name + \"*\" + segment;\n\t\t\t\tObject v=slist.get(sname);\n\t\t\t\tString value=null;\n\t\t\t\tif(v instanceof Value){\n\t\t\t\t\ttry {\n\t\t\t\t\t\tValue vv=(Value)v;\n\t\t\t\t\t\tString evalue=vv.encodedValue;\n\t\t\t\t\t\tvalue=evalue;\n\t\t\t\t\t} catch (NumberFormatException nex){\n\t\t\t\t\t} catch (UnsupportedEncodingException uex){\n\t\t\t\t\t} catch (StringIndexOutOfBoundsException ex){\n\t\t\t\t\t} \n\t\t\t\t} else {\n\t\t\t\t\tvalue=(String)v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tif(keepConsistentOnFailure || success){\n\t\t\tif(slist.size() > 0){\n\t\t\t\tIterator sit=slist.values().iterator();\n\t\t\t\twhile(sit.hasNext()){\n\t\t\t\t\tObject v=sit.next();\n\t\t\t\t\tif(v instanceof Value){\n\t\t\t\t\t\tValue vv=(Value)v;\n\t\t\t\t\t\tValue vnew=decodeValue(vv.encodedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.putAll(slist);\n\t\t\t}\n\t\t\tslist.clear();\n\t\t}\n\t} \n}","r30":"private void combineMultisegmentNames(boolean keepConsistentOnFailure) throws ParseException {\n\ttry {\n\t\tIterator it=multisegmentNames.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tString name=(String)it.next();\n\t\t\tStringBuffer sb=new StringBuffer();\n\t\t\tMultiValue mv=new MultiValue();\n\t\t\tString charset=null;\n\t\t\tint segment;\n\t\t\tfor (segment=0; ; segment++){\n\t\t\t\tObject v=slist.get(sname);\n\t\t\t\tString value=null;\n\t\t\t\tif(v instanceof Value){\n\t\t\t\t\ttry {\n\t\t\t\t\t\tValue vv=(Value)v;\n\t\t\t\t\t\tString evalue=vv.encodedValue;\n\t\t\t\t\t\tvalue=evalue;\n\t\t\t\t\t} catch (NumberFormatException nex){\n\t\t\t\t\t} catch (UnsupportedEncodingException uex){\n\t\t\t\t\t} catch (StringIndexOutOfBoundsException ex){\n\t\t\t\t\t} \n\t\t\t\t} else {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tif(keepConsistentOnFailure || success){\n\t\t\tif(slist.size() > 0){\n\t\t\t\twhile(sit.hasNext()){\n\t\t\t\t\tObject v=sit.next();\n\t\t\t\t\tif(v instanceof Value){\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}"},"code_native":{"r15":"private void combineMultisegmentNames(boolean keepConsistentOnFailure) throws ParseException {\n\tboolean success=false;\n\ttry {\n\t\tIterator it=multisegmentNames.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tString name=(String)it.next();\n\t\t\tStringBuffer sb=new StringBuffer();\n\t\t\tMultiValue mv=new MultiValue();\n\t\t\tString charset=null;\n\t\t\tint segment;\n\t\t}\n\t} finally {\n\t\tif(keepConsistentOnFailure || success){\n\t\t\tmultisegmentNames.clear();\n\t\t\tslist.clear();\n\t\t}\n\t} \n}","r50%":"private void combineMultisegmentNames(boolean keepConsistentOnFailure) throws ParseException {\n\tboolean success=false;\n\ttry {\n\t\tIterator it=multisegmentNames.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tString name=(String)it.next();\n\t\t\tStringBuffer sb=new StringBuffer();\n\t\t\tMultiValue mv=new MultiValue();\n\t\t\tint segment;\n\t\t\tfor (segment=0; ; segment++){\n\t\t\t\tString sname=name + \"*\" + segment;\n\t\t\t\tObject v=slist.get(sname);\n\t\t\t\tif(v == null)\n\t\t\t\t\tbreak;\n\t\t\t\tmv.add(v);\n\t\t\t\tString value=null;\n\t\t\t\tsb.append(value);\n\t\t\t\tslist.remove(sname);\n\t\t\t}\n\t\t}\n\t\tsuccess=true;\n\t} finally {\n\t\tif(keepConsistentOnFailure || success){\n\t\t\tif(slist.size() > 0){\n\t\t\t\tIterator sit=slist.values().iterator();\n\t\t\t\twhile(sit.hasNext()){\n\t\t\t\t\tObject v=sit.next();\n\t\t\t\t\tif(v instanceof Value){\n\t\t\t\t\t\tValue vv=(Value)v;\n\t\t\t\t\t\tValue vnew=decodeValue(vv.encodedValue);\n\t\t\t\t\t\tvv.value=vnew.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.putAll(slist);\n\t\t\t}\n\t\t\tmultisegmentNames.clear();\n\t\t\tslist.clear();\n\t\t}\n\t} \n}","r30":"private void combineMultisegmentNames(boolean keepConsistentOnFailure) throws ParseException {\n\tboolean success=false;\n\ttry {\n\t\tIterator it=multisegmentNames.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tString name=(String)it.next();\n\t\t\tStringBuffer sb=new StringBuffer();\n\t\t\tMultiValue mv=new MultiValue();\n\t\t\tString charset=null;\n\t\t\tint segment;\n\t\t\tfor (segment=0; ; segment++){\n\t\t\t\tString sname=name + \"*\" + segment;\n\t\t\t\tObject v=slist.get(sname);\n\t\t\t\tif(v == null)\n\t\t\t\t\tbreak;\n\t\t\t\tmv.add(v);\n\t\t\t\tString value=null;\n\t\t\t\tsb.append(value);\n\t\t\t\tslist.remove(sname);\n\t\t\t}\n\t\t}\n\t\tsuccess=true;\n\t} finally {\n\t\tif(keepConsistentOnFailure || success){\n\t\t\tif(slist.size() > 0){\n\t\t\t\tIterator sit=slist.values().iterator();\n\t\t\t\tlist.putAll(slist);\n\t\t\t}\n\t\t\tmultisegmentNames.clear();\n\t\t\tslist.clear();\n\t\t}\n\t} \n}"},"method":1,"code_original":"private void combineMultisegmentNames(boolean keepConsistentOnFailure) throws ParseException {\n\tboolean success=false;\n\ttry {\n\t\tIterator it=multisegmentNames.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tString name=(String)it.next();\n\t\t\tStringBuffer sb=new StringBuffer();\n\t\t\tMultiValue mv=new MultiValue();\n\t\t\tString charset=null;\n\t\t\tint segment;\n\t\t\tfor (segment=0; ; segment++){\n\t\t\t\tString sname=name + \"*\" + segment;\n\t\t\t\tObject v=slist.get(sname);\n\t\t\t\tif(v == null)\n\t\t\t\t\tbreak;\n\t\t\t\tmv.add(v);\n\t\t\t\tString value=null;\n\t\t\t\tif(v instanceof Value){\n\t\t\t\t\ttry {\n\t\t\t\t\t\tValue vv=(Value)v;\n\t\t\t\t\t\tString evalue=vv.encodedValue;\n\t\t\t\t\t\tvalue=evalue;\n\t\t\t\t\t\tif(segment == 0){\n\t\t\t\t\t\t\tValue vnew=decodeValue(evalue);\n\t\t\t\t\t\t\tcharset=vv.charset=vnew.charset;\n\t\t\t\t\t\t\tvalue=vv.value=vnew.value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(charset == null){\n\t\t\t\t\t\t\t\tmultisegmentNames.remove(name);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalue=vv.value=decodeBytes(evalue,charset);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (NumberFormatException nex){\n\t\t\t\t\t\tif(decodeParametersStrict)\n\t\t\t\t\t\t\tthrow new ParseException(nex.toString());\n\t\t\t\t\t} catch (UnsupportedEncodingException uex){\n\t\t\t\t\t\tif(decodeParametersStrict)\n\t\t\t\t\t\t\tthrow new ParseException(uex.toString());\n\t\t\t\t\t} catch (StringIndexOutOfBoundsException ex){\n\t\t\t\t\t\tif(decodeParametersStrict)\n\t\t\t\t\t\t\tthrow new ParseException(ex.toString());\n\t\t\t\t\t} \n\t\t\t\t} else {\n\t\t\t\t\tvalue=(String)v;\n\t\t\t\t}\n\t\t\t\tsb.append(value);\n\t\t\t\tslist.remove(sname);\n\t\t\t}\n\t\t\tif(segment == 0){\n\t\t\t\tlist.remove(name);\n\t\t\t} else {\n\t\t\t\tmv.value=sb.toString();\n\t\t\t\tlist.put(name,mv);\n\t\t\t}\n\t\t}\n\t\tsuccess=true;\n\t} finally {\n\t\tif(keepConsistentOnFailure || success){\n\t\t\tif(slist.size() > 0){\n\t\t\t\tIterator sit=slist.values().iterator();\n\t\t\t\twhile(sit.hasNext()){\n\t\t\t\t\tObject v=sit.next();\n\t\t\t\t\tif(v instanceof Value){\n\t\t\t\t\t\tValue vv=(Value)v;\n\t\t\t\t\t\tValue vnew=decodeValue(vv.encodedValue);\n\t\t\t\t\t\tvv.charset=vnew.charset;\n\t\t\t\t\t\tvv.value=vnew.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.putAll(slist);\n\t\t\t}\n\t\t\tmultisegmentNames.clear();\n\t\t\tslist.clear();\n\t\t}\n\t} \n}","type":"T3"},"12":{"codeB":"@Override protected char[] escape(int cp){\n\tif(cp < safeOctets.length && safeOctets[cp]){\n\t} else if(cp == ' ' && plusForSpace){\n\t} else if(cp <= 0x7F){\n\t} else if(cp <= 0x7ff){\n\t\tchar[] dest=new char[6];\n\t\tdest[0]='%';\n\t\tdest[3]='%';\n\t\tdest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[2]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[1]=UPPER_HEX_DIGITS[0xC | cp];\n\t\treturn dest;\n\t} else if(cp <= 0xffff){\n\t\tchar[] dest=new char[9];\n\t\tdest[0]='%';\n\t\tdest[1]='E';\n\t\tdest[3]='%';\n\t\tdest[6]='%';\n\t\tdest[8]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[7]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[5]=UPPER_HEX_DIGITS[cp & 0xF];\n\t\tcp>>>=4;\n\t\tdest[4]=UPPER_HEX_DIGITS[0x8 | (cp & 0x3)];\n\t\tcp>>>=2;\n\t\tdest[2]=UPPER_HEX_DIGITS[cp];\n\t} else \n}","practice":false,"codeA":"protected final String escapeSlow(String s,int index){\n\tint end=s.length();\n\tchar[] dest=DEST_TL.get();\n\tint destIndex=0;\n\tint unescapedChunkStart=0;\n\twhile(index < end){\n\t\tint cp=codePointAt(s,index,end);\n\t\tif(cp < 0){\n\t\t\tthrow new IllegalArgumentException(\"Trailing high surrogate at end of input\");\n\t\t}\n\t\tchar[] escaped=escape(cp);\n\t\tunescapedChunkStart=index + (Character.isSupplementaryCodePoint(cp) ? 2 : 1);\n\t}\n\tint charsSkipped=end - unescapedChunkStart;\n\tif(charsSkipped > 0){\n\t\tint endIndex=destIndex + charsSkipped;\n\t\ts.getChars(unescapedChunkStart,end,dest,destIndex);\n\t\tdestIndex=endIndex;\n\t}\n\treturn new String(dest,0,destIndex);\n}","method":1,"docB":"Returns the escaped form of a given literal string, starting at the given index. It is protected to allow subclasses to override the fastpath escaping function to inline their escaping test.","docA":"Escapes the given Unicode code point in UTF-8.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"23":{"code_mymethod":{"r15":"public URLConnection openConnection(URL url) throws ParserException {\n\tProperties sysprops;\n\tHttpURLConnection http;\n\tURLConnection ret;\n\tdo{\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tret=url.openConnection();\n\t\t\t\tif(ret instanceof HttpURLConnection){\n\t\t\t\t} else \n\t\t\t\ttry {\n\t\t\t\t\tret.connect();\n\t\t\t\t} catch (UnknownHostException uhe){\n\t\t\t\t} catch (IOException ioe){\n\t\t\t\t} \n\t\t\t} finally {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t}\n\t\t\t} \n\t\t} catch (IOException ioe){\n\t\t} \n\t}while(repeat)\n}","r50%":"public URLConnection openConnection(URL url) throws ParserException {\n\tboolean repeat;\n\tint repeated;\n\tProperties sysprops;\n\tHashtable properties;\n\tEnumeration enumeration;\n\tString key;\n\tString value;\n\tString set=null;\n\tString host=null;\n\tString port=null;\n\tString host2=null;\n\tString port2=null;\n\tHttpURLConnection http;\n\tString auth;\n\tString encoded;\n\tint code;\n\tString uri;\n\tURLConnection ret;\n\tdo{\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t\tsysprops=System.getProperties();\n\t\t\t\t\tset=(String)sysprops.put(\"proxySet\",\"true\");\n\t\t\t\t\thost=(String)sysprops.put(\"proxyHost\",getProxyHost());\n\t\t\t\t\tport=(String)sysprops.put(\"proxyPort\",Integer.toString(getProxyPort()));\n\t\t\t\t\thost2=(String)sysprops.put(\"http.proxyHost\",getProxyHost());\n\t\t\t\t\tport2=(String)sysprops.put(\"http.proxyPort\",Integer.toString(getProxyPort()));\n\t\t\t\t\tSystem.setProperties(sysprops);\n\t\t\t\t}\n\t\t\t\tret=url.openConnection();\n\t\t\t\tif(ret instanceof HttpURLConnection){\n\t\t\t\t\tproperties=getRequestProperties();\n\t\t\t\t\tif(null != properties)\n\t\t\t\t\t\tfor (enumeration=properties.keys(); enumeration.hasMoreElements(); ){\n\t\t\t\t\t\t\tkey=(String)enumeration.nextElement();\n\t\t\t\t\t\t\tvalue=(String)properties.get(key);\n\t\t\t\t\t\t\tret.setRequestProperty(key,value);\n\t\t\t\t\t\t}\n\t\t\t\t} else \n\t\t\t\t\thttp=null;\n\t\t\t\ttry {\n\t\t\t\t\tret.connect();\n\t\t\t\t\tif(null != http){\n\t\t\t\t\t\tcode=http.getResponseCode();\n\t\t\t\t\t\tif((3 == (code / 100)) && (repeated < 20))\n\t\t\t\t\t\t\tif(null != (uri=getLocation(http))){\n\t\t\t\t\t\t\t\turl=new URL(uri);\n\t\t\t\t\t\t\t\trepeated++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (UnknownHostException uhe){\n\t\t\t\t} catch (IOException ioe){\n\t\t\t\t} \n\t\t\t} finally {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t\tsysprops=System.getProperties();\n\t\t\t\t\tSystem.setProperties(sysprops);\n\t\t\t\t}\n\t\t\t} \n\t\t} catch (IOException ioe){\n\t\t} \n\t}while(repeat)\n\treturn (ret);\n}","r30":"public URLConnection openConnection(URL url) throws ParserException {\n\tboolean repeat;\n\tProperties sysprops;\n\tHashtable properties;\n\tString key;\n\tHttpURLConnection http;\n\tString auth;\n\tString encoded;\n\tURLConnection ret;\n\tdo{\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t}\n\t\t\t\tret=url.openConnection();\n\t\t\t\tif(ret instanceof HttpURLConnection){\n\t\t\t\t\tif(null != properties)\n\t\t\t\t\t\tfor (enumeration=properties.keys(); enumeration.hasMoreElements(); ){\n\t\t\t\t\t\t\tkey=(String)enumeration.nextElement();\n\t\t\t\t\t\t\tvalue=(String)properties.get(key);\n\t\t\t\t\t\t\tret.setRequestProperty(key,value);\n\t\t\t\t\t\t}\n\t\t\t\t} else \n\t\t\t\t\thttp=null;\n\t\t\t\ttry {\n\t\t\t\t\tret.connect();\n\t\t\t\t} catch (UnknownHostException uhe){\n\t\t\t\t} catch (IOException ioe){\n\t\t\t\t} \n\t\t\t} finally {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t}\n\t\t\t} \n\t\t} catch (IOException ioe){\n\t\t} \n\t}while(repeat)\n\treturn (ret);\n}"},"code_native":{"r15":"public URLConnection openConnection(URL url) throws ParserException {\n\tboolean repeat;\n\tint repeated;\n\tProperties sysprops;\n\tHashtable properties;\n\tEnumeration enumeration;\n\tString key;\n\tString value;\n\tString set=null;\n\tString host=null;\n\tString port=null;\n\tString host2=null;\n\tString port2=null;\n\tint code;\n\tURLConnection ret;\n\treturn (ret);\n}","r50%":"public URLConnection openConnection(URL url) throws ParserException {\n\tboolean repeat;\n\tint repeated;\n\tProperties sysprops;\n\tHashtable properties;\n\tEnumeration enumeration;\n\tString key;\n\tString value;\n\tString set=null;\n\tString host=null;\n\tString port=null;\n\tString host2=null;\n\tString port2=null;\n\tHttpURLConnection http;\n\tString auth;\n\tString encoded;\n\tint code;\n\tString uri;\n\tURLConnection ret;\n\trepeated=0;\n\tdo{\n\t\trepeat=false;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t\tsysprops=System.getProperties();\n\t\t\t\t\tset=(String)sysprops.put(\"proxySet\",\"true\");\n\t\t\t\t\thost=(String)sysprops.put(\"proxyHost\",getProxyHost());\n\t\t\t\t\tport=(String)sysprops.put(\"proxyPort\",Integer.toString(getProxyPort()));\n\t\t\t\t\thost2=(String)sysprops.put(\"http.proxyHost\",getProxyHost());\n\t\t\t\t\tport2=(String)sysprops.put(\"http.proxyPort\",Integer.toString(getProxyPort()));\n\t\t\t\t\tSystem.setProperties(sysprops);\n\t\t\t\t}\n\t\t\t\tret=url.openConnection();\n\t\t\t\tif(ret instanceof HttpURLConnection){\n\t\t\t\t\thttp=(HttpURLConnection)ret;\n\t\t\t\t\tif(getRedirectionProcessingEnabled())\n\t\t\t\t\t\thttp.setInstanceFollowRedirects(false);\n\t\t\t\t\tproperties=getRequestProperties();\n\t\t\t\t\tif(null != properties)\n\t\t\t\t\tif((null != getUser()) && (null != getPassword())){\n\t\t\t\t\t\tauth=getUser() + \":\" + getPassword();\n\t\t\t\t\t\tencoded=encode(auth.getBytes(\"ISO-8859-1\"));\n\t\t\t\t\t\tret.setRequestProperty(\"Authorization\",\"Basic \" + encoded);\n\t\t\t\t\t}\n\t\t\t\t\tif(getCookieProcessingEnabled())\n\t\t\t\t\t\taddCookies(ret);\n\t\t\t\t\tif(null != getMonitor())\n\t\t\t\t\t\tgetMonitor().preConnect(http);\n\t\t\t\t} else \n\t\t\t\t\thttp=null;\n\t\t\t} finally {\n\t\t\t} \n\t\t} catch (IOException ioe){\n\t\t\tString msg=\"Error in opening a connection to \" + url.toExternalForm();\n\t\t\tParserException ex=new ParserException(msg,ioe);\n\t\t\tthrow ex;\n\t\t} \n\t}while(repeat)\n\treturn (ret);\n}","r30":"public URLConnection openConnection(URL url) throws ParserException {\n\tboolean repeat;\n\tint repeated;\n\tProperties sysprops;\n\tHashtable properties;\n\tEnumeration enumeration;\n\tString key;\n\tString value;\n\tString set=null;\n\tString host=null;\n\tString port=null;\n\tString host2=null;\n\tString port2=null;\n\tHttpURLConnection http;\n\tString auth;\n\tString encoded;\n\tint code;\n\tString uri;\n\tURLConnection ret;\n\tdo{\n\t\trepeat=false;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tret=url.openConnection();\n\t\t\t} finally {\n\t\t\t} \n\t\t} catch (IOException ioe){\n\t\t\tString msg=\"Error in opening a connection to \" + url.toExternalForm();\n\t\t\tParserException ex=new ParserException(msg,ioe);\n\t\t\tthrow ex;\n\t\t} \n\t}while(repeat)\n\treturn (ret);\n}"},"method":1,"code_original":"public URLConnection openConnection(URL url) throws ParserException {\n\tboolean repeat;\n\tint repeated;\n\tProperties sysprops;\n\tHashtable properties;\n\tEnumeration enumeration;\n\tString key;\n\tString value;\n\tString set=null;\n\tString host=null;\n\tString port=null;\n\tString host2=null;\n\tString port2=null;\n\tHttpURLConnection http;\n\tString auth;\n\tString encoded;\n\tint code;\n\tString uri;\n\tURLConnection ret;\n\trepeated=0;\n\tdo{\n\t\trepeat=false;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t\tsysprops=System.getProperties();\n\t\t\t\t\tset=(String)sysprops.put(\"proxySet\",\"true\");\n\t\t\t\t\thost=(String)sysprops.put(\"proxyHost\",getProxyHost());\n\t\t\t\t\tport=(String)sysprops.put(\"proxyPort\",Integer.toString(getProxyPort()));\n\t\t\t\t\thost2=(String)sysprops.put(\"http.proxyHost\",getProxyHost());\n\t\t\t\t\tport2=(String)sysprops.put(\"http.proxyPort\",Integer.toString(getProxyPort()));\n\t\t\t\t\tSystem.setProperties(sysprops);\n\t\t\t\t}\n\t\t\t\tret=url.openConnection();\n\t\t\t\tif(ret instanceof HttpURLConnection){\n\t\t\t\t\thttp=(HttpURLConnection)ret;\n\t\t\t\t\tif(getRedirectionProcessingEnabled())\n\t\t\t\t\t\thttp.setInstanceFollowRedirects(false);\n\t\t\t\t\tproperties=getRequestProperties();\n\t\t\t\t\tif(null != properties)\n\t\t\t\t\t\tfor (enumeration=properties.keys(); enumeration.hasMoreElements(); ){\n\t\t\t\t\t\t\tkey=(String)enumeration.nextElement();\n\t\t\t\t\t\t\tvalue=(String)properties.get(key);\n\t\t\t\t\t\t\tret.setRequestProperty(key,value);\n\t\t\t\t\t\t}\n\t\t\t\t\tif((null != getProxyUser()) && (null != getProxyPassword())){\n\t\t\t\t\t\tauth=getProxyUser() + \":\" + getProxyPassword();\n\t\t\t\t\t\tencoded=encode(auth.getBytes(\"ISO-8859-1\"));\n\t\t\t\t\t\tret.setRequestProperty(\"Proxy-Authorization\",\"Basic \" + encoded);\n\t\t\t\t\t}\n\t\t\t\t\tif((null != getUser()) && (null != getPassword())){\n\t\t\t\t\t\tauth=getUser() + \":\" + getPassword();\n\t\t\t\t\t\tencoded=encode(auth.getBytes(\"ISO-8859-1\"));\n\t\t\t\t\t\tret.setRequestProperty(\"Authorization\",\"Basic \" + encoded);\n\t\t\t\t\t}\n\t\t\t\t\tif(getCookieProcessingEnabled())\n\t\t\t\t\t\taddCookies(ret);\n\t\t\t\t\tif(null != getMonitor())\n\t\t\t\t\t\tgetMonitor().preConnect(http);\n\t\t\t\t} else \n\t\t\t\t\thttp=null;\n\t\t\t\ttry {\n\t\t\t\t\tret.connect();\n\t\t\t\t\tif(null != http){\n\t\t\t\t\t\tif(null != getMonitor())\n\t\t\t\t\t\t\tgetMonitor().postConnect(http);\n\t\t\t\t\t\tif(getCookieProcessingEnabled())\n\t\t\t\t\t\t\tparseCookies(ret);\n\t\t\t\t\t\tcode=http.getResponseCode();\n\t\t\t\t\t\tif((3 == (code / 100)) && (repeated < 20))\n\t\t\t\t\t\t\tif(null != (uri=getLocation(http))){\n\t\t\t\t\t\t\t\turl=new URL(uri);\n\t\t\t\t\t\t\t\trepeat=true;\n\t\t\t\t\t\t\t\trepeated++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (UnknownHostException uhe){\n\t\t\t\t\tint message=(int)(Math.random() * FOUR_OH_FOUR.length);\n\t\t\t\t\tthrow new ParserException(FOUR_OH_FOUR[message],uhe);\n\t\t\t\t} catch (IOException ioe){\n\t\t\t\t\tthrow new ParserException(ioe.getMessage(),ioe);\n\t\t\t\t} \n\t\t\t} finally {\n\t\t\t\tif((null != getProxyHost()) && (0 != getProxyPort())){\n\t\t\t\t\tsysprops=System.getProperties();\n\t\t\t\t\tif(null != set)\n\t\t\t\t\t\tsysprops.put(\"proxySet\",set);\n\t\t\t\t\telse \n\t\t\t\t\t\tsysprops.remove(\"proxySet\");\n\t\t\t\t\tif(null != host)\n\t\t\t\t\t\tsysprops.put(\"proxyHost\",host);\n\t\t\t\t\telse \n\t\t\t\t\t\tsysprops.remove(\"proxyHost\");\n\t\t\t\t\tif(null != port)\n\t\t\t\t\t\tsysprops.put(\"proxyPort\",port);\n\t\t\t\t\telse \n\t\t\t\t\t\tsysprops.remove(\"proxyPort\");\n\t\t\t\t\tif(null != host2)\n\t\t\t\t\t\tsysprops.put(\"http.proxyHost\",host2);\n\t\t\t\t\telse \n\t\t\t\t\t\tsysprops.remove(\"http.proxyHost\");\n\t\t\t\t\tif(null != port2)\n\t\t\t\t\t\tsysprops.put(\"http.proxyPort\",port2);\n\t\t\t\t\telse \n\t\t\t\t\t\tsysprops.remove(\"http.proxyPort\");\n\t\t\t\t\tSystem.setProperties(sysprops);\n\t\t\t\t}\n\t\t\t} \n\t\t} catch (IOException ioe){\n\t\t\tString msg=\"Error in opening a connection to \" + url.toExternalForm();\n\t\t\tParserException ex=new ParserException(msg,ioe);\n\t\t\tthrow ex;\n\t\t} \n\t}while(repeat)\n\treturn (ret);\n}","type":"T3"},"13":{"codeB":"public void submit(String buttonName,String buttonValue){\n\tList<HtmlElement> l=new LinkedList<HtmlElement>();\n\ttry {\n\t\tfor (int i=0; i < l.size(); i++){\n\t\t\tObject o=l.get(i);\n\t\t\tif(o instanceof HtmlSubmitInput){\n\t\t\t\tHtmlSubmitInput inpt=(HtmlSubmitInput)o;\n\t\t\t\tif(inpt.getValueAttribute().equals(buttonValue)){\n\t\t\t\t\tinpt.click();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(o instanceof HtmlButton){\n\t\t\t\tHtmlButton inpt=(HtmlButton)o;\n\t\t\t\tif(inpt.getTypeAttribute().equals(\"submit\") && inpt.getValueAttribute().equals(buttonValue)){\n\t\t\t\t\tinpt.click();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} catch (FailingHttpStatusCodeException e){\n\t} catch (IOException e){\n\t} \n}","practice":false,"codeA":"public Page submit(final SubmittableElement submitElement) throws IOException {\n\tfinal HtmlPage htmlPage=(HtmlPage)getPage();\n\tfinal List<NameValuePair> parameters=getParameterListForSubmit(submitElement);\n\tfinal HttpMethod method;\n\tfinal String methodAttribute=getMethodAttribute();\n\tString actionUrl=getActionAttribute();\n\tif(HttpMethod.GET == method){\n\t\tfinal String anchor=StringUtils.substringAfter(actionUrl,\"#\");\n\t\tactionUrl=StringUtils.substringBefore(actionUrl,\"#\");\n\t\tfinal NameValuePair[] pairs=new NameValuePair[parameters.size()];\n\t\tparameters.toArray(pairs);\n\t\tfinal String queryFromFields=EncodingUtil.formUrlEncode(pairs,getPage().getPageEncoding());\n\t\tactionUrl=StringUtils.substringBefore(actionUrl,\"?\");\n\t\tfinal BrowserVersion browserVersion=getPage().getWebClient().getBrowserVersion();\n\t\tparameters.clear();\n\t}\n\tfinal URL url;\n\ttry {\n\t\tif(actionUrl.length() == 0){\n\t\t\turl=htmlPage.getWebResponse().getRequestSettings().getUrl();\n\t\t} else if(actionUrl.startsWith(\"?\")){\n\t\t\tString urlString=htmlPage.getWebResponse().getRequestSettings().getUrl().toExternalForm();\n\t\t\tif(urlString.indexOf('?') != -1){\n\t\t\t\turlString=urlString.substring(0,urlString.indexOf('?'));\n\t\t\t}\n\t\t\turl=new URL(urlString + actionUrl);\n\t\t} else {\n\t\t\turl=htmlPage.getFullyQualifiedUrl(actionUrl);\n\t\t}\n\t} catch (final MalformedURLException e){\n\t} \n\tfinal WebRequestSettings settings=new WebRequestSettings(url,method);\n\tsettings.setRequestParameters(parameters);\n\tsettings.setEncodingType(FormEncodingType.getInstance(getEnctypeAttribute()));\n\tsettings.setCharset(getSubmitCharset());\n\tsettings.setAdditionalHeader(\"Referer\",htmlPage.getWebResponse().getRequestSettings().getUrl().toExternalForm());\n\tfinal WebWindow webWindow=htmlPage.getEnclosingWindow();\n\treturn htmlPage.getWebClient().getPage(webWindow,htmlPage.getResolvedTarget(getTargetAttribute()),settings);\n}","method":2,"docB":"Submit the current form with the specifed submit button.","docA":"Submit this form to the server. If parameter is null, then the submission is treated as if it was triggered by JavaScript, and the onsubmit handler will not be executed.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"24":{"code_mymethod":{"r15":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tif(mode == TFTP.ASCII_MODE){\n\t}\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket :\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","r50%":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPDataPacket data;\n\tbeginBufferedOps();\n\t_sendPacket :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket :\n\t\t\t\twhile(true){\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treceived=bufferedReceive();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} catch (SocketException e){\n\t\t\t\t\t\t} catch (InterruptedIOException e){\n\t\t\t\t\t\t} catch (TFTPPacketException e){\n\t\t\t\t\t\t} \n\t\t\t\t\t}while(timeouts < __maxTimeouts)\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tif(lastBlock == block){\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\toutput.write(data.getData(),data.getDataOffset(),dataLength);\n\t\t\t\t\t\t\t\t} catch (IOException e){\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t++block;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiscardPackets();\n\t\t\t\t\t\t\t\tcontinue _receivePacket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\treturn bytesRead;\n}","r30":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPDataPacket data;\n\t_sendPacket :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket :\n\t\t\t\twhile(true){\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treceived=bufferedReceive();\n\t\t\t\t\t\t} catch (SocketException e){\n\t\t\t\t\t\t} catch (InterruptedIOException e){\n\t\t\t\t\t\t} catch (TFTPPacketException e){\n\t\t\t\t\t\t} \n\t\t\t\t\t}while(timeouts < __maxTimeouts)\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\treturn bytesRead;\n}"},"code_native":{"r15":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tif(mode == TFTP.ASCII_MODE){\n\t\toutput=new FromNetASCIIOutputStream(output);\n\t}\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket :\n\tbufferedSend(sent);\n\tendBufferedOps();\n}","r50%":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tif(mode == TFTP.ASCII_MODE){\n\t\toutput=new FromNetASCIIOutputStream(output);\n\t}\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket :\n\t\t\t\twhile(true){\n\t\t\t\t\ttimeouts=0;\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tdata=(TFTPDataPacket)received;\n\t\t\t\t\t\t\tdataLength=data.getDataLength();\n\t\t\t\t\t\t\tlastBlock=data.getBlockNumber();\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Received unexpected packet type.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror=new TFTPErrorPacket(received.getAddress(),received.getPort(),TFTPErrorPacket.UNKNOWN_TID,\"Unexpected host or port.\");\n\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\tendBufferedOps();\n\treturn bytesRead;\n}","r30":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tif(mode == TFTP.ASCII_MODE){\n\t\toutput=new FromNetASCIIOutputStream(output);\n\t}\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket :\n\t\t\t\twhile(true){\n\t\t\t\t\ttimeouts=0;\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}"},"method":1,"code_original":"public int receiveFile(String filename,int mode,OutputStream output,InetAddress host,int port) throws IOException {\n\tint bytesRead, timeouts, lastBlock, block, hostPort, dataLength;\n\tTFTPPacket sent, received=null;\n\tTFTPErrorPacket error;\n\tTFTPDataPacket data;\n\tTFTPAckPacket ack=new TFTPAckPacket(host,port,0);\n\tbeginBufferedOps();\n\tdataLength=lastBlock=hostPort=bytesRead=0;\n\tblock=1;\n\tif(mode == TFTP.ASCII_MODE){\n\t\toutput=new FromNetASCIIOutputStream(output);\n\t}\n\tsent=new TFTPReadRequestPacket(host,port,filename,mode);\n\t_sendPacket :\n\t\tdo{\n\t\t\tbufferedSend(sent);\n\t\t\t_receivePacket :\n\t\t\t\twhile(true){\n\t\t\t\t\ttimeouts=0;\n\t\t\t\t\tdo{\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treceived=bufferedReceive();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} catch (SocketException e){\n\t\t\t\t\t\t\tif(++timeouts >= __maxTimeouts){\n\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\tthrow new IOException(\"Connection timed out.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t} catch (InterruptedIOException e){\n\t\t\t\t\t\t\tif(++timeouts >= __maxTimeouts){\n\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\tthrow new IOException(\"Connection timed out.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t} catch (TFTPPacketException e){\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Bad packet: \" + e.getMessage());\n\t\t\t\t\t\t} \n\t\t\t\t\t}while(timeouts < __maxTimeouts)\n\t\t\t\t\tif(lastBlock == 0){\n\t\t\t\t\t\thostPort=received.getPort();\n\t\t\t\t\t\tack.setPort(hostPort);\n\t\t\t\t\t\tif(!host.equals(received.getAddress())){\n\t\t\t\t\t\t\thost=received.getAddress();\n\t\t\t\t\t\t\tack.setAddress(host);\n\t\t\t\t\t\t\tsent.setAddress(host);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(host.equals(received.getAddress()) && received.getPort() == hostPort){\n\t\t\t\t\t\tswitch (received.getType()){\n\t\t\t\t\t\tcase TFTPPacket.ERROR: \n\t\t\t\t\t\t\terror=(TFTPErrorPacket)received;\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Error code \" + error.getError() + \" received: \"+ error.getMessage());\n\t\t\t\t\t\tcase TFTPPacket.DATA: \n\t\t\t\t\t\t\tdata=(TFTPDataPacket)received;\n\t\t\t\t\t\t\tdataLength=data.getDataLength();\n\t\t\t\t\t\t\tlastBlock=data.getBlockNumber();\n\t\t\t\t\t\t\tif(lastBlock == block){\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\toutput.write(data.getData(),data.getDataOffset(),dataLength);\n\t\t\t\t\t\t\t\t} catch (IOException e){\n\t\t\t\t\t\t\t\t\terror=new TFTPErrorPacket(host,hostPort,TFTPErrorPacket.OUT_OF_SPACE,\"File write failed.\");\n\t\t\t\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t++block;\n\t\t\t\t\t\t\t\tif(block > 65535){\n\t\t\t\t\t\t\t\t\tblock=0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak _receivePacket;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiscardPackets();\n\t\t\t\t\t\t\t\tif(lastBlock == (block == 0 ? 65535 : (block - 1))){\n\t\t\t\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue _receivePacket;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tendBufferedOps();\n\t\t\t\t\t\t\tthrow new IOException(\"Received unexpected packet type.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror=new TFTPErrorPacket(received.getAddress(),received.getPort(),TFTPErrorPacket.UNKNOWN_TID,\"Unexpected host or port.\");\n\t\t\t\t\t\tbufferedSend(error);\n\t\t\t\t\t\tcontinue _sendPacket;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tack.setBlockNumber(lastBlock);\n\t\t\tsent=ack;\n\t\t\tbytesRead+=dataLength;\n\t\t}while(dataLength == TFTPPacket.SEGMENT_SIZE)\n\tbufferedSend(sent);\n\tendBufferedOps();\n\treturn bytesRead;\n}","type":"T3"},"14":{"codeB":"public static MultivaluedMap<String,String> getEntityParameters(ClientRequest request,Providers providers){\n\tObject entity=request.getEntity();\n\tString method=request.getMethod();\n\tMediaType mediaType=getMediaType(request);\n\tif(entity == null || method == null || !method.equalsIgnoreCase(\"POST\") || mediaType == null || !mediaType.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE)){\n\t\treturn new MultivaluedMapImpl();\n\t}\n\tif(entity instanceof MultivaluedMap){\n\t\treturn (MultivaluedMap)entity;\n\t}\n\tType entityType=entity.getClass();\n\tif(entity instanceof GenericEntity){\n\t\tfinal GenericEntity generic=(GenericEntity)entity;\n\t\tentityType=generic.getType();\n\t\tentity=generic.getEntity();\n\t}\n\tfinal Class entityClass=entity.getClass();\n\tByteArrayOutputStream out=new ByteArrayOutputStream();\n\tMessageBodyWriter writer=providers.getMessageBodyWriter(entityClass,entityType,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE);\n\ttry {\n\t\twriter.writeTo(entity,entityClass,entityType,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE,null,out);\n\t} catch (WebApplicationException wae){\n\t\tthrow new IllegalStateException(wae);\n\t} catch (IOException ioe){\n\t\tthrow new IllegalStateException(ioe);\n\t} \n\tByteArrayInputStream in=new ByteArrayInputStream(out.toByteArray());\n\tMessageBodyReader reader=providers.getMessageBodyReader(MultivaluedMap.class,MultivaluedMap.class,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE);\n\ttry {\n\t\treturn (MultivaluedMap<String,String>)reader.readFrom(MultivaluedMap.class,MultivaluedMap.class,EMPTY_ANNOTATIONS,MediaType.APPLICATION_FORM_URLENCODED_TYPE,null,in);\n\t} catch (IOException ioe){\n\t\tthrow new IllegalStateException(ioe);\n\t} \n}","practice":false,"codeA":"protected SortedMap<String,SortedSet<String>> loadSignificantParametersForSignatureBaseString(HttpServletRequest request){\n\tSortedMap<String,SortedSet<String>> significantParameters=new TreeMap<String,SortedSet<String>>();\n\tEnumeration parameterNames=request.getParameterNames();\n\twhile(parameterNames.hasMoreElements()){\n\t\tString parameterName=(String)parameterNames.nextElement();\n\t\tString[] values=request.getParameterValues(parameterName);\n\t\tif(values == null){\n\t\t\tvalues=new String[]{\"\"};\n\t\t}\n\t\tfor (String parameterValue : values){\n\t\t\tif(parameterValue == null){\n\t\t\t\tparameterValue=\"\";\n\t\t\t}\n\t\t\tparameterName=oauthEncode(parameterName);\n\t\t\tparameterValue=oauthEncode(parameterValue);\n\t\t\tSortedSet<String> significantValues=significantParameters.get(parameterName);\n\t\t\tif(significantValues == null){\n\t\t\t\tsignificantValues=new TreeSet<String>();\n\t\t\t\tsignificantParameters.put(parameterName,significantValues);\n\t\t\t}\n\t\t\tsignificantValues.add(parameterValue);\n\t\t}\n\t}\n\tMap<String,String> oauthParams=parseParameters(request);\n\toauthParams.remove(\"realm\");\n\tSet<String> parsedParams=oauthParams.keySet();\n\tfor (String parameterName : parsedParams){\n\t\tString parameterValue=oauthParams.get(parameterName);\n\t\tif(parameterValue == null){\n\t\t\tparameterValue=\"\";\n\t\t}\n\t\tparameterName=oauthEncode(parameterName);\n\t\tparameterValue=oauthEncode(parameterValue);\n\t\tSortedSet<String> significantValues=significantParameters.get(parameterName);\n\t\tif(significantValues == null){\n\t\t\tsignificantValues=new TreeSet<String>();\n\t\t\tsignificantParameters.put(parameterName,significantValues);\n\t\t}\n\t\tsignificantValues.add(parameterValue);\n\t}\n\tsignificantParameters.remove(OAuthConsumerParameter.oauth_signature.toString());\n\treturn significantParameters;\n}","method":0,"docB":"Gets the parameters (name-to-value map) that are to be used to calculate the signature base string. The parameters will be encoded by oauthEncode method.","docA":"Gets the parameters from a request as a map. If the request does not have a POST method, or the media type is not x-www-form-urlencoded, then null is returned.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"15":{"codeB":"protected void retrieveToken(OAuthConsumer consumer,String endpointUrl,HttpParameters customOAuthParams) throws OAuthMessageSignerException, OAuthCommunicationException, OAuthNotAuthorizedException, OAuthExpectationFailedException {\n\tHttpRequest request=null;\n\tHttpResponse response=null;\n\ttry {\n\t\trequest=createRequest(endpointUrl);\n\t\tconsumer.sign(request);\n\t\tresponse=sendRequest(request);\n\t\tboolean requestHandled=false;\n\t\tHttpParameters responseParams=OAuth.decodeForm(response.getContent());\n\t\tString token=responseParams.getFirst(OAuth.OAUTH_TOKEN);\n\t\tString secret=responseParams.getFirst(OAuth.OAUTH_TOKEN_SECRET);\n\t\tresponseParams.remove(OAuth.OAUTH_TOKEN);\n\t\tresponseParams.remove(OAuth.OAUTH_TOKEN_SECRET);\n\t\tsetResponseParameters(responseParams);\n\t\tif(token == null || secret == null){\n\t\t\tthrow new OAuthExpectationFailedException(\"Request token or token secret not set in server reply. \" + \"The service provider you use is probably buggy.\");\n\t\t}\n\t\tconsumer.setTokenWithSecret(token,secret);\n\t} catch (OAuthNotAuthorizedException e){\n\t\tthrow e;\n\t} catch (OAuthExpectationFailedException e){\n\t\tthrow e;\n\t} catch (Exception e){\n\t\tthrow new OAuthCommunicationException(e);\n\t} finally {\n\t\ttry {\n\t\t\tcloseConnection(request,response);\n\t\t} catch (Exception e){\n\t\t\tthrow new OAuthCommunicationException(e);\n\t\t} \n\t} \n}","practice":false,"codeA":"protected OAuthConsumerToken getTokenFromProvider(ProtectedResourceDetails details,URL tokenURL,String httpMethod,OAuthConsumerToken requestToken,Map<String,String> additionalParameters){\n\tboolean isAccessToken=requestToken != null;\n\tif(!isAccessToken){\n\t\trequestToken=new OAuthConsumerToken();\n\t\trequestToken.setNonce(getNonceFactory().generateNonce());\n\t}\n\tInputStream inputStream=readResource(details,tokenURL,httpMethod,requestToken,additionalParameters);\n\tString tokenInfo;\n\ttry {\n\t\tByteArrayOutputStream out=new ByteArrayOutputStream();\n\t\tbyte[] buffer=new byte[1024];\n\t\tint len=inputStream.read(buffer);\n\t\twhile(len >= 0){\n\t\t\tout.write(buffer,0,len);\n\t\t\tlen=inputStream.read(buffer);\n\t\t}\n\t\ttokenInfo=new String(out.toByteArray(),\"UTF-8\");\n\t} catch (IOException e){\n\t} \n\tMap<String,String> tokenPropertyValues=new TreeMap<String,String>();\n\tString tokenValue=tokenPropertyValues.remove(OAuthProviderParameter.oauth_token.toString());\n\tString tokenSecret=tokenPropertyValues.remove(OAuthProviderParameter.oauth_token_secret.toString());\n\tOAuthConsumerToken consumerToken=new OAuthConsumerToken();\n\tconsumerToken.setValue(tokenValue);\n\tconsumerToken.setSecret(tokenSecret);\n\tconsumerToken.setNonce(requestToken.getNonce());\n\tconsumerToken.setResourceId(details.getId());\n\tconsumerToken.setAccessToken(isAccessToken);\n\treturn consumerToken;\n}","method":1,"docB":"Implemented by subclasses. The responsibility of this method is to contact the service provider at the given endpoint URL and fetch a request or access token. What kind of token is retrieved solely depends on the URL being used. Correct implementations of this method must guarantee the following post-conditions: the OAuthConsumer passed to this method must have a valid OAuth#OAUTH_TOKEN and OAuth#OAUTH_TOKEN_SECRET set bycalling OAuthConsumer#setTokenWithSecret(String,String). #getResponseParameters() must return the set of queryparameters served by the service provider in the token response, with all OAuth specific parameters being removed.","docA":"Get the consumer token with the given parameters and URL. The determination of whether the retrieved token is an access token depends on whether a request token is provided.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"16":{"codeB":"public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tif(diffUnit instanceof XMLDocumentDiffUnit){\n\t\tXMLDocumentDiffUnit du=(XMLDocumentDiffUnit)diffUnit;\n\t} else if(diffUnit instanceof XMLNodeDiffUnit){\n\t\tif(n1 != null && n2 != null){\n\t\t\tString v1=n1.getNodeValue();\n\t\t\tString v2=n2.getNodeValue();\n\t\t\tif(v1 != null && v2 != null){\n\t\t\t} else if(v1 == null && v2 != null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Node value present in right only\");\n\t\t\t} else \n\t\t} else if(n1 == null && n2 != null){\n\t\t} else \n\t} else if(diffUnit instanceof XMLAttributeDiffUnit){\n\t\tXMLAttributeDiffUnit du=(XMLAttributeDiffUnit)diffUnit;\n\t\tString name=du.getAttributeName();\n\t\tif(!du.leftExists()){\n\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Attribute present in right only: \" + name);\n\t\t} else if(!du.rightExists()){\n\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Attribute present in left only: \" + name);\n\t\t} else {\n\t\t\tNode n1=du.getLeftAttributeNode();\n\t\t\tNode n2=du.getRightAttributeNode();\n\t\t\tString v1=n1.getNodeValue();\n\t\t\tString v2=n2.getNodeValue();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tInputStream is1=diffUnit.getLeftInputStream();\n\t\t\tInputStream is2=diffUnit.getRightInputStream();\n\t\t\tString scopedPath=diffUnit.getScopedPath();\n\t\t\tscope=createScope(scopedPath,is1,is2);\n\t\t} catch (IOException ioe){\n\t\t} \n\t}\n\treturn scope;\n}","practice":false,"codeA":"public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tProperties p1=new Properties();\n\tProperties p2=new Properties();\n\tInputStream is1=null;\n\tInputStream is2=null;\n\ttry {\n\t\tis1=diffUnit.getLeftInputStream();\n\t\tis2=diffUnit.getRightInputStream();\n\t\tSet<String> keys=new TreeSet<String>();\n\t\tkeys.addAll(p2.stringPropertyNames());\n\t\tfor (Iterator<String> it=keys.iterator(); it.hasNext(); ){\n\t\t\tString key=it.next();\n\t\t\tString v1=p1.getProperty(key);\n\t\t\tString v2=p2.getProperty(key);\n\t\t\tif(v1 == null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Property in right only: \" + key);\n\t\t\t} else if(v2 == null){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Property in left only: \" + key);\n\t\t\t} else if(!v1.equals(v2)){\n\t\t\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Property value mismatch for key \" + key + \": \"+ v1+ \", \"+ v2);\n\t\t\t\tprocessor.processDiffPoint(diffPoint);\n\t\t\t}\n\t\t}\n\t} catch (IOException ioe){\n\t} finally {\n\t} \n\treturn null;\n}","method":2,"docB":"Performs a Properties comparison on diffUnit, and passes any DiffPoint found to processor. The properties are iterated through and their values compared.","docA":"Performs a deep XML comparison on diffUnit. If diffUnit represents part of a DOM, compares the unit and passes any DiffPoint found to processor. Otherwise, returns a new DiffScope to process the XML document.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"17":{"codeB":"public Tag scan(Tag tag,Lexer lexer,NodeList stack) throws ParserException {\n\tString language;\n\tString code;\n\tNode content;\n\tint position;\n\tNode node;\n\tAttribute attribute;\n\tVector vector;\n\tif(tag instanceof ScriptTag){\n\t\tlanguage=((ScriptTag)tag).getLanguage();\n\t\tif((null != language) && (language.equalsIgnoreCase(\"JScript.Encode\") || language.equalsIgnoreCase(\"VBScript.Encode\"))){\n\t\t\tcode=ScriptDecoder.Decode(lexer.getPage(),lexer.getCursor());\n\t\t\t((ScriptTag)tag).setScriptCode(code);\n\t\t}\n\t}\n\tcontent=lexer.parseCDATA(!STRICT);\n\tposition=lexer.getPosition();\n\tnode=lexer.nextNode(false);\n\tif(null != node)\n\t\tif(!(node instanceof Tag) || !(((Tag)node).isEndTag() && ((Tag)node).getTagName().equals(tag.getIds()[0]))){\n\t\t\tlexer.setPosition(position);\n\t\t\tnode=null;\n\t\t}\n\tif(null == node){\n\t\tattribute=new Attribute(\"/script\",null);\n\t\tvector=new Vector();\n\t\tvector.addElement(attribute);\n\t\tnode=lexer.getNodeFactory().createTagNode(lexer.getPage(),position,position,vector);\n\t}\n\ttag.setEndTag((Tag)node);\n\tif(null != content){\n\t\ttag.setChildren(new NodeList(content));\n\t\tcontent.setParent(tag);\n\t}\n\tnode.setParent(tag);\n\ttag.doSemanticAction();\n\treturn (tag);\n}","practice":false,"codeA":"public Tag scan(Tag tag,Lexer lexer,NodeList stack) throws ParserException {\n\tNode content;\n\tint position;\n\tNode node;\n\tAttribute attribute;\n\tVector vector;\n\tcontent=lexer.parseCDATA();\n\tposition=lexer.getPosition();\n\tnode=lexer.nextNode(false);\n\tif(null != node)\n\t\tif(!(node instanceof Tag) || !(((Tag)node).isEndTag() && ((Tag)node).getTagName().equals(tag.getIds()[0]))){\n\t\t\tlexer.setPosition(position);\n\t\t\tnode=null;\n\t\t}\n\tif(null == node){\n\t\tattribute=new Attribute(\"/style\",null);\n\t\tvector=new Vector();\n\t\tvector.addElement(attribute);\n\t\tnode=lexer.getNodeFactory().createTagNode(lexer.getPage(),position,position,vector);\n\t}\n\ttag.setEndTag((Tag)node);\n\tif(null != content){\n\t\ttag.setChildren(new NodeList(content));\n\t\tcontent.setParent(tag);\n\t}\n\tnode.setParent(tag);\n\ttag.doSemanticAction();\n\treturn (tag);\n}","method":0,"docB":"Scan for style definitions. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.","docA":"Scan for script. Accumulates text from the page, until &lt;/[a-zA-Z] is encountered.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"18":{"codeB":"protected URL[][] extractImageLinks(final Lexer lexer,final URL docbase) throws IOException, ParserException {\n\tHashMap<String,URL> images;\n\tHashMap<String,URL> links;\n\tboolean ina;\n\tNode node;\n\tTag tag;\n\tString name;\n\tTag startatag;\n\tTag imgtag;\n\tString href;\n\tString src;\n\tURL url;\n\tURL[][] ret;\n\timages=new HashMap<String,URL>();\n\tlinks=new HashMap<String,URL>();\n\tina=false;\n\tstartatag=null;\n\timgtag=null;\n\twhile(null != (node=lexer.nextNode())){\n\t\tif(node instanceof Tag){\n\t\t\ttag=(Tag)node;\n\t\t\tname=tag.getTagName();\n\t\t\tif(\"A\".equals(name)){\n\t\t\t} else if(ina && \"IMG\".equals(name))\n\t\t\t\timgtag=tag;\n\t\t}\n\t}\n\tret=new URL[2][];\n\tret[0]=new URL[images.size()];\n\timages.values().toArray(ret[0]);\n\tret[1]=new URL[links.size()];\n\tlinks.values().toArray(ret[1]);\n\treturn (ret);\n}","practice":false,"codeA":"public String extractImageLocn(){\n\tVector attributes;\n\tint size;\n\tAttribute attribute;\n\tString string;\n\tString data;\n\tint state;\n\tString name;\n\tString ret;\n\tret=\"\";\n\tstate=0;\n\tattributes=getAttributesEx();\n\tsize=attributes.size();\n\tfor (int i=0; (i < size) && (state < 3); i++){\n\t\tattribute=(Attribute)attributes.elementAt(i);\n\t\tstring=attribute.getName();\n\t\tdata=attribute.getValue();\n\t\tswitch (state){\n\t\tcase 0: \n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tif(null != string){\n\t\t\t\tif(null == data)\n\t\t\t\t\tret=string;\n\t\t\t\tstate=0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"we're not supposed to in state \" + state);\n\t\t}\n\t}\n\tret=ParserUtils.removeChars(ret,'\\n');\n\treturn (ret);\n}","method":1,"docB":"Extract the location of the image Given the tag (with attributes), and the url of the html page in which this tag exists, perform best effort to extract the 'intended' URL. Attempts to handle such attributes as: &lt;IMG SRC=http://www.redgreen.com&gt; - normal &lt;IMG SRC =http://www.redgreen.com&gt; - space between attribute name and equals sign &lt;IMG SRC= http://www.redgreen.com&gt; - space between equals sign and attribute value &lt;IMG SRC = http://www.redgreen.com&gt; - space both sides of equals sign.\n","docA":"Get the links of an element of a document. Only gets the links on IMG elements that reference another image. The latter is based on suffix (.jpg, .gif and .png).","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"19":{"codeB":"private StyleProp createProps(StyleProp prop,String style){\n\tint nameEnd;\n\tint valueEnd;\n\tint nameStart=0;\n\tboolean more;\n\twhile(nameStart < style.length()){\n\t\twhile(nameStart < style.length() && style.charAt(nameStart) == ' '){\n\t\t}\n\t\twhile(nameEnd < style.length()){\n\t\t\t++nameEnd;\n\t\t}\n\t\twhile(valueStart < style.length() && style.charAt(valueStart) == ' '){\n\t\t\t++valueStart;\n\t\t}\n\t\tvalueEnd=valueStart;\n\t\twhile(valueEnd < style.length()){\n\t\t\tif(style.charAt(valueEnd) == ';'){\n\t\t\t\tmore=true;\n\t\t\t}\n\t\t\t++valueEnd;\n\t\t}\n\t\tprop=insertProperty(prop,style.substring(nameStart,nameEnd),style.substring(valueStart,valueEnd));\n\t}\n\treturn prop;\n}","practice":false,"codeA":"private void createStyleElement(Lexer lexer,Node doc){\n\tNode node, head, body;\n\tStyle style;\n\tAttVal av;\n\tav=new AttVal(null,null,'\"',\"type\",\"text/css\");\n\tbody=doc.findBody(lexer.configuration.tt);\n\tlexer.txtstart=lexer.lexsize;\n\tfor (style=lexer.styles; style != null; style=style.next){\n\t\tlexer.addCharToLexer(' ');\n\t\tlexer.addStringLiteral(style.tag);\n\t\tlexer.addCharToLexer('.');\n\t\tlexer.addStringLiteral(style.tagClass);\n\t\tlexer.addCharToLexer(' ');\n\t\tlexer.addCharToLexer('{');\n\t\tlexer.addStringLiteral(style.properties);\n\t\tlexer.addCharToLexer('}');\n\t\tlexer.addCharToLexer('\\n');\n\t}\n\tlexer.txtend=lexer.lexsize;\n\thead=doc.findHEAD(lexer.configuration.tt);\n}","method":2,"docB":"Create sorted linked list of properties from style string.","docA":"Create style element using rules from dictionary.","correctSolution":0,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"1":{"codes":["public static String toString(JSONObject jo) throws JSONException {\n\tStringBuffer sb=new StringBuffer();\n\tint i;\n\tJSONArray ja;\n\tString key;\n\tIterator keys;\n\tint length;\n\tObject object;\n\tString tagName;\n\tString value;\n\ttagName=jo.optString(\"tagName\");\n\tif(tagName == null){\n\t\treturn XML.escape(jo.toString());\n\t}\n\tXML.noSpace(tagName);\n\ttagName=XML.escape(tagName);\n\tsb.append('<');\n\tsb.append(tagName);\n\tkeys=jo.keys();\n\twhile(keys.hasNext()){\n\t\tkey=keys.next().toString();\n\t\tif(!\"tagName\".equals(key) && !\"childNodes\".equals(key)){\n\t\t\tXML.noSpace(key);\n\t\t\tvalue=jo.optString(key);\n\t\t\tif(value != null){\n\t\t\t\tsb.append(' ');\n\t\t\t\tsb.append(XML.escape(key));\n\t\t\t\tsb.append('=');\n\t\t\t\tsb.append('\"');\n\t\t\t\tsb.append(XML.escape(value));\n\t\t\t\tsb.append('\"');\n\t\t\t}\n\t\t}\n\t}\n\tja=jo.optJSONArray(\"childNodes\");\n\tif(ja == null){\n\t\tsb.append('/');\n\t\tsb.append('>');\n\t} else {\n\t\tsb.append('>');\n\t\tlength=ja.length();\n\t\tfor (i=0; i < length; i+=1){\n\t\t\tobject=ja.get(i);\n\t\t\tif(object != null){\n\t\t\t\tif(object instanceof String){\n\t\t\t\t\tsb.append(XML.escape(object.toString()));\n\t\t\t\t} else if(object instanceof JSONObject){\n\t\t\t\t\tsb.append(toString((JSONObject)object));\n\t\t\t\t} else if(object instanceof JSONArray){\n\t\t\t\t\tsb.append(toString((JSONArray)object));\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(object.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsb.append('<');\n\t\tsb.append('/');\n\t\tsb.append(tagName);\n\t\tsb.append('>');\n\t}\n\treturn sb.toString();\n}","public static String toString(JSONArray ja) throws JSONException {\n\tint i;\n\tJSONObject jo;\n\tString key;\n\tIterator keys;\n\tint length;\n\tObject object;\n\tStringBuffer sb=new StringBuffer();\n\tString tagName;\n\tString value;\n\ttagName=ja.getString(0);\n\tXML.noSpace(tagName);\n\ttagName=XML.escape(tagName);\n\tsb.append('<');\n\tsb.append(tagName);\n\tobject=ja.opt(1);\n\tif(object instanceof JSONObject){\n\t\ti=2;\n\t\tjo=(JSONObject)object;\n\t\tkeys=jo.keys();\n\t\twhile(keys.hasNext()){\n\t\t\tkey=keys.next().toString();\n\t\t\tXML.noSpace(key);\n\t\t\tvalue=jo.optString(key);\n\t\t\tif(value != null){\n\t\t\t\tsb.append(' ');\n\t\t\t\tsb.append(XML.escape(key));\n\t\t\t\tsb.append('=');\n\t\t\t\tsb.append('\"');\n\t\t\t\tsb.append(XML.escape(value));\n\t\t\t\tsb.append('\"');\n\t\t\t}\n\t\t}\n\t} else {\n\t\ti=1;\n\t}\n\tlength=ja.length();\n\tif(i >= length){\n\t\tsb.append('/');\n\t\tsb.append('>');\n\t} else {\n\t\tsb.append('>');\n\t\tdo{\n\t\t\tobject=ja.get(i);\n\t\t\ti+=1;\n\t\t\tif(object != null){\n\t\t\t\tif(object instanceof String){\n\t\t\t\t\tsb.append(XML.escape(object.toString()));\n\t\t\t\t} else if(object instanceof JSONObject){\n\t\t\t\t\tsb.append(toString((JSONObject)object));\n\t\t\t\t} else if(object instanceof JSONArray){\n\t\t\t\t\tsb.append(toString((JSONArray)object));\n\t\t\t\t}\n\t\t\t}\n\t\t}while(i < length)\n\t\tsb.append('<');\n\t\tsb.append('/');\n\t\tsb.append(tagName);\n\t\tsb.append('>');\n\t}\n\treturn sb.toString();\n}","public static String valueToString(Object value) throws JSONException {\n\tif(value == null || value.equals(null)){\n\t\treturn \"null\";\n\t}\n\tif(value instanceof JSONString){\n\t\tObject object;\n\t\ttry {\n\t\t\tobject=((JSONString)value).toJSONString();\n\t\t} catch (Exception e){\n\t\t\tthrow new JSONException(e);\n\t\t} \n\t\tif(object instanceof String){\n\t\t\treturn (String)object;\n\t\t}\n\t\tthrow new JSONException(\"Bad value from toJSONString: \" + object);\n\t}\n\tif(value instanceof Number){\n\t\treturn numberToString((Number)value);\n\t}\n\tif(value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray){\n\t\treturn value.toString();\n\t}\n\tif(value instanceof Map){\n\t\treturn new JSONObject((Map)value).toString();\n\t}\n\tif(value instanceof Collection){\n\t\treturn new JSONArray((Collection)value).toString();\n\t}\n\tif(value.getClass().isArray()){\n\t\treturn new JSONArray(value).toString();\n\t}\n\treturn quote(value.toString());\n}","private String nextString(char quote) throws IOException {\n\tchar[] buffer=this.buffer;\n\tStringBuilder builder=null;\n\twhile(true){\n\t\tint p=pos;\n\t\tint l=limit;\n\t\tint start=p;\n\t\twhile(p < l){\n\t\t\tint c=buffer[p++];\n\t\t\tif(c == quote){\n\t\t\t\tpos=p;\n\t\t\t\tif(skipping){\n\t\t\t\t\treturn \"skipped!\";\n\t\t\t\t} else if(builder == null){\n\t\t\t\t\treturn stringPool.get(buffer,start,p - start - 1);\n\t\t\t\t} else {\n\t\t\t\t\tbuilder.append(buffer,start,p - start - 1);\n\t\t\t\t\treturn builder.toString();\n\t\t\t\t}\n\t\t\t} else if(c == '\\\\'){\n\t\t\t\tpos=p;\n\t\t\t\tif(builder == null){\n\t\t\t\t\tbuilder=new StringBuilder();\n\t\t\t\t}\n\t\t\t\tbuilder.append(buffer,start,p - start - 1);\n\t\t\t\tbuilder.append(readEscapeCharacter());\n\t\t\t\tp=pos;\n\t\t\t\tl=limit;\n\t\t\t\tstart=p;\n\t\t\t}\n\t\t}\n\t\tif(builder == null){\n\t\t\tbuilder=new StringBuilder();\n\t\t}\n\t\tbuilder.append(buffer,start,p - start);\n\t\tpos=p;\n\t\tif(!fillBuffer(1)){\n\t\t\tthrow syntaxError(\"Unterminated string\");\n\t\t}\n\t}\n}","String toString(int indentFactor,int indent) throws JSONException {\n\tint len=this.length();\n\tif(len == 0){\n\t\treturn \"[]\";\n\t}\n\tint i;\n\tStringBuffer sb=new StringBuffer(\"[\");\n\tif(len == 1){\n\t\tsb.append(JSONObject.valueToString(this.myArrayList.get(0),indentFactor,indent));\n\t} else {\n\t\tint newindent=indent + indentFactor;\n\t\tsb.append('\\n');\n\t\tfor (i=0; i < len; i+=1){\n\t\t\tif(i > 0){\n\t\t\t\tsb.append(\",\\n\");\n\t\t\t}\n\t\t\tfor (int j=0; j < newindent; j+=1){\n\t\t\t\tsb.append(' ');\n\t\t\t}\n\t\t\tsb.append(JSONObject.valueToString(this.myArrayList.get(i),indentFactor,newindent));\n\t\t}\n\t\tsb.append('\\n');\n\t\tfor (i=0; i < indent; i+=1){\n\t\t\tsb.append(' ');\n\t\t}\n\t}\n\tsb.append(']');\n\treturn sb.toString();\n}"],"practice":true,"method":0,"correctSolution":2,"doc":" Make a JSON text of an Object value. If the object has an value.toJSONString() method, then that method will be used to produce the JSON text. The method is required to produce a strictly conforming text.","type":"T1"},"2":{"codes":["public static String toString(JSONObject jo) throws JSONException {\n\tStringBuffer sb=new StringBuffer();\n\tint i;\n\tJSONArray ja;\n\tString key;\n\tIterator keys;\n\tObject object;\n\tString tagName;\n\tString value;\n\twhile(keys.hasNext()){\n\t\tkey=keys.next().toString();\n\t\tif(!\"tagName\".equals(key) && !\"childNodes\".equals(key)){\n\t\t\tXML.noSpace(key);\n\t\t\tvalue=jo.optString(key);\n\t\t\tif(value != null){\n\t\t\t\tsb.append(XML.escape(key));\n\t\t\t\tsb.append(XML.escape(value));\n\t\t\t}\n\t\t}\n\t}\n\tja=jo.optJSONArray(\"childNodes\");\n\tif(ja == null){\n\t} else {\n\t\tlength=ja.length();\n\t\tfor (i=0; i < length; i+=1){\n\t\t\tif(object != null){\n\t\t\t\tif(object instanceof String){\n\t\t\t\t\tsb.append(XML.escape(object.toString()));\n\t\t\t\t} else if(object instanceof JSONObject){\n\t\t\t\t\tsb.append(toString((JSONObject)object));\n\t\t\t\t} else \n\t\t\t}\n\t\t}\n\t}\n}","public static String toString(JSONArray ja) throws JSONException {\n\tint i;\n\tJSONObject jo;\n\tString key;\n\tIterator keys;\n\tObject object;\n\tStringBuffer sb=new StringBuffer();\n\tString tagName;\n\tString value;\n\tif(object instanceof JSONObject){\n\t\twhile(keys.hasNext()){\n\t\t\tkey=keys.next().toString();\n\t\t\tXML.noSpace(key);\n\t\t\tvalue=jo.optString(key);\n\t\t\tif(value != null){\n\t\t\t\tsb.append(XML.escape(key));\n\t\t\t\tsb.append(XML.escape(value));\n\t\t\t}\n\t\t}\n\t} else {\n\t}\n\tif(i >= length){\n\t} else {\n\t\tdo{\n\t\t\tobject=ja.get(i);\n\t\t\tif(object != null){\n\t\t\t\tif(object instanceof String){\n\t\t\t\t\tsb.append(XML.escape(object.toString()));\n\t\t\t\t} else if(object instanceof JSONObject){\n\t\t\t\t\tsb.append(toString((JSONObject)object));\n\t\t\t\t} else \n\t\t\t}\n\t\t}while(i < length)\n\t}\n}","public static String valueToString(Object value) throws JSONException {\n\tif(value instanceof JSONString){\n\t\tObject object;\n\t\ttry {\n\t\t\tobject=((JSONString)value).toJSONString();\n\t\t} catch (Exception e){\n\t\t} \n\t\tthrow new JSONException(\"Bad value from toJSONString: \" + object);\n\t}\n\tif(value instanceof Boolean || value instanceof JSONObject || value instanceof JSONArray){\n\t\treturn value.toString();\n\t}\n\tif(value instanceof Collection){\n\t\treturn new JSONArray((Collection)value).toString();\n\t}\n\tif(value.getClass().isArray()){\n\t\treturn new JSONArray(value).toString();\n\t}\n\treturn quote(value.toString());\n}","private String nextString(char quote) throws IOException {\n\tchar[] buffer=this.buffer;\n\tStringBuilder builder=null;\n\twhile(true){\n\t\tint p=pos;\n\t\tint l=limit;\n\t\twhile(p < l){\n\t\t\tint c=buffer[p++];\n\t\t\tif(c == quote){\n\t\t\t\tpos=p;\n\t\t\t\tif(skipping){\n\t\t\t\t\treturn \"skipped!\";\n\t\t\t\t} else if(builder == null){\n\t\t\t\t\treturn stringPool.get(buffer,start,p - start - 1);\n\t\t\t\t} else {\n\t\t\t\t\treturn builder.toString();\n\t\t\t\t}\n\t\t\t} else if(c == '\\\\'){\n\t\t\t\tp=pos;\n\t\t\t}\n\t\t}\n\t\tpos=p;\n\t}\n}","String toString(int indentFactor,int indent) throws JSONException {\n\tint len=this.length();\n\tif(len == 0){\n\t\treturn \"[]\";\n\t}\n\tint i;\n\tStringBuffer sb=new StringBuffer(\"[\");\n\tif(len == 1){\n\t\tsb.append(JSONObject.valueToString(this.myArrayList.get(0),indentFactor,indent));\n\t} else {\n\t\tint newindent=indent + indentFactor;\n\t\tfor (i=0; i < len; i+=1){\n\t\t\tsb.append(JSONObject.valueToString(this.myArrayList.get(i),indentFactor,newindent));\n\t\t}\n\t\tfor (i=0; i < indent; i+=1){\n\t\t}\n\t}\n}"],"practice":true,"method":2,"correctSolution":2,"doc":" Make a JSON text of an Object value. If the object has an value.toJSONString() method, then that method will be used to produce the JSON text. The method is required to produce a strictly conforming text.","type":"T1"},"3":{"codes":["private static NodePointer doPredicateName(EvalContext context,NodePointer parent,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tNodePointer child=valuePointer(parent);\n\tif(child instanceof PropertyOwnerPointer){\n\t\tPropertyPointer pointer=((PropertyOwnerPointer)child).getPropertyPointer();\n\t\tif(pointer.isActual()){\n\t\t\treturn doPredicate(context,pointer,steps,currentStep,predicates,currentPredicate + 1);\n\t\t}\n\t} else if(child.isCollection()){\n\t\tNodePointer bestMatch=null;\n\t\tint bestQuality=0;\n\t\tint count=child.getLength();\n\t\tfor (int i=0; i < count; i++){\n\t\t\tchild.setIndex(i);\n\t\t\tNodePointer valuePointer=valuePointer(child);\n\t\t\tNodePointer pointer;\n\t\t\tif((valuePointer instanceof PropertyOwnerPointer) || valuePointer.isCollection()){\n\t\t\t\tpointer=doPredicateName(context,valuePointer,steps,currentStep,predicates,currentPredicate);\n\t\t\t} else if(isNameAttributeEqual(valuePointer,key)){\n\t\t\t\tpointer=doPredicate(context,valuePointer,steps,currentStep,predicates,currentPredicate + 1);\n\t\t\t} else {\n\t\t\t\tpointer=null;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tNodePointer found=doPredicatesStandard(context,Collections.singletonList(child),steps,currentStep,predicates,currentPredicate);\n\t}\n\treturn createNullPointerForPredicates(context,child,steps,currentStep,predicates,currentPredicate);\n}","private static NodePointer doStepPredicatesStandard(EvalContext context,NodePointer parent,Step[] steps,int currentStep){\n\tStep step=steps[currentStep];\n\tExpression[] predicates=step.getPredicates();\n\tint axis=step.getAxis();\n\tExpression predicate=predicates[0];\n\tif(predicates.length == 1){\n\t\tNodeIterator it=getNodeIterator(context,parent,step);\n\t\tNodePointer pointer=null;\n\t\tif(it != null){\n\t\t\tif(predicate instanceof NameAttributeTest){\n\t\t\t\tString key=keyFromPredicate(context,predicate);\n\t\t\t\tfor (int i=1; it.setPosition(i); i++){\n\t\t\t\t\tNodePointer ptr=it.getNodePointer();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint index=indexFromPredicate(context,predicate);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tNodeIterator it=getNodeIterator(context,parent,step);\n\t\tif(it != null){\n\t\t\tList list=new ArrayList();\n\t\t\tNodePointer pointer=doPredicatesStandard(context,list,steps,currentStep,predicates,0);\n\t\t}\n\t}\n\treturn createNullPointer(context,parent,steps,currentStep);\n}","private static NodePointer doPredicatesStandard(EvalContext context,List parents,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tif(currentPredicate == predicates.length){\n\t\treturn doStep(context,pointer,steps,currentStep + 1);\n\t}\n\tExpression predicate=predicates[currentPredicate];\n\tif(predicate instanceof NameAttributeTest){\n\t\tString key=keyFromPredicate(context,predicate);\n\t\tList newList=new ArrayList();\n\t\tfor (int i=0; i < parents.size(); i++){\n\t\t}\n\t\treturn doPredicatesStandard(context,newList,steps,currentStep,predicates,currentPredicate + 1);\n\t} else {\n\t\tint index=indexFromPredicate(context,predicate);\n\t\tif(index < 0 || index >= parents.size()){\n\t\t\treturn null;\n\t\t}\n\t\treturn doPredicate(context,ptr,steps,currentStep,predicates,currentPredicate + 1);\n\t}\n}","private static NodePointer doStepNoPredicatesPropertyOwner(EvalContext context,PropertyOwnerPointer parentPointer,Step[] steps,int currentStep){\n\tNodePointer childPointer=createChildPointerForStep(parentPointer,step);\n\tif(childPointer.isCollection()){\n\t\tint bestQuality=0;\n\t\tchildPointer=(NodePointer)childPointer.clone();\n\t\tNodePointer bestMatch=null;\n\t\tint count=childPointer.getLength();\n\t\tfor (int i=0; i < count; i++){\n\t\t\tchildPointer.setIndex(i);\n\t\t\tNodePointer pointer=doStep(context,childPointer,steps,currentStep + 1);\n\t\t\tint quality=computeQuality(pointer);\n\t\t\tif(quality == PERFECT_MATCH){\n\t\t\t\treturn pointer;\n\t\t\t} else if(quality > bestQuality){\n\t\t\t\tbestQuality=quality;\n\t\t\t}\n\t\t}\n\t\treturn createNullPointer(context,childPointer,steps,currentStep);\n\t}\n\treturn doStep(context,childPointer,steps,currentStep + 1);\n}","private static NodePointer doPredicate(EvalContext context,NodePointer parent,Step[] steps,int currentStep,Expression[] predicates,int currentPredicate){\n\tif(currentPredicate == predicates.length){\n\t\treturn doStep(context,parent,steps,currentStep + 1);\n\t}\n\tif(predicate instanceof NameAttributeTest){\n\t\treturn doPredicateName(context,parent,steps,currentStep,predicates,currentPredicate);\n\t}\n\treturn doPredicateIndex(context,parent,steps,currentStep,predicates,currentPredicate);\n}"],"practice":false,"method":2,"correctSolution":1,"doc":"Process a path that starts with a standard InfoSet node, e.g. a DOM Node. The method evaluates the first predicate in a special way if there is only one predicate in the array, Otherwise it will forward to a general predicate processing method.","type":"T1"},"4":{"codes":["public synchronized void authntlm(String authzid,String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\tString type1Msg=null;\n\tint flags=PropUtil.getIntProperty(props,\"mail.\" + name + \".auth.ntlm.flags\",0);\n\tString domain=props.getProperty(\"mail.\" + name + \".auth.ntlm.domain\",\"\");\n\tNtlm ntlm=new Ntlm(domain,getLocalHost(),u,p,debug ? out : null);\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE NTLM command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE NTLM\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tboolean first=true;\n\t\twhile(!done){\n\t\t\ttry {\n\t\t\t\tr=readResponse();\n\t\t\t\tif(r.isContinuation()){\n\t\t\t\t\tString s;\n\t\t\t\t\tif(first){\n\t\t\t\t\t\ts=ntlm.generateType1Msg(flags);\n\t\t\t\t\t\tfirst=false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts=ntlm.generateType3Msg(r.getRest());\n\t\t\t\t\t}\n\t\t\t\t\tos.write(ASCIIUtility.getBytes(s));\n\t\t\t\t\tos.write(CRLF);\n\t\t\t\t\tos.flush();\n\t\t\t\t} else if(r.isTagged() && r.getTag().equals(tag))\n\t\t\t\t\tdone=true;\n\t\t\t\telse if(r.isBYE())\n\t\t\t\t\tdone=true;\n\t\t\t\telse \n\t\t\t\t\tv.addElement(r);\n\t\t\t} catch (Exception ioex){\n\t\t\t\tr=Response.byeResponse(ioex);\n\t\t\t\tdone=true;\n\t\t\t} \n\t\t}\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE NTLM command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}","public boolean auth(AuthenticatingIMAPClient.AUTH_METHOD method,String username,String password) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {\n\tif(!IMAPReply.isContinuation(sendCommand(IMAPCommand.AUTHENTICATE,method.getAuthName()))){\n\t\treturn false;\n\t}\n\tswitch (method){\n\tcase PLAIN:  {\n\t\tint result=sendData(new String(Base64.encodeBase64((\"\\000\" + username + \"\\000\"+ password).getBytes())));\n\t\tif(result == IMAPReply.OK){\n\t\t\tsetState(IMAP.IMAPState.AUTH_STATE);\n\t\t}\n\t\treturn result == IMAPReply.OK;\n\t}\n\tcase CRAM_MD5:  {\n\t\tbyte[] serverChallenge=Base64.decodeBase64(getReplyString().substring(2).trim());\n\t\tMac hmac_md5=Mac.getInstance(\"HmacMD5\");\n\t\thmac_md5.init(new SecretKeySpec(password.getBytes(),\"HmacMD5\"));\n\t\tbyte[] hmacResult=_convertToHexString(hmac_md5.doFinal(serverChallenge)).getBytes();\n\t\tbyte[] usernameBytes=username.getBytes();\n\t\tbyte[] toEncode=new byte[usernameBytes.length + 1 + hmacResult.length];\n\t\tSystem.arraycopy(usernameBytes,0,toEncode,0,usernameBytes.length);\n\t\ttoEncode[usernameBytes.length]=' ';\n\t\tSystem.arraycopy(hmacResult,0,toEncode,usernameBytes.length + 1,hmacResult.length);\n\t\tint result=sendData(new String(Base64.encodeBase64(toEncode)));\n\t\tif(result == IMAPReply.OK){\n\t\t\tsetState(IMAP.IMAPState.AUTH_STATE);\n\t\t}\n\t\treturn result == IMAPReply.OK;\n\t}\n\tcase LOGIN:  {\n\t\tif(sendData(new String(Base64.encodeBase64(username.getBytes()))) != IMAPReply.CONT){\n\t\t\treturn false;\n\t\t}\n\t\tint result=sendData(new String(Base64.encodeBase64(password.getBytes())));\n\t\tif(result == IMAPReply.OK){\n\t\t\tsetState(IMAP.IMAPState.AUTH_STATE);\n\t\t}\n\t\treturn result == IMAPReply.OK;\n\t}\n\t}\n\treturn false;\n}","public synchronized void authlogin(String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE LOGIN command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE LOGIN\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tByteArrayOutputStream bos=new ByteArrayOutputStream();\n\t\tOutputStream b64os=new BASE64EncoderStream(bos,Integer.MAX_VALUE);\n\t\tboolean first=true;\n\t\twhile(!done){\n\t\t\ttry {\n\t\t\t\tr=readResponse();\n\t\t\t\tif(r.isContinuation()){\n\t\t\t\t\tString s;\n\t\t\t\t\tif(first){\n\t\t\t\t\t\ts=u;\n\t\t\t\t\t\tfirst=false;\n\t\t\t\t\t} else \n\t\t\t\t\t\ts=p;\n\t\t\t\t\tb64os.write(ASCIIUtility.getBytes(s));\n\t\t\t\t\tb64os.flush();\n\t\t\t\t\tbos.write(CRLF);\n\t\t\t\t\tos.write(bos.toByteArray());\n\t\t\t\t\tos.flush();\n\t\t\t\t\tbos.reset();\n\t\t\t\t} else if(r.isTagged() && r.getTag().equals(tag))\n\t\t\t\t\tdone=true;\n\t\t\t\telse if(r.isBYE())\n\t\t\t\t\tdone=true;\n\t\t\t\telse \n\t\t\t\t\tv.addElement(r);\n\t\t\t} catch (Exception ioex){\n\t\t\t\tr=Response.byeResponse(ioex);\n\t\t\t\tdone=true;\n\t\t\t} \n\t\t}\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE LOGIN command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}","private boolean authenticate(String user,String passwd) throws MessagingException {\n\tString mechs=session.getProperty(\"mail.\" + name + \".auth.mechanisms\");\n\tif(mechs == null)\n\t\tmechs=defaultAuthenticationMechanisms;\n\tString authzid=getAuthorizationId();\n\tif(authzid == null)\n\t\tauthzid=user;\n\tif(enableSASL){\n\t\tif(debug)\n\t\t\tout.println(\"DEBUG SMTP: Authenticate with SASL\");\n\t\tif(sasllogin(getSASLMechanisms(),getSASLRealm(),authzid,user,passwd))\n\t\t\treturn true;\n\t\tif(debug)\n\t\t\tout.println(\"DEBUG SMTP: SASL authentication failed\");\n\t}\n\tif(debug){\n\t\tout.println(\"DEBUG SMTP: Attempt to authenticate\");\n\t\tout.println(\"DEBUG SMTP: check mechanisms: \" + mechs);\n\t}\n\tStringTokenizer st=new StringTokenizer(mechs);\n\twhile(st.hasMoreTokens()){\n\t\tString m=st.nextToken();\n\t\tString dprop=\"mail.\" + name + \".auth.\"+ m.toLowerCase(Locale.ENGLISH)+ \".disable\";\n\t\tboolean disabled=PropUtil.getBooleanSessionProperty(session,dprop,false);\n\t\tif(disabled){\n\t\t\tif(debug)\n\t\t\t\tout.println(\"DEBUG SMTP: mechanism \" + m + \" disabled by property: \"+ dprop);\n\t\t\tcontinue;\n\t\t}\n\t\tm=m.toUpperCase(Locale.ENGLISH);\n\t\tif(!supportsAuthentication(m)){\n\t\t\tif(debug)\n\t\t\t\tout.println(\"DEBUG SMTP: mechanism \" + m + \" not supported by server\");\n\t\t\tcontinue;\n\t\t}\n\t\tAuthenticator a=(Authenticator)authenticators.get(m);\n\t\tif(a == null){\n\t\t\tif(debug)\n\t\t\t\tout.println(\"DEBUG SMTP: \" + \"no authenticator for mechanism \" + m);\n\t\t\tcontinue;\n\t\t}\n\t\treturn a.authenticate(host,authzid,user,passwd);\n\t}\n\tthrow new AuthenticationFailedException(\"No authentication mechansims supported by both server and client\");\n}","public synchronized void authplain(String authzid,String u,String p) throws ProtocolException {\n\tVector v=new Vector();\n\tString tag=null;\n\tResponse r=null;\n\tboolean done=false;\n\ttry {\n\t\tif(noauthdebug){\n\t\t\tout.println(\"DEBUG IMAP: AUTHENTICATE PLAIN command trace suppressed\");\n\t\t\tsuspendTracing();\n\t\t}\n\t\ttry {\n\t\t\ttag=writeCommand(\"AUTHENTICATE PLAIN\",null);\n\t\t} catch (Exception ex){\n\t\t\tr=Response.byeResponse(ex);\n\t\t\tdone=true;\n\t\t} \n\t\tOutputStream os=getOutputStream();\n\t\tByteArrayOutputStream bos=new ByteArrayOutputStream();\n\t\tOutputStream b64os=new BASE64EncoderStream(bos,Integer.MAX_VALUE);\n\t\twhile(!done){\n\t\t\ttry {\n\t\t\t\tr=readResponse();\n\t\t\t\tif(r.isContinuation()){\n\t\t\t\t\tfinal String nullByte=\"\\0\";\n\t\t\t\t\tString s=(authzid == null ? \"\" : authzid) + nullByte + u+ nullByte+ p;\n\t\t\t\t\tb64os.write(ASCIIUtility.getBytes(s));\n\t\t\t\t\tb64os.flush();\n\t\t\t\t\tbos.write(CRLF);\n\t\t\t\t\tos.write(bos.toByteArray());\n\t\t\t\t\tos.flush();\n\t\t\t\t\tbos.reset();\n\t\t\t\t} else if(r.isTagged() && r.getTag().equals(tag))\n\t\t\t\t\tdone=true;\n\t\t\t\telse if(r.isBYE())\n\t\t\t\t\tdone=true;\n\t\t\t\telse \n\t\t\t\t\tv.addElement(r);\n\t\t\t} catch (Exception ioex){\n\t\t\t\tr=Response.byeResponse(ioex);\n\t\t\t\tdone=true;\n\t\t\t} \n\t\t}\n\t} finally {\n\t\tresumeTracing();\n\t} \n\tResponse[] responses=new Response[v.size()];\n\tv.copyInto(responses);\n\tnotifyResponseHandlers(responses);\n\tif(noauthdebug)\n\t\tout.println(\"DEBUG IMAP: AUTHENTICATE PLAIN command result: \" + r);\n\thandleResult(r);\n\tsetCapabilities(r);\n\tauthenticated=true;\n}"],"practice":false,"method":0,"correctSolution":3,"doc":"Performs the actual protocol-specific connection attempt. Will attempt to connect to \"localhost\" if the host was null. Unless mail.smtp.ehlo is set to false, we'll try to identify ourselves using the ESMTP command EHLO. If mail.smtp.auth is set to true, we insist on having a username and password, and will try to authenticate ourselves if the server supports the AUTH extension (RFC 2554).","type":"T1"},"5":{"codes":["public static boolean check(List constraints,Authenticator authenticator,UserRealm realm,String pathInContext,HttpRequest request,HttpResponse response) throws HttpException, IOException {\n\tint dataConstraint=DC_NONE;\n\tObject roles=null;\n\tboolean unauthenticated=false;\n\tif(dataConstraint > DC_NONE){\n\t\tHttpConnection connection=request.getHttpConnection();\n\t\tHttpListener listener=connection.getListener();\n\t\tswitch (dataConstraint){\n\t\tcase SecurityConstraint.DC_INTEGRAL: \n\t\t\tif(listener.isIntegral(connection))\n\t\t\t\tbreak;\n\t\t\tif(listener.getIntegralPort() > 0){\n\t\t\t\tString url=listener.getIntegralScheme() + \"://\" + request.getHost()+ \":\"+ listener.getIntegralPort()+ request.getPath();\n\t\t\t\tif(request.getQuery() != null)\n\t\t\t\t\turl+=\"?\" + request.getQuery();\n\t\t\t\tresponse.setContentLength(0);\n\t\t\t\tresponse.sendRedirect(url);\n\t\t\t} else \n\t\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t\treturn false;\n\t\tcase SecurityConstraint.DC_CONFIDENTIAL: \n\t\t\tif(listener.isConfidential(connection))\n\t\t\t\tbreak;\n\t\t\tif(listener.getConfidentialPort() > 0){\n\t\t\t\tString url=listener.getConfidentialScheme() + \"://\" + request.getHost()+ \":\"+ listener.getConfidentialPort()+ request.getPath();\n\t\t\t\tif(request.getQuery() != null)\n\t\t\t\t\turl+=\"?\" + request.getQuery();\n\t\t\t\tresponse.setContentLength(0);\n\t\t\t\tresponse.sendRedirect(url);\n\t\t\t} else \n\t\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tHttpContext.sendContextError(response,HttpResponse.__403_Forbidden,null);\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(!unauthenticated && roles != null){\n\t\tif(realm == null){\n\t\t\tHttpContext.sendContextError(response,HttpResponse.__500_Internal_Server_Error,\"Configuration error\");\n\t\t\treturn false;\n\t\t}\n\t\tPrincipal user=null;\n\t\tif(request.getAuthType() != null && request.getAuthUser() != null){\n\t\t\tuser=request.getUserPrincipal();\n\t\t\tif(user == null)\n\t\t\t\tuser=realm.authenticate(request.getAuthUser(),null,request);\n\t\t\tif(user == null && authenticator != null)\n\t\t\t\tuser=authenticator.authenticate(realm,pathInContext,request,response);\n\t\t} else \n\t\tif(user == null)\n\t\t\treturn false;\n\t\telse if(user == __NOBODY)\n\t\t\treturn true;\n\t} else {\n\t}\n\treturn true;\n}","public void handle(HttpRequest request,HttpResponse response) throws HttpException, IOException {\n\tif(!isStarted() || _gracefulStop)\n\t\treturn;\n\tString pathInContext=URI.canonicalPath(request.getPath());\n\tif(_contextPath.length() > 1)\n\t\tpathInContext=pathInContext.substring(_contextPath.length());\n\tif(_redirectNullPath && (pathInContext == null || pathInContext.length() == 0)){\n\t\tStringBuffer buf=request.getRequestURL();\n\t\tbuf.append(\"/\");\n\t\tString q=request.getQuery();\n\t\tif(q != null && q.length() != 0)\n\t\t\tbuf.append(\"?\" + q);\n\t\tresponse.sendRedirect(buf.toString());\n\t\tif(log.isDebugEnabled())\n\t\t\tlog.debug(this + \" consumed all of path \" + request.getPath()+ \", redirect to \"+ buf.toString());\n\t\treturn;\n\t}\n\tString pathParams=null;\n\tint semi=pathInContext.lastIndexOf(';');\n\tif(semi >= 0){\n\t\tint pl=pathInContext.length() - semi;\n\t\tString ep=request.getEncodedPath();\n\t}\n\ttry {\n\t\thandle(pathInContext,pathParams,request,response);\n\t} finally {\n\t\tif(_userRealm != null && request.hasUserPrincipal())\n\t\t\t_userRealm.disassociate(request.getUserPrincipal());\n\t} \n}","public void handle(String pathInContext,String pathParams,HttpRequest httpRequest,HttpResponse httpResponse) throws IOException {\n\tif(!isStarted())\n\t\treturn;\n\tServletHttpRequest request=(ServletHttpRequest)httpRequest.getWrapper();\n\tServletHttpResponse response=(ServletHttpResponse)httpResponse.getWrapper();\n\tMap.Entry servlet=getHolderEntry(pathInContext);\n\tServletHolder servletHolder=servlet == null ? null : (ServletHolder)servlet.getValue();\n\tif(log.isDebugEnabled())\n\t\tlog.debug(\"servlet=\" + servlet);\n\ttry {\n\t\trequest.setRequestedSessionId(pathParams);\n\t\tHttpSession session=request.getSession(false);\n\t\tif(session != null)\n\t\t\t((SessionManager.Session)session).access();\n\t\tif(log.isDebugEnabled())\n\t\t\tlog.debug(\"session=\" + session);\n\t\tif(servletHolder != null)\n\t\t\tdispatch(pathInContext,request,response,servletHolder,Dispatcher.__REQUEST);\n\t} catch (Exception e){\n\t\tlog.debug(LogSupport.EXCEPTION,e);\n\t\tThrowable th=e;\n\t\twhile(th instanceof ServletException){\n\t\t\tlog.warn(LogSupport.EXCEPTION,th);\n\t\t\tThrowable cause=((ServletException)th).getRootCause();\n\t\t\tif(cause == th || cause == null)\n\t\t\t\tbreak;\n\t\t\tth=cause;\n\t\t}\n\t\tif(th instanceof HttpException)\n\t\t\tthrow (HttpException)th;\n\t\thttpResponse.getHttpConnection().forceClose();\n\t\tif(!httpResponse.isCommitted()){\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION_TYPE,th.getClass());\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION,th);\n\t\t} else if(log.isDebugEnabled())\n\t\t\tlog.debug(\"Response already committed for handling \" + th);\n\t} catch (Error e){\n\t\tlog.warn(\"Error for \" + httpRequest.getURI(),e);\n\t\tif(log.isDebugEnabled())\n\t\t\tlog.debug(httpRequest);\n\t\thttpResponse.getHttpConnection().forceClose();\n\t\tif(!httpResponse.isCommitted()){\n\t\t\trequest.setAttribute(ServletHandler.__J_S_ERROR_EXCEPTION,e);\n\t\t\tresponse.sendError(HttpResponse.__500_Internal_Server_Error,e.getMessage());\n\t\t} else if(log.isDebugEnabled())\n\t\t\tlog.debug(\"Response already committed for handling \",e);\n\t} finally {\n\t} \n}","XObject execute(final XPathContext xpathContext,final int contextNode,final PrefixResolver namespaceContext) throws TransformerException {\n\txpathContext.pushNamespaceContext(namespaceContext);\n\txpathContext.pushCurrentNodeAndExpression(contextNode,contextNode);\n\tXObject xobj=null;\n\ttry {\n\t\txobj=mainExp_.execute(xpathContext);\n\t} catch (final TransformerException te){\n\t\tte.setLocator(mainExp_);\n\t\tfinal ErrorListener el=xpathContext.getErrorListener();\n\t} catch (Exception e){\n\t\tString msg=e.getMessage();\n\t\tfinal TransformerException te=new TransformerException(msg,mainExp_,e);\n\t\tfinal ErrorListener el=xpathContext.getErrorListener();\n\t} finally {\n\t\txpathContext.popNamespaceContext();\n\t\txpathContext.popCurrentNodeAndExpression();\n\t} \n\treturn xobj;\n}","public HttpContext service(HttpRequest request,HttpResponse response) throws IOException, HttpException {\n\tString host=request.getHost();\n\tif(_requestsPerGC > 0 && _gcRequests++ > _requestsPerGC){\n\t\t_gcRequests=0;\n\t\tSystem.gc();\n\t}\n\twhile(true){\n\t\tPathMap contextMap=(PathMap)_virtualHostMap.get(host);\n\t\tif(host == null)\n\t\t\tbreak;\n\t}\n\tsynchronized (this){\n\t\tif(_notFoundContext == null){\n\t\t\t_notFoundContext=new HttpContext();\n\t\t\t_notFoundContext.setContextPath(\"/\");\n\t\t\t_notFoundContext.setHttpServer(this);\n\t\t\ttry {\n\t\t\t\t_notFoundContext.addHandler((NotFoundHandler)Class.forName(\"org.openqa.jetty.http.handler.RootNotFoundHandler\").newInstance());\n\t\t\t} catch (Exception e){\n\t\t\t\t_notFoundContext.addHandler(new NotFoundHandler());\n\t\t\t} \n\t\t\taddComponent(_notFoundContext);\n\t\t}\n\t\t_notFoundContext.handle(request,response);\n\t\tif(!request.isHandled())\n\t\t\tresponse.sendError(HttpResponse.__404_Not_Found);\n\t\treturn _notFoundContext;\n\t}\n}"],"practice":false,"method":1,"correctSolution":4,"doc":"Process a http request. Handle the request by passing it to the HttpHandler contained in the mapped HttpContexts. The requests host and path are used to select a list of HttpContexts. Each HttpHandler in these context is offered the request in turn, until the request is handled. If no handler handles the request, 404 Not Found is returned.","type":"T1"},"6":{"codes":["public static JSONObject loadJSON(String resource){\n\tInputStream in=Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);\n\tif(in == null){\n\t\ttry {\n\t\t\tin=new FileInputStream(resource);\n\t\t} catch (FileNotFoundException e){\n\t\t} \n\t}\n\tStringBuilder b=new StringBuilder();\n\tInputStreamReader inputreader=new InputStreamReader(in);\n\tBufferedReader buffreader=new BufferedReader(inputreader);\n\tString line;\n\ttry {\n\t\twhile((line=buffreader.readLine()) != null){\n\t\t}\n\t} catch (IOException e){\n\t} \n\tString json=b.toString();\n\tJSONObject o;\n\treturn o;\n}","public Resource getResource(String pathInContext) throws IOException {\n\tif(_resourceBase == null)\n\t\treturn null;\n\tResource resource=null;\n\tsynchronized (_cache){\n\t\tCachedResource cached=(CachedResource)_cache.get(pathInContext);\n\t\tif(resource.getAlias() != null){\n\t\t\tlog.warn(\"Alias request of '\" + resource.getAlias() + \"' for '\"+ resource+ \"'\");\n\t\t\treturn null;\n\t\t}\n\t\tif(resource.exists()){\n\t\t\tif(resource.isDirectory()){\n\t\t\t\tif(resource.list() != null)\n\t\t\t\telse \n\t\t\t\t\tlen=0;\n\t\t\t}\n\t\t\tif(len > 0 && len < _maxCachedFileSize && len < _maxCacheSize){\n\t\t\t\tint needed=_maxCacheSize - (int)len;\n\t\t\t\twhile(_cacheSize > needed)\n\t\t\t\t\t_leastRecentlyUsed.invalidate();\n\t\t\t\tcached=resource.cache();\n\t\t\t\tnew CachedMetaData(cached,pathInContext);\n\t\t\t\treturn cached;\n\t\t\t}\n\t\t}\n\t}\n\treturn resource;\n}","public void loadFromGridYml(String resource){\n\tInputStream in=Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);\n\tif(in == null){\n\t\ttry {\n\t\t\tin=new FileInputStream(resource);\n\t\t} catch (FileNotFoundException e){\n\t\t} \n\t}\n\tYaml yaml=new Yaml();\n\tMap<String,Object> hub=(Map<String,Object>)config.get(\"hub\");\n\tList<Map<String,String>> environments=(List<Map<String,String>>)hub.get(\"environments\");\n\tInteger p=(Integer)hub.get(\"port\");\n\tfor (Map<String,String> environment : environments){\n\t\tgetGrid1Mapping().put(environment.get(\"name\"),environment.get(\"browser\"));\n\t}\n\tInteger poll=(Integer)hub.get(\"remoteControlPollingIntervalInSeconds\");\n\tif(poll != null){\n\t\tallParams.put(RegistrationRequest.NODE_POLLING,poll.intValue() * 1000);\n\t\tcleanupCycle=poll.intValue() * 1000;\n\t}\n\tInteger timeout=(Integer)hub.get(\"sessionMaxIdleTimeInSeconds\");\n\tInteger port=(Integer)hub.get(RegistrationRequest.PORT);\n\tInteger newSessionWait=(Integer)hub.get(\"newSessionMaxWaitTimeInSeconds\");\n\tallParams.put(RegistrationRequest.MAX_SESSION,1);\n}","public static Resource newResource(String resource) throws MalformedURLException, IOException {\n\tURL url=null;\n\ttry {\n\t\turl=new URL(resource);\n\t} catch (MalformedURLException e){\n\t\tif(!resource.startsWith(\"ftp:\") && !resource.startsWith(\"file:\") && !resource.startsWith(\"jar:\")){\n\t\t\ttry {\n\t\t\t\tFile file=new File(resource).getCanonicalFile();\n\t\t\t\turl=file.toURI().toURL();\n\t\t\t\tURLConnection connection=url.openConnection();\n\t\t\t\tFileResource fileResource=new FileResource(url,connection,file);\n\t\t\t\treturn fileResource;\n\t\t\t} catch (Exception e2){\n\t\t\t} \n\t\t} else {\n\t\t\tlog.warn(\"Bad Resource: \" + resource);\n\t\t\tthrow e;\n\t\t}\n\t} \n\treturn newResource(url);\n}","public String getListHTML(String base,boolean parent) throws IOException {\n\tif(!isDirectory())\n\t\treturn null;\n\tString[] ls=list();\n\tif(ls == null)\n\t\treturn null;\n\tArrays.sort(ls);\n\tString title=\"Directory: \" + URI.decodePath(base);\n\tStringBuffer buf=new StringBuffer(4096);\n\tbuf.append(\"<HTML><HEAD><TITLE>\");\n\tbuf.append(\"<\/TITLE><\/HEAD><BODY>\\n<H1>\");\n\tif(parent){\n\t\tbuf.append(URI.encodePath(URI.addPaths(base,\"../\")));\n\t}\n\tDateFormat dfmt=DateFormat.getDateTimeInstance(DateFormat.MEDIUM,DateFormat.MEDIUM);\n\tfor (int i=0; i < ls.length; i++){\n\t\tString encoded=URI.encodePath(ls[i]);\n\t\tResource item=addPath(encoded);\n\t\tString path=URI.addPaths(base,encoded);\n\t}\n\tbuf.append(\"<\/BODY><\/HTML>\\n\");\n\treturn buf.toString();\n}"],"practice":false,"method":2,"correctSolution":1,"doc":"Get a resource from the context. Cached Resources are returned if the resource fits within the LRU cache.  Directories may have CachedResources returned, but the caller must use the CachedResource.setCachedData method to set the formatted directory content.","type":"T1"},"7":{"codes":["protected void scandir(File dir,String vpath,boolean fast){\n\tif(dir == null){\n\t\tthrow new BuildException(\"dir must not be null.\");\n\t} else if(!dir.exists()){\n\t\tthrow new BuildException(dir + \" doesn't exists.\");\n\t} else if(!dir.isDirectory()){\n\t\tthrow new BuildException(dir + \" is not a directory.\");\n\t}\n\tif(fast && hasBeenScanned(vpath)){\n\t\treturn;\n\t}\n\tsetState(\"Scan directory: %s\",vpath);\n\tString[] newfiles=dir.list();\n\tif(newfiles == null){\n\t\tthrow new BuildException(\"IO error scanning directory \" + dir.getAbsolutePath());\n\t}\n\tif(!followSymlinks){\n\t\tList<String> noLinks=new ArrayList<String>();\n\t\tfor (int i=0; i < newfiles.length; i++){\n\t\t\ttry {\n\t\t\t\tif(FILE_UTILS.isSymbolicLink(dir,newfiles[i])){\n\t\t\t\t\tString name=vpath + newfiles[i];\n\t\t\t\t\tFile file=new File(dir,newfiles[i]);\n\t\t\t\t\t(file.isDirectory() ? dirsExcluded : filesExcluded).add(name);\n\t\t\t\t} else {\n\t\t\t\t\tnoLinks.add(newfiles[i]);\n\t\t\t\t}\n\t\t\t} catch (IOException ioe){\n\t\t\t\tString msg=\"IOException caught while checking \" + \"for links, couldn't get canonical path!\";\n\t\t\t\tSystem.err.println(msg);\n\t\t\t\tnoLinks.add(newfiles[i]);\n\t\t\t} \n\t\t}\n\t\tnewfiles=noLinks.toArray(new String[noLinks.size()]);\n\t}\n\tfor (int i=0; i < newfiles.length; i++){\n\t\tString name=vpath + newfiles[i];\n\t\tFile file=new File(dir,newfiles[i]);\n\t\tif(file.isDirectory()){\n\t\t\tif(isIncluded(name)){\n\t\t\t\taccountForIncludedDir(name,file,fast);\n\t\t\t} else {\n\t\t\t\teverythingIncluded=false;\n\t\t\t\tdirsNotIncluded.add(name);\n\t\t\t\tif(fast && couldHoldIncluded(name) && !contentsExcluded(name)){\n\t\t\t\t\tscandir(file,name + File.separator,fast);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!fast){\n\t\t\t\tscandir(file,name + File.separator,fast);\n\t\t\t}\n\t\t} else if(file.isFile()){\n\t\t\tif(isIncluded(name)){\n\t\t\t\taccountForIncludedFile(name,file,dir);\n\t\t\t} else {\n\t\t\t\teverythingIncluded=false;\n\t\t\t\tfilesNotIncluded.add(name);\n\t\t\t}\n\t\t}\n\t}\n}","public DiffScope processDiffUnit(DiffUnit diffUnit,DiffPointProcessor processor){\n\tString scopedPath=diffUnit.getScopedPath();\n\tfor (Iterator<Pattern> it=excludes.iterator(); it.hasNext(); ){\n\t\tPattern pattern=it.next();\n\t\tif(pattern.matcher(scopedPath).matches()){\n\t\t\tlog.debug(\"Skipping unit due to exclude: \" + scopedPath);\n\t\t\treturn null;\n\t\t}\n\t}\n\tlog.debug(\"Processing unit \" + scopedPath);\n\tboolean leftExists=diffUnit.leftExists();\n\tboolean rightExists=diffUnit.rightExists();\n\tboolean leftIsDir=diffUnit.leftIsDir();\n\tboolean rightIsDir=diffUnit.rightIsDir();\n\tif(leftExists && !rightExists){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Exists in left only\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(rightExists && !leftExists){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Exists in right only\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(leftIsDir != rightIsDir){\n\t\tDiffPoint diffPoint=new DiffPoint(diffUnit,\"Dir/File mismatch\");\n\t\tprocessor.processDiffPoint(diffPoint);\n\t} else if(!leftIsDir && !rightIsDir){\n\t\tboolean foundHandler=false;\n\t\tfor (Iterator<Map.Entry<String,DiffUnitProcessor>> it=fileHandlers.entrySet().iterator(); it.hasNext(); ){\n\t\t\tMap.Entry<String,DiffUnitProcessor> entry=it.next();\n\t\t\tString regex=entry.getKey();\n\t\t\tif(scopedPath.matches(regex)){\n\t\t\t\tDiffUnitProcessor fileHandler=entry.getValue();\n\t\t\t\tDiffScope childScope=fileHandler.processDiffUnit(diffUnit,processor);\n\t\t\t\tif(childScope != null){\n\t\t\t\t\tchildScope.scan(this,processor);\n\t\t\t\t}\n\t\t\t\tfoundHandler=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!foundHandler){\n\t\t\tlog.error(\"No applicable handler found for path: \" + scopedPath);\n\t\t}\n\t}\n\treturn null;\n}","protected void slowScan(){\n\tsynchronized (slowScanLock){\n\t\tif(haveSlowResults){\n\t\t\treturn;\n\t\t}\n\t\tif(slowScanning){\n\t\t\twhile(slowScanning){\n\t\t\t\ttry {\n\t\t\t\t\tslowScanLock.wait();\n\t\t\t\t} catch (InterruptedException e){\n\t\t\t\t} \n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tslowScanning=true;\n\t}\n\ttry {\n\t\tsynchronized (this){\n\t\t\tfor (String excluded : dirsExcluded){\n\t\t\t\tif(!couldHoldIncluded(excluded)){\n\t\t\t\t\tscandir(new File(basedir,excluded),excluded + File.separator,false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (String notIncluded : dirsNotIncluded){\n\t\t\t\tif(!couldHoldIncluded(notIncluded)){\n\t\t\t\t\tscandir(new File(basedir,notIncluded),notIncluded + File.separator,false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclearCaches();\n\t\t}\n\t} finally {\n\t\tsynchronized (slowScanLock){\n\t\t\thaveSlowResults=true;\n\t\t\tslowScanning=false;\n\t\t\tslowScanLock.notifyAll();\n\t\t}\n\t} \n}","private void checkIncludePatterns(){\n\tHashtable newroots=new Hashtable();\n\tfor (String include : includes){\n\t\tnewroots.put(SelectorUtils.rtrimWildcardTokens(include),include);\n\t}\n\tif(newroots.containsKey(\"\")){\n\t\tscandir(basedir,\"\",true);\n\t} else {\n\t\tEnumeration enum2=newroots.keys();\n\t\tFile canonBase=null;\n\t\ttry {\n\t\t\tcanonBase=basedir.getCanonicalFile();\n\t\t} catch (IOException ex){\n\t\t\tthrow new BuildException(ex);\n\t\t} \n\t\twhile(enum2.hasMoreElements()){\n\t\t\tString currentelement=(String)enum2.nextElement();\n\t\t\tString originalpattern=(String)newroots.get(currentelement);\n\t\t\tFile myfile=new File(basedir,currentelement);\n\t\t\tif(myfile.exists()){\n\t\t\t\ttry {\n\t\t\t\t\tFile canonFile=myfile.getCanonicalFile();\n\t\t\t\t\tString path=FILE_UTILS.removeLeadingPath(canonBase,canonFile);\n\t\t\t\t\tif(!path.equals(currentelement) || ON_VMS){\n\t\t\t\t\t\tmyfile=findFile(basedir,currentelement,true);\n\t\t\t\t\t\tif(myfile != null){\n\t\t\t\t\t\t\tcurrentelement=FILE_UTILS.removeLeadingPath(basedir,myfile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException ex){\n\t\t\t\t\tthrow new BuildException(ex);\n\t\t\t\t} \n\t\t\t}\n\t\t\tif((myfile == null || !myfile.exists()) && !isCaseSensitive()){\n\t\t\t\tFile f=findFile(basedir,currentelement,false);\n\t\t\t\tif(f != null && f.exists()){\n\t\t\t\t\tcurrentelement=FILE_UTILS.removeLeadingPath(basedir,f);\n\t\t\t\t\tmyfile=f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(myfile != null && myfile.exists()){\n\t\t\t\tif(!followSymlinks && isSymlink(basedir,currentelement)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(myfile.isDirectory()){\n\t\t\t\t\tif(isIncluded(currentelement) && currentelement.length() > 0){\n\t\t\t\t\t\taccountForIncludedDir(currentelement,myfile,true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(currentelement.length() > 0){\n\t\t\t\t\t\t\tif(currentelement.charAt(currentelement.length() - 1) != File.separatorChar){\n\t\t\t\t\t\t\t\tcurrentelement=currentelement + File.separatorChar;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscandir(myfile,currentelement,true);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tboolean included=isCaseSensitive() ? originalpattern.equals(currentelement) : originalpattern.equalsIgnoreCase(currentelement);\n\t\t\t\t\tif(included){\n\t\t\t\t\t\taccountForIncludedFile(currentelement,myfile,null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","public void scan() throws IllegalStateException {\n\tsynchronized (scanLock){\n\t\tif(scanning){\n\t\t\twhile(scanning){\n\t\t\t\ttry {\n\t\t\t\t\tscanLock.wait();\n\t\t\t\t} catch (InterruptedException e){\n\t\t\t\t\tcontinue;\n\t\t\t\t} \n\t\t\t}\n\t\t\tif(illegal != null){\n\t\t\t\tthrow illegal;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tscanning=true;\n\t}\n\ttry {\n\t\tsynchronized (this){\n\t\t\tillegal=null;\n\t\t\tclearResults();\n\t\t\tif(basedir == null){\n\t\t\t\tillegal=new IllegalStateException(\"No basedir set\");\n\t\t\t} else {\n\t\t\t\tif(!basedir.exists()){\n\t\t\t\t\tillegal=new IllegalStateException(\"basedir \" + basedir + \" does not exist\");\n\t\t\t\t}\n\t\t\t\tif(!basedir.isDirectory()){\n\t\t\t\t\tillegal=new IllegalStateException(\"basedir \" + basedir + \" is not a directory\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(illegal != null){\n\t\t\t\tthrow illegal;\n\t\t\t}\n\t\t\tif(isIncluded(\"\")){\n\t\t\t\tif(!isExcluded(\"\")){\n\t\t\t\t\tif(isSelected(\"\",basedir)){\n\t\t\t\t\t\tdirsIncluded.add(\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdirsDeselected.add(\"\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdirsExcluded.add(\"\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdirsNotIncluded.add(\"\");\n\t\t\t}\n\t\t\tcheckIncludePatterns();\n\t\t\tclearCaches();\n\t\t}\n\t} finally {\n\t\tsynchronized (scanLock){\n\t\t\tscanning=false;\n\t\t\tscanLock.notifyAll();\n\t\t}\n\t} \n}"],"practice":false,"method":0,"correctSolution":0,"doc":"Scan the given directory for files and directories. Found files and directories are placed in their respective collections, based on the matching of includes, excludes, and the selectors for each file. When a directory is found, it is scanned recursively.","type":"T1"},"8":{"codes":["protected Node parsePI(int start) throws ParserException {\n\tboolean done;\n\tchar ch;\n\tint state;\n\tVector attributes;\n\tint code;\n\tdone=false;\n\tstate=0;\n\tcode=0;\n\tattributes=new Vector();\n\twhile(!done){\n\t\tch=mPage.getCharacter(mCursor);\n\t\tswitch (state){\n\t\tcase 0: \n\t\t\tbreak;\n\t\tcase 1: \n\t\t\tbreak;\n\t\tcase 2: \n\t\t\tswitch (ch){\n\t\t\tcase '>': \n\t\t\t\tstate=3;\n\t\t\t\tdone=true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstate=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\"': \n\t\t\tswitch (ch){\n\t\t\tcase Page.EOF: \n\t\t\t\tdone=true;\n\t\t\t\tbreak;\n\t\t\tcase '\"': \n\t\t\t\tstate=1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\'': \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new IllegalStateException(\"Somehow managed to get into invalid state  \" + state);\n\t\t}\n\t}\n\treturn (makeTag(start,mCursor.getPosition(),attributes));\n}","public static void main(String[] argv) throws IOException, SAXException {\n\tint optind=getopts(options,argv);\n\tif(hasOption(options,\"--version\")){\n\t\tSystem.err.println(\"TagSoup version 1.2.1\");\n\t\treturn;\n\t}\n\tif(argv.length == optind){\n\t\tprocess(\"\",System.out);\n\t} else if(hasOption(options,\"--files\")){\n\t\tfor (int i=optind; i < argv.length; i++){\n\t\t\tString src=argv[i];\n\t\t\tString dst;\n\t\t\tint j=src.lastIndexOf('.');\n\t\t\tSystem.err.println(\"src: \" + src + \" dst: \"+ dst);\n\t\t}\n\t} else {\n\t}\n}","protected void process(NodeFilter filter) throws ParserException {\n\tString url;\n\tint bookmark;\n\tNodeList list;\n\tNodeList robots;\n\tMetaTag robot;\n\tString content;\n\tFile file;\n\tFile dir;\n\ttry {\n\t\tmParser.setURL(url);\n\t\ttry {\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} catch (EncodingChangeException ece){\n\t\t\tmParser.reset();\n\t\t\tlist=new NodeList();\n\t\t\tfor (NodeIterator e=mParser.elements(); e.hasMoreNodes(); )\n\t\t\t\tlist.add(e.nextNode());\n\t\t} \n\t\trobots=list.extractAllNodesThatMatch(new AndFilter(new NodeClassFilter(MetaTag.class),new HasAttributeFilter(\"name\",\"robots\")),true);\n\t\tif(null != filter)\n\t\t\tlist.keepAllNodesThatMatch(filter,true);\n\t\tfile=new File(getTarget(),makeLocalLink(url,\"\"));\n\t\tdir=file.getParentFile();\n\t} catch (ParserException pe){\n\t\tString message;\n\t\tmessage=pe.getMessage();\n\t\tif((null != message) && (message.endsWith(\"does not contain text\"))){\n\t\t\tif(!mCopied.contains(url))\n\t\t\t\tif(!mImages.contains(url))\n\t\t\t\t\tmImages.add(url);\n\t\t\tmFinished.remove(url);\n\t\t} else \n\t\t\tthrow pe;\n\t} \n}","public void run(){\n\tURL link;\n\tint original;\n\tint index;\n\tString href;\n\tURL[][] urls;\n\twhile(true){\n\t\ttry {\n\t\t\tif(null != link){\n\t\t\t\turls=getImageLinks(link);\n\t\t\t\tfetch(urls[0]);\n\t\t\t\tappend(filter(urls[1]));\n\t\t\t} else \n\t\t\t\tThread.sleep(100);\n\t\t\tif(!mActive)\n\t\t} catch (Throwable t){\n\t\t\tt.printStackTrace();\n\t\t} \n\t}\n}","protected void doSAX(Node node) throws ParserException, SAXException {\n\tTag tag;\n\tTag end;\n\tif(node instanceof Remark){\n\t\tString text=mParser.getLexer().getPage().getText(node.getStartPosition(),node.getEndPosition());\n\t\tmContentHandler.ignorableWhitespace(text.toCharArray(),0,text.length());\n\t} else if(node instanceof Text){\n\t\tString text=mParser.getLexer().getPage().getText(node.getStartPosition(),node.getEndPosition());\n\t\ttext=Translate.decode(text);\n\t\tmContentHandler.characters(text.toCharArray(),0,text.length());\n\t} else if(node instanceof Tag){\n\t\ttag=(Tag)node;\n\t\tif(mNameSpacePrefixes)\n\t\t\tmParts[2]=tag.getTagName();\n\t\telse if(mNameSpaces)\n\t\t\tmParts[2]=\"\";\n\t\telse \n\t\t\tmParts[2]=tag.getTagName();\n\t\tNodeList children=tag.getChildren();\n\t\tif(null != children)\n\t\t\tfor (int i=0; i < children.size(); i++)\n\t\t\t\tdoSAX(children.elementAt(i));\n\t}\n}"],"practice":false,"method":1,"correctSolution":3,"doc":"The main processing loop. Pull suspect URLs off the queue one at a time, fetch and parse it, request images and enqueue further links.","type":"T1"},"9":{"codeB":"public JSONObject(JSONTokener x) throws JSONException {\n\tthis();\n\tchar c;\n\tString key;\n\tif(x.nextClean() != '{'){\n\t\tthrow x.syntaxError(\"A JSONObject text must begin with '{'\");\n\t}\n\tfor (; ; ){\n\t\tc=x.nextClean();\n\t\tswitch (c){\n\t\tcase 0: \n\t\t\tthrow x.syntaxError(\"A JSONObject text must end with '}'\");\n\t\tcase '}': \n\t\t\treturn;\n\t\tdefault:\n\t\t\tx.back();\n\t\t\tkey=x.nextValue().toString();\n\t\t}\n\t\tc=x.nextClean();\n\t\tif(c == '='){\n\t\t\tif(x.next() != '>'){\n\t\t\t\tx.back();\n\t\t\t}\n\t\t} else if(c != ':'){\n\t\t\tthrow x.syntaxError(\"Expected a ':' after a key\");\n\t\t}\n\t\tthis.putOnce(key,x.nextValue());\n\t\tswitch (x.nextClean()){\n\t\tcase ';': \n\t\tcase ',': \n\t\t\tif(x.nextClean() == '}'){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tx.back();\n\t\t\tbreak;\n\t\tcase '}': \n\t\t\treturn;\n\t\tdefault:\n\t\t\tthrow x.syntaxError(\"Expected a ',' or '}'\");\n\t\t}\n\t}\n}","practice":true,"codeA":"public JSONArray(JSONTokener x) throws JSONException {\n\tthis();\n\tif(x.nextClean() != '['){\n\t\tthrow x.syntaxError(\"A JSONArray text must start with '['\");\n\t}\n\tif(x.nextClean() != ']'){\n\t\tx.back();\n\t\tfor (; ; ){\n\t\t\tif(x.nextClean() == ','){\n\t\t\t\tx.back();\n\t\t\t\tthis.myArrayList.add(JSONObject.NULL);\n\t\t\t} else {\n\t\t\t\tx.back();\n\t\t\t\tthis.myArrayList.add(x.nextValue());\n\t\t\t}\n\t\t\tswitch (x.nextClean()){\n\t\t\tcase ';': \n\t\t\tcase ',': \n\t\t\t\tif(x.nextClean() == ']'){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tx.back();\n\t\t\t\tbreak;\n\t\t\tcase ']': \n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tthrow x.syntaxError(\"Expected a ',' or ']'\");\n\t\t\t}\n\t\t}\n\t}\n}","method":0,"docB":"Construct a JSONArray from a JSONTokener.","docA":"Construct a JSONObject from a JSONTokener.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"20":{"code_mymethod":{"r15":"public synchronized void connect(String host,int port,String user,String password) throws MessagingException {\n\tPasswordAuthentication pw;\n\tString protocol=null;\n\tString file=null;\n\tif(host == null)\n\t\thost=session.getProperty(\"mail.host\");\n\tif(!connected){\n\t\tInetAddress addr;\n\t\ttry {\n\t\t\taddr=InetAddress.getByName(host);\n\t\t} catch (UnknownHostException e){\n\t\t} \n\t\tpw=session.requestPasswordAuthentication(addr,port,protocol,null,user);\n\t\tif(pw != null){\n\t\t\tpassword=pw.getPassword();\n\t\t}\n\t}\n\tsetURLName(new URLName(protocol,host,port,file,user,password));\n\tsetConnected(true);\n\tnotifyConnectionListeners(ConnectionEvent.OPENED);\n}","r50%":"public synchronized void connect(String host,int port,String user,String password) throws MessagingException {\n\tPasswordAuthentication pw;\n\tString protocol=null;\n\tString file=null;\n\tif(url != null){\n\t\tprotocol=url.getProtocol();\n\t\tif(host == null)\n\t\t\thost=url.getHost();\n\t\tif(user == null){\n\t\t\tif(password == null)\n\t\t\t\tpassword=url.getPassword();\n\t\t} else {\n\t\t\tif(password == null && user.equals(url.getUsername()))\n\t\t\t\tpassword=url.getPassword();\n\t\t}\n\t\tfile=url.getFile();\n\t}\n\tif(protocol != null){\n\t\tif(host == null)\n\t\t\thost=session.getProperty(\"mail.\" + protocol + \".host\");\n\t}\n\tif(host == null)\n\t\thost=session.getProperty(\"mail.host\");\n\tif(password == null && url != null){\n\t\tsetURLName(new URLName(protocol,host,port,file,user,null));\n\t\tpw=session.getPasswordAuthentication(getURLName());\n\t\tif(pw != null){\n\t\t\tif(user == null){\n\t\t\t\tpassword=pw.getPassword();\n\t\t\t} else if(user.equals(pw.getUserName())){\n\t\t\t\tpassword=pw.getPassword();\n\t\t\t}\n\t\t} else \n\t}\n\tif(!connected){\n\t\tInetAddress addr;\n\t\ttry {\n\t\t\taddr=InetAddress.getByName(host);\n\t\t} catch (UnknownHostException e){\n\t\t} \n\t\tpw=session.requestPasswordAuthentication(addr,port,protocol,null,user);\n\t\tif(pw != null){\n\t\t\tpassword=pw.getPassword();\n\t\t\tconnected=protocolConnect(host,port,user,password);\n\t\t}\n\t}\n\tsetURLName(new URLName(protocol,host,port,file,user,password));\n\tsetConnected(true);\n\tnotifyConnectionListeners(ConnectionEvent.OPENED);\n}","r30":"public synchronized void connect(String host,int port,String user,String password) throws MessagingException {\n\tPasswordAuthentication pw;\n\tString protocol=null;\n\tString file=null;\n\tif(url != null){\n\t\tprotocol=url.getProtocol();\n\t\tif(host == null)\n\t\t\thost=url.getHost();\n\t\tif(user == null){\n\t\t\tif(password == null)\n\t\t\t\tpassword=url.getPassword();\n\t\t} else {\n\t\t\tif(password == null && user.equals(url.getUsername()))\n\t\t\t\tpassword=url.getPassword();\n\t\t}\n\t\tfile=url.getFile();\n\t}\n\tif(password == null && url != null){\n\t\tsetURLName(new URLName(protocol,host,port,file,user,null));\n\t\tpw=session.getPasswordAuthentication(getURLName());\n\t}\n\tif(!connected){\n\t\tInetAddress addr;\n\t\ttry {\n\t\t\taddr=InetAddress.getByName(host);\n\t\t} catch (UnknownHostException e){\n\t\t} \n\t\tpw=session.requestPasswordAuthentication(addr,port,protocol,null,user);\n\t\tif(pw != null){\n\t\t\tpassword=pw.getPassword();\n\t\t}\n\t}\n\tsetURLName(new URLName(protocol,host,port,file,user,password));\n\tsetConnected(true);\n\tnotifyConnectionListeners(ConnectionEvent.OPENED);\n}"},"code_native":{"r15":"public synchronized void connect(String host,int port,String user,String password) throws MessagingException {\n\tif(isConnected())\n\t\tthrow new IllegalStateException(\"already connected\");\n\tPasswordAuthentication pw;\n\tboolean connected=false;\n\tboolean save=false;\n\tString protocol=null;\n\tString file=null;\n\tif(host == null)\n\t\thost=session.getProperty(\"mail.host\");\n\tif(user == null)\n\t\tuser=session.getProperty(\"mail.user\");\n\tAuthenticationFailedException authEx=null;\n\tsetURLName(new URLName(protocol,host,port,file,user,password));\n\tsetConnected(true);\n\tnotifyConnectionListeners(ConnectionEvent.OPENED);\n}","r50%":"public synchronized void connect(String host,int port,String user,String password) throws MessagingException {\n\tif(isConnected())\n\t\tthrow new IllegalStateException(\"already connected\");\n\tPasswordAuthentication pw;\n\tboolean connected=false;\n\tboolean save=false;\n\tString protocol=null;\n\tString file=null;\n\tif(url != null){\n\t\tprotocol=url.getProtocol();\n\t\tif(host == null)\n\t\t\thost=url.getHost();\n\t\tif(port == -1)\n\t\t\tport=url.getPort();\n\t\tfile=url.getFile();\n\t}\n\tif(protocol != null){\n\t\tif(host == null)\n\t\t\thost=session.getProperty(\"mail.\" + protocol + \".host\");\n\t\tif(user == null)\n\t\t\tuser=session.getProperty(\"mail.\" + protocol + \".user\");\n\t}\n\tif(host == null)\n\t\thost=session.getProperty(\"mail.host\");\n\tif(user == null)\n\t\tuser=session.getProperty(\"mail.user\");\n\tif(password == null && url != null){\n\t\tsetURLName(new URLName(protocol,host,port,file,user,null));\n\t\tpw=session.getPasswordAuthentication(getURLName());\n\t}\n\tAuthenticationFailedException authEx=null;\n\tif(!connected){\n\t\tif(authEx != null)\n\t\t\tthrow authEx;\n\t\telse if(user == null)\n\t\t\tthrow new AuthenticationFailedException(\"failed to connect, no user name specified?\");\n\t\telse if(password == null)\n\t\t\tthrow new AuthenticationFailedException(\"failed to connect, no password specified?\");\n\t\telse \n\t\t\tthrow new AuthenticationFailedException(\"failed to connect\");\n\t}\n\tsetURLName(new URLName(protocol,host,port,file,user,password));\n\tif(save)\n\tsetConnected(true);\n\tnotifyConnectionListeners(ConnectionEvent.OPENED);\n}","r30":"public synchronized void connect(String host,int port,String user,String password) throws MessagingException {\n\tif(isConnected())\n\t\tthrow new IllegalStateException(\"already connected\");\n\tPasswordAuthentication pw;\n\tboolean connected=false;\n\tboolean save=false;\n\tString protocol=null;\n\tString file=null;\n\tif(url != null){\n\t\tprotocol=url.getProtocol();\n\t\tif(host == null)\n\t\t\thost=url.getHost();\n\t\tif(port == -1)\n\t\t\tport=url.getPort();\n\t\tfile=url.getFile();\n\t}\n\tif(protocol != null){\n\t\tif(host == null)\n\t\t\thost=session.getProperty(\"mail.\" + protocol + \".host\");\n\t\tif(user == null)\n\t\t\tuser=session.getProperty(\"mail.\" + protocol + \".user\");\n\t}\n\tif(host == null)\n\t\thost=session.getProperty(\"mail.host\");\n\tif(user == null)\n\t\tuser=session.getProperty(\"mail.user\");\n\tAuthenticationFailedException authEx=null;\n\tsetURLName(new URLName(protocol,host,port,file,user,password));\n\tif(save)\n\t\tsession.setPasswordAuthentication(getURLName(),new PasswordAuthentication(user,password));\n\tnotifyConnectionListeners(ConnectionEvent.OPENED);\n}"},"method":1,"code_original":"public synchronized void connect(String host,int port,String user,String password) throws MessagingException {\n\tif(isConnected())\n\t\tthrow new IllegalStateException(\"already connected\");\n\tPasswordAuthentication pw;\n\tboolean connected=false;\n\tboolean save=false;\n\tString protocol=null;\n\tString file=null;\n\tif(url != null){\n\t\tprotocol=url.getProtocol();\n\t\tif(host == null)\n\t\t\thost=url.getHost();\n\t\tif(port == -1)\n\t\t\tport=url.getPort();\n\t\tif(user == null){\n\t\t\tuser=url.getUsername();\n\t\t\tif(password == null)\n\t\t\t\tpassword=url.getPassword();\n\t\t} else {\n\t\t\tif(password == null && user.equals(url.getUsername()))\n\t\t\t\tpassword=url.getPassword();\n\t\t}\n\t\tfile=url.getFile();\n\t}\n\tif(protocol != null){\n\t\tif(host == null)\n\t\t\thost=session.getProperty(\"mail.\" + protocol + \".host\");\n\t\tif(user == null)\n\t\t\tuser=session.getProperty(\"mail.\" + protocol + \".user\");\n\t}\n\tif(host == null)\n\t\thost=session.getProperty(\"mail.host\");\n\tif(user == null)\n\t\tuser=session.getProperty(\"mail.user\");\n\tif(user == null){\n\t\ttry {\n\t\t\tuser=System.getProperty(\"user.name\");\n\t\t} catch (SecurityException sex){\n\t\t\tif(debug)\n\t\t\t\tsex.printStackTrace(session.getDebugOut());\n\t\t} \n\t}\n\tif(password == null && url != null){\n\t\tsetURLName(new URLName(protocol,host,port,file,user,null));\n\t\tpw=session.getPasswordAuthentication(getURLName());\n\t\tif(pw != null){\n\t\t\tif(user == null){\n\t\t\t\tuser=pw.getUserName();\n\t\t\t\tpassword=pw.getPassword();\n\t\t\t} else if(user.equals(pw.getUserName())){\n\t\t\t\tpassword=pw.getPassword();\n\t\t\t}\n\t\t} else \n\t\t\tsave=true;\n\t}\n\tAuthenticationFailedException authEx=null;\n\ttry {\n\t\tconnected=protocolConnect(host,port,user,password);\n\t} catch (AuthenticationFailedException ex){\n\t\tauthEx=ex;\n\t} \n\tif(!connected){\n\t\tInetAddress addr;\n\t\ttry {\n\t\t\taddr=InetAddress.getByName(host);\n\t\t} catch (UnknownHostException e){\n\t\t\taddr=null;\n\t\t} \n\t\tpw=session.requestPasswordAuthentication(addr,port,protocol,null,user);\n\t\tif(pw != null){\n\t\t\tuser=pw.getUserName();\n\t\t\tpassword=pw.getPassword();\n\t\t\tconnected=protocolConnect(host,port,user,password);\n\t\t}\n\t}\n\tif(!connected){\n\t\tif(authEx != null)\n\t\t\tthrow authEx;\n\t\telse if(user == null)\n\t\t\tthrow new AuthenticationFailedException(\"failed to connect, no user name specified?\");\n\t\telse if(password == null)\n\t\t\tthrow new AuthenticationFailedException(\"failed to connect, no password specified?\");\n\t\telse \n\t\t\tthrow new AuthenticationFailedException(\"failed to connect\");\n\t}\n\tsetURLName(new URLName(protocol,host,port,file,user,password));\n\tif(save)\n\t\tsession.setPasswordAuthentication(getURLName(),new PasswordAuthentication(user,password));\n\tsetConnected(true);\n\tnotifyConnectionListeners(ConnectionEvent.OPENED);\n}","type":"T3"},"10":{"codeB":"public JSONObject(JSONTokener x) throws JSONException {\n\tthis();\n\tchar c;\n\tString key;\n\tfor (; ; ){\n\t\tc=x.nextClean();\n\t\tswitch (c){\n\t\tcase 0: \n\t\t\tthrow x.syntaxError(\"A JSONObject text must end with '}'\");\n\t\tcase '}': \n\t\t\treturn;\n\t\tdefault:\n\t\t\tkey=x.nextValue().toString();\n\t\t}\n\t\tc=x.nextClean();\n\t\tthis.putOnce(key,x.nextValue());\n\t\tswitch (x.nextClean()){\n\t\tcase ';': \n\t\tcase ',': \n\t\tcase '}': \n\t\t\treturn;\n\t\tdefault:\n\t\t}\n\t}\n}","practice":true,"codeA":"public JSONArray(JSONTokener x) throws JSONException {\n\tthis();\n\tif(x.nextClean() != ']'){\n\t\tfor (; ; ){\n\t\t\tif(x.nextClean() == ','){\n\t\t\t\tthis.myArrayList.add(JSONObject.NULL);\n\t\t\t} else {\n\t\t\t\tx.back();\n\t\t\t\tthis.myArrayList.add(x.nextValue());\n\t\t\t}\n\t\t\tswitch (x.nextClean()){\n\t\t\tcase ';': \n\t\t\tcase ',': \n\t\t\tcase ']': \n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}","method":2,"docB":"Construct a JSONArray from a JSONTokener.","docA":"Construct a JSONObject from a JSONTokener.","correctSolution":1,"type":"T2","Alternatives":["Method A mactches Description A, Method B mactches Description B.","Method A mactches Description B, Method B mactches Description A.","Impossible to decide."]},"21":{"code_mymethod":{"r15":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\treturn newInstance(fallbackClassName,cl,true);\n}","r50%":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\ttry {\n\t\t\t\tif(fLastModified >= 0){\n\t\t\t\t} else {\n\t\t\t\t\tif(propertiesFileExists){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t\tfLastModified=ss.getLastModified(propertiesFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t} \n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\treturn newInstance(fallbackClassName,cl,true);\n}","r30":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\tboolean loadProperties=false;\n\t\t\ttry {\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t} \n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\treturn newInstance(fallbackClassName,cl,true);\n}"},"code_native":{"r15":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(factoryClassName != null){\n\t\treturn newInstance(factoryClassName,cl,true);\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(fallbackClassName == null){\n\t\tthrow new ConfigurationError(\"Provider for \" + factoryId + \" cannot be found\",null);\n\t}\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n\treturn newInstance(fallbackClassName,cl,true);\n}","r50%":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tString javah=ss.getSystemProperty(\"java.home\");\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t\tfLastModified=-1;\n\t\t\tfXercesProperties=null;\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\tboolean loadProperties=false;\n\t\t\ttry {\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t\tfXercesProperties=null;\n\t\t\t\tfLastModified=-1;\n\t\t\t} \n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(DEBUG)\n\treturn newInstance(fallbackClassName,cl,true);\n}","r30":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tString javah=ss.getSystemProperty(\"java.home\");\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t\tfLastModified=-1;\n\t\t\tfXercesProperties=null;\n\t\t} \n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(provider != null){\n\t\treturn provider;\n\t}\n\treturn newInstance(fallbackClassName,cl,true);\n}"},"method":1,"code_original":"static Object createObject(String factoryId,String propertiesFilename,String fallbackClassName) throws ConfigurationError {\n\tif(DEBUG)\n\t\tdebugPrintln(\"debug is on\");\n\tSecuritySupport ss=SecuritySupport.getInstance();\n\tClassLoader cl=findClassLoader();\n\ttry {\n\t\tString systemProp=ss.getSystemProperty(factoryId);\n\t\tif(systemProp != null){\n\t\t\tif(DEBUG)\n\t\t\t\tdebugPrintln(\"found system property, value=\" + systemProp);\n\t\t\treturn newInstance(systemProp,cl,true);\n\t\t}\n\t} catch (SecurityException se){\n\t} \n\tString factoryClassName=null;\n\tif(propertiesFilename == null){\n\t\tFile propertiesFile=null;\n\t\tboolean propertiesFileExists=false;\n\t\ttry {\n\t\t\tString javah=ss.getSystemProperty(\"java.home\");\n\t\t\tpropertiesFilename=javah + File.separator + \"lib\"+ File.separator+ DEFAULT_PROPERTIES_FILENAME;\n\t\t\tpropertiesFile=new File(propertiesFilename);\n\t\t\tpropertiesFileExists=ss.getFileExists(propertiesFile);\n\t\t} catch (SecurityException e){\n\t\t\tfLastModified=-1;\n\t\t\tfXercesProperties=null;\n\t\t} \n\t\tsynchronized (ObjectFactory.class){\n\t\t\tboolean loadProperties=false;\n\t\t\ttry {\n\t\t\t\tif(fLastModified >= 0){\n\t\t\t\t\tif(propertiesFileExists && (fLastModified < (fLastModified=ss.getLastModified(propertiesFile)))){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(!propertiesFileExists){\n\t\t\t\t\t\t\tfLastModified=-1;\n\t\t\t\t\t\t\tfXercesProperties=null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(propertiesFileExists){\n\t\t\t\t\t\tloadProperties=true;\n\t\t\t\t\t\tfLastModified=ss.getLastModified(propertiesFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(loadProperties){\n\t\t\t\t\tfXercesProperties=new Properties();\n\t\t\t\t\tFileInputStream fis=ss.getFileInputStream(propertiesFile);\n\t\t\t\t\tfXercesProperties.load(fis);\n\t\t\t\t\tfis.close();\n\t\t\t\t}\n\t\t\t} catch (Exception x){\n\t\t\t\tfXercesProperties=null;\n\t\t\t\tfLastModified=-1;\n\t\t\t} \n\t\t}\n\t\tif(fXercesProperties != null){\n\t\t\tfactoryClassName=fXercesProperties.getProperty(factoryId);\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tFileInputStream fis=ss.getFileInputStream(new File(propertiesFilename));\n\t\t\tProperties props=new Properties();\n\t\t\tprops.load(fis);\n\t\t\tfis.close();\n\t\t\tfactoryClassName=props.getProperty(factoryId);\n\t\t} catch (Exception x){\n\t\t} \n\t}\n\tif(factoryClassName != null){\n\t\tif(DEBUG)\n\t\t\tdebugPrintln(\"found in \" + propertiesFilename + \", value=\"+ factoryClassName);\n\t\treturn newInstance(factoryClassName,cl,true);\n\t}\n\tObject provider=findJarServiceProvider(factoryId);\n\tif(provider != null){\n\t\treturn provider;\n\t}\n\tif(fallbackClassName == null){\n\t\tthrow new ConfigurationError(\"Provider for \" + factoryId + \" cannot be found\",null);\n\t}\n\tif(DEBUG)\n\t\tdebugPrintln(\"using fallback, value=\" + fallbackClassName);\n\treturn newInstance(fallbackClassName,cl,true);\n}","type":"T3"}}}